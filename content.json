{"meta":{"title":"Hsueh's Blog","subtitle":"","description":"","author":"Hsueh-","url":"https://hsueh37.gitee.io/blog","root":"/blog/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-04-28T09:02:42.257Z","updated":"2020-04-28T09:02:42.257Z","comments":false,"path":"/404.html","permalink":"https://hsueh37.gitee.io/blog/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-04-28T09:02:42.279Z","updated":"2020-04-28T09:02:42.279Z","comments":false,"path":"about/index.html","permalink":"https://hsueh37.gitee.io/blog/about/index.html","excerpt":"","text":"Hsueh’s Blog在读本科大学生现役ACMerQQ：867997466"},{"title":"分类","date":"2020-04-28T09:02:42.280Z","updated":"2020-04-28T09:02:42.280Z","comments":false,"path":"categories/index.html","permalink":"https://hsueh37.gitee.io/blog/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-04-28T09:02:42.282Z","updated":"2020-04-28T09:02:42.282Z","comments":true,"path":"links/index.html","permalink":"https://hsueh37.gitee.io/blog/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-28T09:02:42.283Z","updated":"2020-04-28T09:02:42.283Z","comments":false,"path":"tags/index.html","permalink":"https://hsueh37.gitee.io/blog/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-04-28T09:02:42.282Z","updated":"2020-04-28T09:02:42.282Z","comments":false,"path":"repository/index.html","permalink":"https://hsueh37.gitee.io/blog/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Domjudge安装记录","slug":"Domjudge安装记录","date":"2020-12-01T12:51:46.000Z","updated":"2020-12-10T13:52:20.010Z","comments":true,"path":"2020/12/01/Domjudge安装记录/","link":"","permalink":"https://hsueh37.gitee.io/blog/2020/12/01/Domjudge%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/","excerpt":"","text":"本文参考于：https://github.com/cn-xcpc-tools/cn-xcpc-docs 前期准备 腾讯云学生机 Ubuntu Server 18.04.1 LTS 64位 安装依赖包和功能1sudo apt-get upgrade &amp;&amp; sudo apt-get update 1234567sudo apt install gcc g++ make zip unzip mariadb-server \\ apache2 php php-cli libapache2-mod-php php-zip \\ php-gd php-curl php-mysql php-json php-xml php-intl php-mbstring \\ acl bsdmainutils ntp phpmyadmin python-pygments \\ libcgroup-dev linuxdoc-tools linuxdoc-tools-text \\ groff texlive-latex-recommended texlive-latex-extra \\ texlive-fonts-recommended texlive-lang-european composer 安装时选择 apache2 1sudo apt install libcurl4-gnutls-dev libjsoncpp-dev libmagic-dev 1sudo phpenmod json 编译Domjudge domjudge-7.1.1.tar.gz 12cd Downloadswget https://www.domjudge.org/releases/domjudge-7.1.1.tar.gz 1tar -zxvf domjudge-7.1.1.tar.gz 1234cd domjudge-7.1.1./configure --prefix=/opt/domjudge --with-baseurl=127.0.0.1make domserver &amp;&amp; sudo make install-domservermake docs &amp;&amp; sudo make install-docs 配置数据库12cd &#x2F;opt&#x2F;domjudge&#x2F;domserversudo bin&#x2F;dj_setup_database -u root install 配置 Web 服务器123456cd /opt/domjudge/domserversudo ln -s /opt/domjudge/domserver/etc/apache.conf /etc/apache2/conf-available/domjudge.confsudo a2enmod rewritesudo a2enconf domjudgesudo systemctl reload apache2sudo chown www-data:www-data -R /opt/domjudge/domserver/webapp/var/* 现在你应该可以访问 http://127.0.0.1/domjudge 或者公网并使用用户名 admin 与 /opt/domjudge/domserver/etc/initial_admin_password.secret 内生成的密码登录 domjudge 后台了。 配置 MySQL编辑 /etc/mysql/conf.d/mysql.cnf，追加以下内容： 1234[mysqld]max_connections = 1000max_allowed_packet = 16MBinnodb_log_file_size = 48MB 其中 max_allowed_packet 数值改成两倍于题目测试数据文件的大小，innodb_log_file_size 数值改成十倍于题目测试数据文件的大小。 1sudo systemctl restart mysql 配置php编辑 /opt/domjudge/domserver/etc/apache.conf，取消以下几行内容前的注释： 123456&lt;IfModule mod_php7.c&gt;php_value max_file_uploads 101php_value upload_max_filesize 128Mphp_value post_max_size 128Mphp_value memory_limit 512M&lt;/IfModule&gt; 编辑 /etc/php/7.2/apache2/php.ini，搜索 date.timezone 关键字，取消其行前注释，并将其值设为 Asia/Shanghai。搜索 max_execution_time 关键字，将其值由30改为300，防止生成队伍密码时 PHP 执行超时。 1sudo systemctl restart apache2 配置 Apache编辑 /etc/apache2/apache2.conf，搜索 KeepAlive 关键字，将其值设为 Off，并在其后新增一行内容： 1MaxClients 1000 1sudo systemctl restart apache2 搭建judgehost准备工作安装依赖包和功能123456sudo apt-get upgrade &amp;&amp; sudo apt-get updatesudo apt install make sudo debootstrap libcgroup-dev lsof zip unzip\\ php-cli php-curl php-json php-xml php-zip procps \\ gcc g++ openjdk-8-jre-headless \\ openjdk-8-jdk ghc fp-compiler \\ libcurl4-gnutls-dev libjsoncpp-dev libmagic-dev 编译 Domjudge123456cd Downloadswget https://www.domjudge.org/releases/domjudge-7.1.1.tar.gztar -zxvf domjudge-7.1.1.tar.gzcd domjudge-7.1.1./configure --prefix=/opt/domjudge --with-baseurl=127.0.0.1make judgehost &amp;&amp; sudo make install-judgehost 这会将 judgehost 安装在 /opt/domjudge/judgehost 里。 配置 judgehost添加用户12345678useradd -d /nonexistent -U -M -s /bin/false domjudge-run# 如果 judgehost 拥有多个 CPU 核心，你可以添加额外的用户来支持绑定# 不同的 judgehost 进程到不同的 CPU 核心上，如下：useradd -d /nonexistent -U -M -s /bin/false domjudge-run-0useradd -d /nonexistent -U -M -s /bin/false domjudge-run-1useradd -d /nonexistent -U -M -s /bin/false domjudge-run-2useradd -d /nonexistent -U -M -s /bin/false domjudge-run-3# ... 如果有更多的 CPU 核心，请自行添加更多的用户 配置 sudoers将 /opt/domjudge/judgehost/etc/sudoers-domjudge 复制到 /etc/sudoers.d/ 目录下。 1sudo cp /opt/domjudge/judgehost/etc/sudoers-domjudge /etc/sudoers.d/ 修改 rest 密码使用 vim 等文本编辑器编辑 /opt/domjudge/judgehost 目录下 etc/restapi.secret 这个文件。文件的格式为： 1default http://example.edu/domjudge/api/ judgehosts MzfJYWF5agSlUfmiGEy5mgkfqU 注意不要有空行 格式为 endpoint api_url username password ，endpoint 可以保持不变，api_url 根据 judgeserver 的地址进行修改，username 和 password 要与 domserver上的 etc/restapi.secret 保持一致。 构建 chroot 环境使用 vim 等文本编辑器编辑 ~/domjudge/judgehost/bin/dj_make_chroot 脚本，将 ubuntu 镜像改为国内源。（第 172 行） 12# Ubuntu mirror, modify to match closest mirror[ -z \"$DEBMIRROR\" ] &amp;&amp; DEBMIRROR=\"http://mirrors.aliyun.com/ubuntu/\" 修改之后保存并运行此脚本(bash 运行)。这一步会从源上下载必要的软件包，所以请耐心等待。 设置cgroup使用 vim 等文本编辑器编辑 /etc/default/grub 这个文件，对其中的这一行做如下修改： 1GRUB_CMDLINE_LINUX_DEFAULT=\"quiet cgroup_enable=memory swapaccount=1\" 如果下面的步骤仍然报错 那就修改 1GRUB_CMDLINE_LINUX=\"quiet cgroup_enable=memory swapaccount=1\" 然后执行： 1update-grub 之后重启计算机。 启动 judgehost如果需要使用cgroup，则每次重启之后都要运行 /opt/domjudge/judgehost/bin/create_cgroups/opt/domjudge/judgehost/bin/judgedaemon 即可启动，若提示 error: Call to undefined function curl_init()，则可以安装 php-curl 解决 如果想要断开连接并且还可以正常使用判题机，这样来 12bash /opt/domjudge/judgehost/bin/create_cgroupsnohup /opt/domjudge/judgehost/bin/judgedaemon &amp; 退出连接的时候记得用exit，不要直接关闭 到这里，domjudge就可以正常投入使用了。 配置多 judgehost 的 systemd 及 rsyslog使用 vim 等文本编辑器在 /lib/systemd/system 下新建一个文本文件叫做 create-cgroups.service，写入下列内容： 1234567[Unit]Description=Make sure cgroups exist for DOMjudge judgedaemon[Service]Type=oneshotExecStart=/opt/domjudge/judgehost/bin/create_cgroupsRemainAfterExit=true 在 /lib/systemd/system 下再新建一个文本文件叫做 domjudge-judgehost@.service，写入下列内容： 注意 User=&lt;username&gt; 要用自己编译 judgehost 时的用户名，因为 /etc/sudoers.d/sudoers-domjudge 列表里是当时的用户 12345678910111213141516171819202122[Unit]Description=DOMjudge JudgeDaemonRequires=create-cgroups.serviceAfter=create-cgroups.serviceAfter=network.target[Service]Type=simpleExecStart=/opt/domjudge/judgehost/bin/judgedaemon -n %iUser=&lt;username&gt;Restart=alwaysRestartSec=3PrivateTmp=yesStandardOutput=syslogStandardError=syslogSyslogIdentifier=judgehost-%i[Install]WantedBy=multi-user.target 在 /etc/rsyslog.d/ 下新建一个文本文件叫做 judgehost.conf，写入下列内容： 1234:programname, isequal, \"judgehost-0\" /var/log/judgehost/judgehost-0.log:programname, isequal, \"judgehost-1\" /var/log/judgehost/judgehost-1.log:programname, isequal, \"judgehost-2\" /var/log/judgehost/judgehost-2.log:programname, isequal, \"judgehost-3\" /var/log/judgehost/judgehost-3.log 重启日志服务，启动四个 judgehost： 12345sudo systemctl restart rsyslogsudo systemctl start domjudge-judgehost@0sudo systemctl start domjudge-judgehost@1sudo systemctl start domjudge-judgehost@2sudo systemctl start domjudge-judgehost@3 judgedaemon的日志会保存在 /var/log/judgehost 下 一些杂项 script123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384./configure --prefix=/opt/domjudge --with-baseurl=127.0.0.1wget https://dup4.top/attachments/domjudge-7.1.1.tar.gzdefault http://localhost/domjudge/api judgehost 123456sudo useradd -d /nonexistent -U -M -s /bin/false domjudge-run-0sudo useradd -d /nonexistent -U -M -s /bin/false domjudge-run-1sudo useradd -d /nonexistent -U -M -s /bin/false domjudge-run-2sudo useradd -d /nonexistent -U -M -s /bin/false domjudge-run-3sudo useradd -d /nonexistent -U -M -s /bin/false domjudge-run-4sudo useradd -d /nonexistent -U -M -s /bin/false domjudge-run-5sudo useradd -d /nonexistent -U -M -s /bin/false domjudge-run-6sudo useradd -d /nonexistent -U -M -s /bin/false domjudge-run-7sudo useradd -d /nonexistent -U -M -s /bin/false domjudge-run-8sudo useradd -d /nonexistent -U -M -s /bin/false domjudge-run-9sudo useradd -d /nonexistent -U -M -s /bin/false domjudge-run-10sudo useradd -d /nonexistent -U -M -s /bin/false domjudge-run-11sudo useradd -d /nonexistent -U -M -s /bin/false domjudge-run-12sudo useradd -d /nonexistent -U -M -s /bin/false domjudge-run-13sudo useradd -d /nonexistent -U -M -s /bin/false domjudge-run-14sudo useradd -d /nonexistent -U -M -s /bin/false domjudge-run-15sudo useradd -d /nonexistent -U -M -s /bin/false domjudge-run-16sudo vim /lib/systemd/system/domjudge-judgehost@.servicesudo vim /etc/rsyslog.d/judgehost.conf:programname, isequal, \"judgehost-0\" /var/log/judgehost/judgehost-0.log:programname, isequal, \"judgehost-1\" /var/log/judgehost/judgehost-1.log:programname, isequal, \"judgehost-2\" /var/log/judgehost/judgehost-2.log:programname, isequal, \"judgehost-3\" /var/log/judgehost/judgehost-3.log:programname, isequal, \"judgehost-3\" /var/log/judgehost/judgehost-4.log:programname, isequal, \"judgehost-3\" /var/log/judgehost/judgehost-5.log:programname, isequal, \"judgehost-3\" /var/log/judgehost/judgehost-6.log:programname, isequal, \"judgehost-3\" /var/log/judgehost/judgehost-7.log:programname, isequal, \"judgehost-3\" /var/log/judgehost/judgehost-8.log:programname, isequal, \"judgehost-3\" /var/log/judgehost/judgehost-9.log:programname, isequal, \"judgehost-3\" /var/log/judgehost/judgehost-10.log:programname, isequal, \"judgehost-3\" /var/log/judgehost/judgehost-11.log:programname, isequal, \"judgehost-3\" /var/log/judgehost/judgehost-12.log:programname, isequal, \"judgehost-3\" /var/log/judgehost/judgehost-13.log:programname, isequal, \"judgehost-3\" /var/log/judgehost/judgehost-14.log:programname, isequal, \"judgehost-3\" /var/log/judgehost/judgehost-15.log:programname, isequal, \"judgehost-3\" /var/log/judgehost/judgehost-16.log#重启judgesudo systemctl restart rsyslogsudo systemctl start domjudge-judgehost@0sudo systemctl start domjudge-judgehost@1sudo systemctl start domjudge-judgehost@2sudo systemctl start domjudge-judgehost@3sudo systemctl start domjudge-judgehost@4sudo systemctl start domjudge-judgehost@5sudo systemctl start domjudge-judgehost@6sudo systemctl start domjudge-judgehost@7sudo systemctl start domjudge-judgehost@8sudo systemctl start domjudge-judgehost@9sudo systemctl start domjudge-judgehost@10sudo systemctl start domjudge-judgehost@11sudo systemctl start domjudge-judgehost@12sudo systemctl start domjudge-judgehost@13sudo systemctl start domjudge-judgehost@14sudo systemctl start domjudge-judgehost@15sudo systemctl start domjudge-judgehost@16#设置开机启动sudo systemctl enable domjudge-judgehost@0sudo systemctl enable domjudge-judgehost@1sudo systemctl enable domjudge-judgehost@2sudo systemctl enable domjudge-judgehost@3sudo systemctl enable domjudge-judgehost@4sudo systemctl enable domjudge-judgehost@5sudo systemctl enable domjudge-judgehost@6sudo systemctl enable domjudge-judgehost@7sudo systemctl enable domjudge-judgehost@8sudo systemctl enable domjudge-judgehost@9sudo systemctl enable domjudge-judgehost@10sudo systemctl enable domjudge-judgehost@11sudo systemctl enable domjudge-judgehost@12sudo systemctl enable domjudge-judgehost@13sudo systemctl enable domjudge-judgehost@14sudo systemctl enable domjudge-judgehost@15sudo systemctl enable domjudge-judgehost@16","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://hsueh37.gitee.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"2020年CCCC-总决赛","slug":"2020年CCCC-总决赛","date":"2020-11-30T04:00:00.000Z","updated":"2020-11-30T04:25:01.766Z","comments":true,"path":"2020/11/30/2020年CCCC-总决赛/","link":"","permalink":"https://hsueh37.gitee.io/blog/2020/11/30/2020%E5%B9%B4CCCC-%E6%80%BB%E5%86%B3%E8%B5%9B/","excerpt":"","text":"写在前面因为考研，所以没参加，但是早上忍不住还是打了补题场，9点开打，大概三小时不到一点，然后261/290分，还可以吧 L1-1 嫑废话上代码 (5分)1print(\"Talk is cheap. Show me the code.\") L1-2 猫是液体 (5分)123456789#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main() &#123; int a, b, c; scanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c); printf(\"%d\", a * b * c); return 0;&#125; L1-3 洛希极限(10分)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;void RUN() &#123; db a, b; int op; while (cin &gt;&gt; a &gt;&gt; op &gt;&gt; b) &#123; op = !op; db res = a * (op ? 2.455 : 1.26); if (res &gt; b) &#123; cout &lt;&lt; res &lt;&lt; \" T_T\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; res &lt;&lt; \" ^_^\" &lt;&lt; endl; &#125; &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(2); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; L1-4 调和平均 (10分)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;int n;db a[N];void RUN() &#123; scanf(\"%d\", &amp;n); db sum = 0, x; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%lf\", &amp;x); sum += 1.0 / x; &#125; sum = n / sum; printf(\"%.2f\\n\", sum);&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input\", \"r\", stdin);#endif RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; L1-5 胎压监测 (15分)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;int a[10];void RUN() &#123; for (int i = 1; i &lt;= 6; ++i) &#123; cin &gt;&gt; a[i]; &#125; int Max = a[1]; for (int i = 1; i &lt;= 4; ++i) Max = max(Max, a[i]); vector&lt;int&gt; vec; for (int i = 1; i &lt;= 4; ++i) &#123; if (abs(a[i] - Max) &gt; a[6] || a[i] &lt; a[5]) vec.push_back(i); &#125; if (vec.empty()) cout &lt;&lt; \"Normal\" &lt;&lt; endl; else if (vec.size() == 1) &#123; cout &lt;&lt; \"Warning: please check #\" &lt;&lt; vec[0] &lt;&lt; \"!\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"Warning: please check all the tires!\" &lt;&lt; endl; &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; L1-6 吃火锅 (15分)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;int n;string s, str = \"chi1 huo3 guo1\";vector&lt;int&gt; vec;void RUN() &#123; int len = str.size(); while (getline(cin, s)) &#123; if (s == \".\") break; ++n; if (s.find(str) != s.npos) &#123; vec.push_back(n); &#125; &#125; cout &lt;&lt; n &lt;&lt; endl; if (vec.empty()) &#123; cout &lt;&lt; \"-_-#\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; vec[0] &lt;&lt; \" \" &lt;&lt; vec.size() &lt;&lt; endl; &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(2); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; L1-7 前世档案 (20分)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;int m, n;string s;void RUN() &#123; cin &gt;&gt; m &gt;&gt; n; ll begin = 1ll &lt;&lt; m; --begin; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; s; ll id = 1; for (auto it : s) &#123; if (it == 'y') id = id &lt;&lt; 1; else id = id &lt;&lt; 1 | 1; &#125; cout &lt;&lt; id - begin &lt;&lt; endl; &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; L1-8 刮刮彩票 (20分)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;int a[4][4], vis[10];int sum[] = &#123;10000, 36, 720, 360, 80, 252, 108, 72, 54, 180, 72, 180, 119, 36, 306, 1080, 144, 1800, 3600&#125;;void RUN() &#123; int x = 0, y = 0; for (int i = 1; i &lt;= 3; ++i) &#123; for (int j = 1; j &lt;= 3; ++j) &#123; cin &gt;&gt; a[i][j]; if (!a[i][j]) &#123; x = i, y = j; &#125; else &#123; vis[a[i][j]] = 1; &#125; &#125; &#125; for (int i = 1; i &lt;= 9; ++i) if (!vis[i]) a[x][y] = i; for (int i = 1; i &lt;= 3; ++i) &#123; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; a[x][y] &lt;&lt; endl; &#125; int op; cin &gt;&gt; op; int cnt = 0; if (op &lt;= 3) &#123; for (int i = 1; i &lt;= 3; ++i) &#123; cnt += a[op][i]; &#125; &#125; else if (op &lt;= 6) &#123; for (int i = 1; i &lt;= 3; ++i) &#123; cnt += a[i][op - 3]; &#125; &#125; else if (op == 7) &#123; for (int i = 1; i &lt;= 3; ++i) &#123; cnt += a[i][i]; &#125; &#125; else &#123; for (int i = 1, j = 3; i &lt;= 3; ++i, --j) &#123; cnt += a[i][j]; &#125; &#125; cout &lt;&lt; sum[cnt - 6] &lt;&lt; endl;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; L2-1 简单计算器 (25分)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;int n;stack&lt;int&gt; num;stack&lt;string&gt; op;void RUN() &#123; cin &gt;&gt; n; for (int i = 1, x; i &lt;= n; ++i) &#123; cin &gt;&gt; x; num.push(x); &#125; string s; for (int i = 2; i &lt;= n; ++i) &#123; cin &gt;&gt; s; op.push(s); &#125; for (int i = 2; i &lt;= n; ++i) &#123; int n1 = num.top(); num.pop(); int n2 = num.top(); num.pop(); s = op.top(); op.pop(); if (s == \"+\") n1 = n2 + n1; else if (s == \"-\") n1 = n2 - n1; else if (s == \"*\") n1 = n2 * n1; else if (s == \"/\") &#123; if (n1 == 0) &#123; cout &lt;&lt; \"ERROR: \" &lt;&lt; n2 &lt;&lt; \"/\" &lt;&lt; n1 &lt;&lt; endl; return; &#125; n1 = n2 / n1; &#125; num.push(n1); &#125; cout &lt;&lt; num.top() &lt;&lt; endl;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; L2-2 口罩发放 (25分)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;struct E &#123; string name, id, time; int idx; int op; bool input(int _idx) &#123; cin &gt;&gt; name &gt;&gt; id &gt;&gt; op &gt;&gt; time; idx = _idx; if (id.size() != 18) return false; for (auto it : id) &#123; if (it &lt; '0' || it &gt; '9') return false; &#125; return true; &#125; void out() &#123; cout &lt;&lt; name &lt;&lt; \" \" &lt;&lt; id &lt;&lt; endl; &#125; bool operator&lt;(const E &amp;other) &#123; if (time == other.time) return idx &lt; other.idx; return time &lt; other.time; &#125;&#125;a[N];int d, p, n, m;map&lt;string, int&gt; mp;vector&lt;E&gt; V;void gao(int day) &#123; cin &gt;&gt; n &gt;&gt; m; vector&lt;E&gt; vec; for (int i = 1; i &lt;= n; ++i) &#123; bool F = a[i].input(i); if (F) &#123; if (a[i].op == 1) V.push_back(a[i]); vec.push_back(a[i]); &#125; &#125; sort(vec.begin(), vec.end()); for (auto it : vec) &#123; if (!m) &#123; continue; &#125; if (!mp.count(it.id) || day &gt; mp[it.id] + p) &#123; mp[it.id] = day; --m; it.out(); &#125; &#125;&#125;void RUN() &#123; cin &gt;&gt; d &gt;&gt; p; for (int i = 1; i &lt;= d; ++i) &#123; gao(i); &#125; mp.clear(); for (auto it : V) &#123; if (mp.count(it.id)) continue; it.out(); mp[it.id]++; &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); RUN();#ifdef LOCAL_JUDGE// cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; L2-3 完全二叉树的层序遍历 (25分)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;int n;int a[N];int t[N];int idx = 1;void gao(int id) &#123; if (id &gt; n) return; gao(id &lt;&lt; 1); gao(id &lt;&lt; 1 | 1); t[id] = a[idx++];&#125;void RUN() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125; gao(1); for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; t[i] &lt;&lt; \" \\n\"[i == n];&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; L2-4 网红点打卡攻略 (25分)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e2 + 10;int n, m;int G[N][N];int Max = 0x3f3f3f3f, ans = -1, cnt;int a[N];void gao(int id) &#123; cin &gt;&gt; m; set&lt;int&gt; s; for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; a[i]; s.insert(a[i]); &#125; if (m != n) return; if (s.size() != n) return; int res = 0, pre = 0; for (int i = 1; i &lt;= m; ++i) &#123; if (G[pre][a[i]] == 0x3f3f3f3f) return; res += G[pre][a[i]]; pre = a[i]; &#125; if (G[a[m]][0] == 0x3f3f3f3f) return; res += G[a[m]][0]; ++cnt; if (res &lt; Max) ans = id, Max = res;&#125;void RUN() &#123; memset(G, 0x3f, sizeof G); cin &gt;&gt; n &gt;&gt; m; for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; G[u][v] = w; G[v][u] = w; &#125; int q; cin &gt;&gt; q; for (int i = 1; i &lt;= q; ++i) &#123; gao(i); &#125; cout &lt;&lt; cnt &lt;&lt; endl; cout &lt;&lt; ans &lt;&lt; \" \" &lt;&lt; Max &lt;&lt; endl;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; L3-1 那就别担心了 (30分)垃圾题目，关于Yes/No只需要从A出发，然后只要一个终点就好了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl; cout.flush();&#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 5e2 + 10;int n, m, st, ed;int in_degree[N], out_degree[N], back_in_degree[N], vis[N];int cnt[N], g[N][N];vector&lt;vector&lt;int&gt;&gt; G, R;void BFS(int rt) &#123; queue&lt;int&gt; q; q.push(rt); while (!q.empty()) &#123; int u = q.front(); q.pop(); if (vis[u]) continue; vis[u] = true; for (auto it : R[u]) &#123; q.push(it); g[u][it] = 1; out_degree[u]++; &#125; &#125;&#125;void gao() &#123; for (int k = 1; k &lt;= n; ++k) &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; g[i][j] += g[i][k] * g[k][j]; &#125; &#125; &#125; cout &lt;&lt; g[st][ed] &lt;&lt; \" \"; if (g[st][ed] == 0) &#123; cout &lt;&lt; \"No\" &lt;&lt; endl; return; &#125; vector&lt;int&gt; vec; for (int i = 1; i &lt;= n; ++i) &#123; if (vis[i] &amp;&amp; out_degree[i] == 0) &#123; vec.push_back(i); &#125; &#125; if (vec.size() == 1)cout &lt;&lt; \"Yes\" &lt;&lt; endl; else cout &lt;&lt; \"No\" &lt;&lt; endl;&#125;void RUN() &#123; cin &gt;&gt; n &gt;&gt; m; G.resize(n + 1); R.resize(n + 1); for (int i = 1, u, v; i &lt;= m; ++i) &#123; cin &gt;&gt; u &gt;&gt; v; R[u].push_back(v); &#125; cin &gt;&gt; st &gt;&gt; ed; BFS(st); gao();&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; L3-2 传送门 (18/30分)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;struct E &#123; int x1, x2, y; E() &#123;&#125; E(int x1, int x2, int y) : x1(x1), x2(x2), y(y) &#123;&#125;; bool operator&lt;(const E &amp;other) const &#123; if (y != other.y) return y &lt; other.y; else &#123; if (x1 != other.x1) return x1 &lt; other.x1; else return x2 &lt; other.x2; &#125; &#125;&#125;;int n, m;ll f[N];set&lt;E&gt; s;string op;void gao() &#123; for (int i = 1; i &lt;= n; ++i) f[i] = i; for (auto it : s) &#123; swap(f[it.x1], f[it.x2]); &#125; ll res = 0; for (int i = 1; i &lt;= n; ++i) res += i * f[i]; cout &lt;&lt; res &lt;&lt; endl;&#125;void RUN() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1, a, b, c; i &lt;= m; ++i) &#123; cin &gt;&gt; op &gt;&gt; a &gt;&gt; b &gt;&gt; c; if (op == \"+\") s.insert(E(a, b, c)); else s.erase(E(a, b, c)); gao(); &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; L3-3 可怜的复杂度 (13/30分)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;int n, m;int b[N], a[N];map&lt;vector&lt;int&gt;, int&gt; mp;ll res;int f() &#123; mp.clear(); for (int l = 1; l &lt;= n; ++l) &#123; vector&lt;int&gt; vec; for (int r = l; r &lt;= n; ++r) &#123; vec.push_back(a[r]); mp[vec]++; &#125; &#125; return mp.size();&#125;void gao(int x) &#123; if (x == n + 1) &#123; res += f(); return; &#125; for (int i = 1; i &lt;= m; ++i) &#123; a[x] = m * b[x] + i; gao(x + 1); &#125;&#125;void RUN() &#123; res = 0; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; b[i]; &#125; gao(1); cout &lt;&lt; res &lt;&lt; endl;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); int _T; cin &gt;&gt; _T; while (_T--) &#123; RUN(); &#125;#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://hsueh37.gitee.io/blog/tags/ACM/"}]},{"title":"个人足迹图绘制","slug":"个人足迹图绘制","date":"2020-10-10T01:40:00.000Z","updated":"2020-10-10T12:04:51.255Z","comments":true,"path":"2020/10/10/个人足迹图绘制/","link":"","permalink":"https://hsueh37.gitee.io/blog/2020/10/10/%E4%B8%AA%E4%BA%BA%E8%B6%B3%E8%BF%B9%E5%9B%BE%E7%BB%98%E5%88%B6/","excerpt":"","text":"travel_config.yml 12345678910111213141516171819202122浙江: - 杭州江西: - 南昌吉林: - 吉林辽宁: - 沈阳河北: - 秦皇岛广东: - 深圳江苏: - 南京福建: - 厦门陕西: - 西安山东: - 青岛北京: - 北京 main.py 123456789101112131415161718192021222324# -*- coding: utf-8 -*-import yamlfrom pyecharts.charts import Mapfrom pyecharts import options as opts# 省和直辖市with open(\"travel_config.yml\", 'r', encoding='utf-8') as ymlfile: province_city_dict = yaml.safe_load(ymlfile)province_dict = dict(zip(province_city_dict.keys(), [1] * len(province_city_dict.keys())))print(province_dict)# maptype='china' 只显示全国直辖市和省级map = Map(init_opts=opts.InitOpts(width='1200px', height='800px'))map.set_global_opts( title_opts=opts.TitleOpts(title=\"个人足迹地图\"), visualmap_opts=opts.VisualMapOpts(max_=1, is_piecewise=True, pieces=[ &#123;\"max\": 1, \"min\": 1, \"label\": \"去过\", \"color\": \"#4EA397\"&#125;, &#123;\"max\": 0, \"min\": 0, \"label\": \"未去过\", \"color\": \"#FFFFFF\"&#125;, ]) # 最大数据范围，分段)map.add(\"个人足迹地图\", data_pair=province_dict.items(), maptype=\"china\", is_roam=True)map.render('全国.html')","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"https://hsueh37.gitee.io/blog/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"Ubuntu部署django","slug":"Ubuntu部署django","date":"2020-05-06T00:51:46.000Z","updated":"2020-05-06T01:12:08.050Z","comments":true,"path":"2020/05/06/Ubuntu部署django/","link":"","permalink":"https://hsueh37.gitee.io/blog/2020/05/06/Ubuntu%E9%83%A8%E7%BD%B2django/","excerpt":"","text":"写在前面又是工具人的一天 环境配置 ubuntu16.04 python3.7.1 nginx uwsgi python3.7.1 安装 安装环境依赖 123sudo apt-get install zlib1g-dev libbz2-dev libssl-dev libncurses5-dev libsqlite3-dev libreadline-dev tk-dev libgdbm-dev libdb-dev libpcap-dev xz-utils libexpat1-dev liblzma-dev libffi-dev libc6-dev 下载python3.7.1 安装包 1wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgz 解压 1tar -zxvf Python-3.7.1 进入解压目录 1cd Python-3.7.1/ 创建安装目录 1sudo mkdir -p &#x2F;usr&#x2F;local&#x2F;python3 编译安装 123./configure --prefix=/usr/local/python3 --enable-optimizationsmakesudo make install 删除原来的软连接 12rm -rf /usr/bin/python3rm -rf /usr/bin/pip3 建立新的软连接 1234#添加python3的软链接ln -s /usr/local/python3/bin/python3.7 /usr/bin/python3#添加 pip3 的软链接ln -s /usr/local/python3/bin/pip3.7 /usr/bin/pip3 检查版本 12python3 -Vpip3 -V 获取项目文件 新建 or git 得到项目文件 创建虚拟环境 1234pip3 install virtualenv# 清华源安装方式 pip3 install virtualenv -i https://pypi.python.org/simple/python3 -m venv env# env为虚拟环境名字 激活环境 12source env/bin/activate# 退出虚拟环境 deactivate 安装对应的库 1pip install -r requirements.txt uwsgi配置 安装uwsgi 1pip install uwsgi 测试uwsgi 1uwsgi --http :8000 --file web/wsgi.py --static-map=/static=static 访问localhost:8000 看能否访问 新建uwsgi文件 1vim uwsgi.ini 12345678910[uwsgi]master = trueprocesses = 1threads = 2chdir = /www/wwwroot/project_plane/web/ # mangge.py 目录wsgi-file= /www/wwwroot/project_plane/web/web/wsgi.py # wsgi.py 路径http = 0.0.0.0:8080 # 运行端口chmod-socket = 660vacuum = truemax-requests = 1000 运行uwsgi文件 1uwsgi --ini uwsgi.ini 查看否有报错 如果有则可以访问 localhost:8080 到这里uwsgi就配置完成了 nginx配置安装宝塔后新建站点 添加反向代理 到这里 就算部署完成了","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://hsueh37.gitee.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"v2rayN搭建","slug":"v2rayN搭建","date":"2020-03-20T14:54:48.000Z","updated":"2020-11-30T05:04:49.599Z","comments":true,"path":"2020/03/20/v2rayN搭建/","link":"","permalink":"https://hsueh37.gitee.io/blog/2020/03/20/v2rayN%E6%90%AD%E5%BB%BA/","excerpt":"","text":"写在前面前段时间沉迷VPS,就用手头的VPS搭建了v2rayN 宝塔安装1curl -sSO http://download.bt.cn/install/new_install.sh &amp;&amp; bash new_install.sh 安装时，一路默认即可，该输入 Y 的输入 Y，没什么难度。 安装完成，会出现面板地址及默认账号与密码，如下图。（注意新版本在端口号后面还有一个字符串，一定要全部保存,） 如果不记得了可以通过 1bt default 查看 进入对应的地址后，只选择安装nginx 然后添加站点 安装v2rayN通过官方脚本安装 1bash &lt;(curl -L -s https://install.direct/go.sh) 记住你的port和UUID 如果不记得了可以通过 1234# 查看端口 Portcat /etc/v2ray/config.json | grep port# 查看 id (UUID)cat /etc/v2ray/config.json | grep id 然后配置网站的SSL 通知勾选强制HTTPS 修改配置文件：接下来进入 修改网站配置文件 点击配置文件，找到 #SSL-END，大概在 22 行左右，在其下面添加如下代码： 12345678910location /cs&#123; proxy_pass http://127.0.0.1:你的端口号; proxy_redirect off; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $http_host; proxy_read_timeout 300s;&#125; 1、其中第一行的 cs 是你自己 ws 的 path，斜杠不要删除，可以自己修改,也可以不改；2、还记得用官方脚本安装 v2ray 后出现的 port 吗，我叫大家记住的，这个 port 后面的就是你的端口号。修改上面代码后保存，如下图： 接下来才是重点，配置 V2ray 配置文件：进入 /etc/v2ray 目录，编辑 config.json 文件 将里面全部代码改为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&#123; \"policy\": &#123; \"levels\": &#123; \"0\": &#123; \"uplinkOnly\": 0, \"downlinkOnly\": 0, \"connIdle\": 150, \"handshake\": 4 &#125; &#125; &#125;, \"inbound\": &#123; \"listen\": \"127.0.0.1\", \"port\": 31914, //这里填写你的 v2ray 端口号，复制脚本请产出这句注释 \"protocol\": \"vmess\", \"settings\": &#123; \"clients\": [ &#123; \"id\": \"e1bc89df-c245-4da6-90cc-2d20ad80a611\", //这里填写你的 v2ray UUID，复制脚本请删除这句注释 \"level\": 1, \"alterId\": 32 &#125; ] &#125;, \"streamSettings\": &#123; \"network\": \"ws\", \"security\": \"auto\", \"wsSettings\": &#123; \"path\": \"/cs\", //这里填是你自己 ws 的 path,如果修改配置文件的时候没有修改过就不管，复制脚本请删除这句注释 \"headers\": &#123; \"Host\": \"www.xxx.com\" //这里填写你的域名，复制脚本请删除这句注释 &#125; &#125; &#125; &#125;, \"outbound\": &#123; \"protocol\": \"freedom\", \"settings\": &#123; &#125; &#125;, \"outboundDetour\": [ &#123; \"protocol\": \"blackhole\", \"settings\": &#123; &#125;, \"tag\": \"blocked\" &#125; ], \"routing\": &#123; \"strategy\": \"rules\", \"settings\": &#123; \"rules\": [ &#123; \"type\": \"field\", \"ip\": [ \"0.0.0.0/8\", \"10.0.0.0/8\", \"100.64.0.0/10\", \"127.0.0.0/8\", \"169.254.0.0/16\", \"172.16.0.0/12\", \"192.0.0.0/24\", \"192.0.2.0/24\", \"192.168.0.0/16\", \"198.18.0.0/15\", \"198.51.100.0/24\", \"203.0.113.0/24\", \"::1/128\", \"fc00::/7\", \"fe80::/10\" ], \"outboundTag\": \"blocked\" &#125; ] &#125; &#125;&#125; 启动v2rayN 1234#此命令启动 v2raysystemctl start v2ray#更多命令service v2ray start|stop|status|reload|restart|force-reload 客户端配置 杂检测IP是否被封可以通过 https://www.vps234.com/ipchecker/ 进行检测 查看端口可以通过 https://www.toolsdaquan.com/ipcheck/ 测速可以通过 123456# 下载脚本wget https://raw.githubusercontent.com/oooldking/script/master/superspeed.sh # 修改权限chmod +x superspeed.sh# 执行脚本./superspeed.sh 或者 1bash &lt;(curl -Lso- https://git.io/superspeed) v2rayN 代理 git 操作 123456789git config --global http.proxy http://127.0.0.1:10809git config --global https.proxy https://127.0.0.1:10809查看git config –-get –-global http.proxy取消git config --global --unset https.proxygit config --global --unset http.proxy","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://hsueh37.gitee.io/blog/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"牛客小白月赛22 I","slug":"牛客小白月赛22-I","date":"2020-03-02T05:42:03.000Z","updated":"2020-04-28T09:02:42.277Z","comments":true,"path":"2020/03/02/牛客小白月赛22-I/","link":"","permalink":"https://hsueh37.gitee.io/blog/2020/03/02/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B22-I/","excerpt":"","text":"题目传送门 思路:对于每个点都可以通过一些简单计算得到激光枪射中它的最小角度和最大角度,将这些角度排序,枚举起点。 在遍历过程中,对最小角度我们都对这个点进行标记,如果遇到最大角度,那么所有之前标记的点都可以被射中,那么我们就讲这些点的标记清空,最后取最小值即可 时间复杂度$O(n^2)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/* * * Author: Hsueh- * Date: 2020-03-02 13:10:34 * * */#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template &lt;class T, class... Ts&gt;void err(const T&amp; arg, const Ts&amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 5e2 + 10;const db eps = 1e-8, PI = acos(-1.0);int sgn(db x) &#123; if (fabs(x) &lt; eps) return 0; else return x &gt; 0 ? 1 : -1;&#125;struct node &#123; int type; int idx; db angle; node() &#123;&#125; node(int type, int idx, db _angle) : type(type), idx(idx) &#123; angle = fmod(_angle + 2 * PI, 2 * PI); &#125; bool operator&lt;(const node&amp; other) const &#123; if (sgn(angle - other.angle) == 0) return type &lt; other.type; else return angle &lt; other.angle; &#125;&#125;;int n, d;vector&lt;node&gt; vec;int mark[N];void RUN() &#123; cin &gt;&gt; n &gt;&gt; d; vec.clear(); for (int i = 1; i &lt;= n; ++i) &#123; db x, y; cin &gt;&gt; x &gt;&gt; y; db dis = x * x + y * y; if (sgn(dis - d * d) &lt;= 0) continue; db angle = atan2(y, x); db sub = asin(d / sqrt(dis)); vec.push_back(node(0, i, angle - sub)); vec.push_back(node(1, i, angle + sub)); &#125; if (vec.empty()) &#123; cout &lt;&lt; 1 &lt;&lt; endl; return; &#125; sort(all(vec)); int res = vec.size() / 2; // for (auto it : vec) &#123; // dbg(it.idx); // &#125; for (int i = 0, len = vec.size(); i &lt; len; ++i) &#123; vector&lt;int&gt; l; memset(mark, 0, sizeof mark); int tmp = 0; for (int k = 0; k &lt; len; k++) &#123; int j = (i + k) % len; if (vec[j].type == 0) &#123; mark[vec[j].idx] = true; l.push_back(vec[j].idx); &#125; else if (mark[vec[j].idx]) &#123; tmp++; for (auto it : l) &#123; mark[it] = 0; &#125; l.clear(); &#125; &#125; tmp += l.size(); res = min(res, tmp); &#125; cout &lt;&lt; res &lt;&lt; endl;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); int T; cin &gt;&gt; T; for (int cas = 1; cas &lt;= T; ++cas) &#123; RUN(); &#125; return 0;&#125;","categories":[],"tags":[{"name":"nowcoder","slug":"nowcoder","permalink":"https://hsueh37.gitee.io/blog/tags/nowcoder/"}]},{"title":"拉格朗日插值","slug":"拉格朗日插值","date":"2020-03-01T12:44:44.000Z","updated":"2020-04-28T09:02:42.275Z","comments":true,"path":"2020/03/01/拉格朗日插值/","link":"","permalink":"https://hsueh37.gitee.io/blog/2020/03/01/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC/","excerpt":"","text":"拉格朗日差值公式特殊情况如果$P$是一个关于$x$的$n$次多项式,我们已经知道$P(i), i\\in [0, n]$的值,则 P(x) = \\sum_{i = 0}^{n} (-1)^{n - i} P(i) \\frac{x(x-1)(x-2)\\cdots (x-n)}{(n-i)!i!(x-i)}一般情况给出$n+1$个点$x_i$以及值$P(x_i)$,则 P(x) = \\sum_{i=0}^{n}P(x_i) \\prod_{j=0,j\\neq i}^n \\frac{x-x_j}{x_i-x_j}例题洛谷P47811234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const ll p = 998244353;const int N = 2e3 + 10;ll qpow(ll x, ll n) &#123; ll res = 1; while (n) &#123; if (n &amp; 1) res = res * x % p; x = x * x % p; n &gt;&gt;= 1; &#125; return res;&#125;int n, k;ll x[N], y[N];ll gao(ll n, ll K) &#123; ll res = 0; for (int i = 0; i &lt;= n; ++i) &#123; ll tmp = 1; for (int j = 0; j &lt;= n; ++j) &#123; if (i == j) continue; tmp = 1ll * tmp * (K - x[j]) % p * qpow(x[i] - x[j], p - 2) % p; &#125; res = (res + y[i] * tmp % p + p) % p; &#125; return res;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cin &gt;&gt; n &gt;&gt; k; --n; for (int i = 0; i &lt;= n; ++i) &#123; cin &gt;&gt; x[i] &gt;&gt; y[i]; &#125; ll res = gao(n, k); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; The 2019 ICPC China Nanchang National Invitational and International Silk-Road Programming Contest - B Polynomial题意:给出一个关于$x$的$n$次多项式的$f(i), i\\in [0, n]$,问$\\sum_{i=L}^{R} f(i) \\mod 9999991$ 思路:已知一个关于$x$的$n$次多项式的前缀和为一个关于$x$的$n+1$次多项式,于是通过拉格朗日差值得到$f(n+1)$然后再进行拉格朗日差值得到$\\sum_{i=0}^{L} f(i)$以及$\\sum_{i=0}^{R} f(i)$,减一减就可以得到答案 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template &lt;class T, class... Ts&gt;void err(const T&amp; arg, const Ts&amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using pII = pair&lt;int, int&gt;;using ll = long long;using db = double;const int INF = 0x3f3f3f3f;const int N = 1e3 + 10, M = 1e7 + 10;const ll p = 9999991;ll qpow(ll x, ll n) &#123; ll res = 1; while (n) &#123; if (n &amp; 1) res = res * x % p; x = x * x % p; n &gt;&gt;= 1; &#125; return res;&#125;int n, m;ll f[N], fac[N], facinv[N];ll inv[M];ll gao(int _n, int x) &#123; if (x &lt;= _n) return f[x]; int t = (_n &amp; 1) ? -1 : 1; ll res = 0, base = 1; for (int i = 0; i &lt;= _n; ++i) &#123; base = base * (x - i) % p; &#125; for (int i = 0; i &lt;= _n; ++i, t *= -1) &#123; res += 1ll * t * f[i] * base % p * facinv[_n - i] % p * facinv[i] % p * inv[x - i] % p; res = (res + p) % p; &#125; return res;&#125;void RUN() &#123; fac[0] = 1ll; for (int i = 1; i &lt; N; ++i) fac[i] = fac[i - 1] * i % p; facinv[N - 1] = qpow(fac[N - 1], p - 2); for (int i = N - 1; i &gt;= 1; --i) facinv[i - 1] = facinv[i] * i % p; inv[1] = 1; for (int i = 2; i &lt; p; ++i) inv[i] = inv[p % i] * (p - p / i) % p; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 0; i &lt;= n; ++i) &#123; scanf(\"%lld\", f + i); &#125; f[n + 1] = gao(n, n + 1); for (int i = 1; i &lt;= n + 1; ++i) f[i] = (f[i] + f[i - 1]) % p; int l, r; for (int cas = 1; cas &lt;= m; ++cas) &#123; scanf(\"%d %d\", &amp;l, &amp;r); printf(\"%lld\\n\", (gao(n + 1, r) - gao(n + 1, l - 1) + p) % p); &#125; &#125;&#125;int main() &#123; // ios::sync_with_stdio(false); // cin.tie(nullptr), cout.tie(nullptr); // cout &lt;&lt; fixed &lt;&lt; setprecision(20); RUN(); return 0;&#125;","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"https://hsueh37.gitee.io/blog/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"centos7安装python3.7","slug":"centos7安装python3-7","date":"2020-02-28T08:30:08.000Z","updated":"2020-04-28T09:02:42.274Z","comments":true,"path":"2020/02/28/centos7安装python3-7/","link":"","permalink":"https://hsueh37.gitee.io/blog/2020/02/28/centos7%E5%AE%89%E8%A3%85python3-7/","excerpt":"","text":"写在前面由于centos7没有自带的python3,所以需要进行编译安装 安装编译 以及 相关的工具12345yum -y groupinstall \"Development tools\"yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-develyum install libffi-devel -y 下载安装包解压12wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xztar -xvJf Python-3.7.0.tar.xz 编译安装1234mkdir /usr/local/python3 #创建编译安装目录cd Python-3.7.0./configure --prefix=/usr/local/python3make &amp;&amp; make install 创建软连接12ln -s /usr/local/python3/bin/python3 /usr/local/bin/python3ln -s /usr/local/python3/bin/pip3 /usr/local/bin/pip3 验证是否成功12python3 -Vpip3 -V","categories":[],"tags":[{"name":"系统","slug":"系统","permalink":"https://hsueh37.gitee.io/blog/tags/%E7%B3%BB%E7%BB%9F/"}]},{"title":"Python Excel Union","slug":"Python-Excel-Union","date":"2020-02-28T02:03:02.000Z","updated":"2020-04-28T09:02:42.271Z","comments":true,"path":"2020/02/28/Python-Excel-Union/","link":"","permalink":"https://hsueh37.gitee.io/blog/2020/02/28/Python-Excel-Union/","excerpt":"","text":"写在前面由于受不了每次将一堆$excel$整合在一个$excel$中，所以就有了这篇文章 依赖库12import xlrdimport xlsxwriter $xlrd$是$python$中读取$exce$l数据的 $xlsxwriter$是$python$中向$excel$写入数据的 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import osimport datetimeimport xlrdimport xlsxwriter# 遍历的文件目录file_path = 'test'# 合并后的excel存储目录tar_file = file_path + '/mimxed.xlsx'# 遍历目标目录下的所有文件名def all_path(dirname): result = [] # 当前主目录,当前主目录下的所有目录,当前主目录下的所有文件 for maindir, subdir, file_name_list in os.walk(dirname): for filename in file_name_list: if filename.endswith('xls') or filename.endswith('xlsx'): apath = os.path.join(maindir, filename) # 合并成一个完整路径 result.append(apath) return result# 获取excel文件的内容数据def concat_and_insert(fdir): records = [] if len(fdir) &gt; 0: for dir in fdir: # 读取文件 data = xlrd.open_workbook(dir) # 第一个sheet的名字 first_sheet = data.sheet_by_index(0).name # print(dir, '&gt;' * 10, first_sheet) # 获取sheet页的名称 sheet = data.sheet_by_name(first_sheet) # 获取表的数目 nrows = sheet.nrows for i in range(nrows): # 参数可根据实际情况调整 if i &lt; 2: continue if sheet.row_values(i)[2] == '': continue records.append(sheet.row_values(i)) return records# 写入数据def insert_file(alist, tarfile): # 新建目标文件 wh = xlsxwriter.Workbook(tarfile) wadd = wh.add_worksheet('total') if len(alist) &gt; 0: for row_num, row_data in enumerate(alist): wadd.write_row(row_num + 1, 0, row_data) wh.close()def main(): start = datetime.datetime.now() print(start) filename = all_path(file_path) # print(filename) # 获取数据 records = concat_and_insert(filename) # 写入文件 insert_file(records, tar_file) end = datetime.datetime.now() print(end) print(\"持续时间&#123;&#125;\".format(end - start)) print('ok')main()","categories":[],"tags":[{"name":"python tools","slug":"python-tools","permalink":"https://hsueh37.gitee.io/blog/tags/python-tools/"}]},{"title":"Codeforces Round 620 (Div. 2)","slug":"Codeforces_Round_620_(Div.-2)","date":"2020-02-21T04:10:00.000Z","updated":"2020-04-28T09:02:42.265Z","comments":true,"path":"2020/02/21/Codeforces_Round_620_(Div.-2)/","link":"","permalink":"https://hsueh37.gitee.io/blog/2020/02/21/Codeforces_Round_620_(Div.-2)/","excerpt":"","text":"A. Two Rabbits题意：两只$rabbit$，分别在$x,y$，相向而跳，一只跳$x$，一只跳$y$，问能能否整数秒相遇 思路：判断$y-x$能否整除$a+b$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/* * * Author: Hsueh- * Date: 2020-02-21 10:07:03 * * */#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template &lt;class T, class... Ts&gt;void err(const T&amp; arg, const Ts&amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;ll x, y, a, b;void RUN() &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b; if ((y - x) % (a + b)) &#123; cout &lt;&lt; -1 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; (y - x) / (a + b) &lt;&lt; endl; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); int T; cin &gt;&gt; T; while (T--) &#123; RUN(); &#125; return 0;&#125; B. Longest Palindrome题意：给出$n$个长度为$m$的不同的字符串，你可以选任意个并随意拼接，问最长的回文串长度 思路：每次都把$t$和$rev(t)$选入即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* * * Author: Hsueh- * Date: 2020-02-21 10:09:38 * * */#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template &lt;class T, class... Ts&gt;void err(const T&amp; arg, const Ts&amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;int n, m, tot;string s[N];map&lt;string, int&gt; mp;int res[N], mark[N];void RUN() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; s[i]; mp[s[i]] = i; &#125; int mid = -1; for (int i = 1; i &lt;= n; ++i) &#123; if (mark[i]) continue; string t = s[i]; reverse(all(t)); if (t == s[i]) &#123; if (mid == -1) &#123; mid = i; mark[i] = 1; &#125; &#125; else if (mp.count(t) &amp;&amp; !mark[mp[t]]) &#123; res[++tot] = i; mark[i] = mark[mp[t]] = 1; &#125; &#125; int tmp = tot * 2 * m; if (mid != -1) tmp += m; cout &lt;&lt; tmp &lt;&lt; endl; if (!tmp) return; string ans = \"\"; for (int i = 1; i &lt;= tot; ++i) &#123; ans += s[res[i]]; &#125; cout &lt;&lt; ans; if (mid != -1) cout &lt;&lt; s[mid]; reverse(all(ans)); cout &lt;&lt; ans &lt;&lt; endl;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); RUN(); return 0;&#125; C. Air Conditioner题意：一个餐馆中有个空调，每分钟可以选择上调 $1$个单位的温度或下调 $1$ 个单位的温度，当然你也可以选择不变，初始的温度为 $m$，有 $n$个食客，每个食客会在 $t_i$ 时间点到达，他所能适应的最低温度是 $l_i$ ，最高温度是 $h_i$ ，他只会在 $t_i$ 时刻逗留。问能否让所有人舒服 思路：按照$t$排序，每次空调的温度会从$ [ l,r ] $变成$ [l - (t_i - t_{i-1}) , r + (t_{i} - t_{i - 1}) ] $然后和顾客的$ [ l_i,r_i ] $去$min$看能否满足即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* * * Author: Hsueh- * Date: 2020-02-21 10:20:04 * * */#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template &lt;class T, class... Ts&gt;void err(const T&amp; arg, const Ts&amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;struct node &#123; int l, r, t; void input() &#123; cin &gt;&gt; t &gt;&gt; l &gt;&gt; r; &#125; bool operator&lt;(const node&amp; other) const &#123; return t &lt; other.t; &#125;&#125; a[N];int n, m;void RUN() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) &#123; a[i].input(); &#125; sort(a + 1, a + 1 + n); int l = m, r = m; for (int i = 1; i &lt;= n; ++i) &#123; int diff = a[i].t - a[i - 1].t; l -= diff; r += diff; l = max(l, a[i].l); r = min(r, a[i].r); if (l &gt; r) &#123; cout &lt;&lt; \"NO\" &lt;&lt; endl; return; &#125; &#125; cout &lt;&lt; \"YES\" &lt;&lt; endl;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); int T; cin &gt;&gt; T; while (T--) &#123; RUN(); &#125; return 0;&#125; D. Shortest and Longest LIS题意：给出一个长度为$n-1$的字符串，字符串内为大于号和小于号，显然让你随意排列$1-n$个数，使得满足字符串的大小顺序，然后$LIS$长度分别最大和最小 思路：刚开始构造一个$n-1$顺序排列，然后遇到小于号，将连续的小于号部分翻转即可，然后得到长度最小的，同理可以得到长度最大的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/* * * Author: Hsueh- * Date: 2020-02-21 10:24:19 * * */#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template &lt;class T, class... Ts&gt;void err(const T&amp; arg, const Ts&amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;int n, a[N];char s[N];void RUN() &#123; cin &gt;&gt; n &gt;&gt; (s + 1); for (int i = 1, j = n; i &lt;= n; ++i, --j) &#123; a[i] = j; &#125; for (int i = 1; i &lt; n; ++i) &#123; int j = i; while (j &lt; n &amp;&amp; s[j] == '&lt;') ++j; reverse(a + i, a + j + 1); i = j; &#125; for (int i = 1; i &lt;= n; ++i) &#123; cout &lt;&lt; a[i] &lt;&lt; \" \\n\"[i == n]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; a[i] = i; &#125; for (int i = 1; i &lt; n; ++i) &#123; int j = i; while (j &lt; n &amp;&amp; s[j] == '&gt;') ++j; reverse(a + i, a + j + 1); i = j; &#125; for (int i = 1; i &lt;= n; ++i) &#123; cout &lt;&lt; a[i] &lt;&lt; \" \\n\"[i == n]; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); int T; cin &gt;&gt; T; while (T--) &#123; RUN(); &#125; return 0;&#125; E. 1-Trees and Queries题意：给定一棵树，以及$q$次查询，每次查询给出$x,y,a,b,k$表示增加一条$x\\rightarrow y$的边，问是否存在$a\\rightarrow b$的路径，长度为$k$, 每条边可走多次 思路：很显然直接判断$a \\rightarrow b,a \\rightarrow x \\rightarrow y \\rightarrow b, a \\rightarrow y \\rightarrow x \\rightarrow b$三种情况即可 （见过的最水的E题了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/* * * Author: Hsueh- * Date: 2020-02-21 10:33:14 * * */#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template &lt;class T, class... Ts&gt;void err(const T&amp; arg, const Ts&amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10, DEG = 20;int n, q;vector&lt;vector&lt;int&gt;&gt; G;int fa[N][DEG], deg[N];void BFS(int root) &#123; queue&lt;int&gt; q; deg[root] = 0; fa[root][0] = root; q.push(root); while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = 1; i &lt; DEG; ++i) &#123; fa[u][i] = fa[fa[u][i - 1]][i - 1]; &#125; for (auto v : G[u]) &#123; if (v == fa[u][0]) continue; deg[v] = deg[u] + 1; fa[v][0] = u; q.push(v); &#125; &#125;&#125;int LCA(int u, int v) &#123; if (deg[u] &gt; deg[v]) swap(u, v); int hu = deg[u], hv = deg[v]; int tu = u, tv = v; for (int det = hv - hu, i = 0; det; det &gt;&gt;= 1, ++i) &#123; if (det &amp; 1) &#123; tv = fa[tv][i]; &#125; &#125; if (tu == tv) return tu; for (int i = DEG - 1; i &gt;= 0; --i) &#123; if (fa[tu][i] == fa[tv][i]) &#123; continue; &#125; tu = fa[tu][i]; tv = fa[tv][i]; &#125; return fa[tu][0];&#125;int dis(int u, int v) &#123; int root = LCA(u, v); return deg[u] + deg[v] - 2 * deg[root];&#125;bool ok(int u, int v, int k) &#123; if (dis(u, v) &gt;= k &amp;&amp; (dis(u, v) - k) % 2 == 0) return true; else return false;&#125;void RUN() &#123; cin &gt;&gt; n; G.resize(n + 1); for (int i = 1, u, v; i &lt; n; ++i) &#123; cin &gt;&gt; u &gt;&gt; v; G[u].push_back(v); G[v].push_back(u); &#125; BFS(1); cin &gt;&gt; q; for (int _q = 1, x, y, a, b, k; _q &lt;= q; ++_q) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; a &gt;&gt; b &gt;&gt; k; // a-&gt;b int tmp = dis(a, b); if (tmp &lt;= k &amp;&amp; (tmp - k) % 2 == 0) &#123; cout &lt;&lt; \"YES\" &lt;&lt; endl; continue; &#125; // a-&gt;x-&gt;y-&gt;b tmp = dis(a, x) + dis(y, b) + 1; if (tmp &lt;= k &amp;&amp; (tmp - k) % 2 == 0) &#123; cout &lt;&lt; \"YES\" &lt;&lt; endl; continue; &#125; // a-&gt;y-&gt;x-&gt;b tmp = dis(a, y) + dis(x, b) + 1; if (tmp &lt;= k &amp;&amp; (tmp - k) % 2 == 0) &#123; cout &lt;&lt; \"YES\" &lt;&lt; endl; continue; &#125; cout &lt;&lt; \"NO\" &lt;&lt; endl; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); RUN(); return 0;&#125; F1. Animal Observation (easy version)题意：Gildong 计划拍摄森林中的野生动物们。森林被划分为 $m$ 个地区，依次编号为 $1$ 到 $m$，他的拍摄计划持续 $n$ 天。 每一天，他会选择森林中连续的 $k$ 个地区，并且录一段长为 $2$ 天的录像。（如果是最后一天，那就录一段长度为$1$ 天的录像）这样所有在这两天之内在这 $k$ 个地区中出现过的动物都会被拍摄到。 他知道未来 $n$ 天内每一天每一个地区会出现多少野生动物。他想拍摄下尽可能多的野生动物。注意如果一个动物被拍摄了两次，那么只会被计算一次。 你的任务是求出拍摄到的动物数量的最大值。 思路：见F2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/* * * Author: Hsueh- * Date: 2020-02-21 11:57:51 * * */#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template &lt;class T, class... Ts&gt;void err(const T&amp; arg, const Ts&amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e4 + 10, M = 100;int n, m, k;ll a[M][N], s[M][N];ll f[N];struct SEG &#123; ll t[N &lt;&lt; 2]; void build(int id, int l, int r) &#123; t[id] = -INFLL; if (l == r) &#123; return; &#125; int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); &#125; void modify(int id, int l, int r, int pos, ll v) &#123; if (l == r) &#123; t[id] = v; return; &#125; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) modify(id &lt;&lt; 1, l, mid, pos, v); else modify(id &lt;&lt; 1 | 1, mid + 1, r, pos, v); t[id] = max(t[id &lt;&lt; 1], t[id &lt;&lt; 1 | 1]); &#125; ll query(int id, int l, int r, int ql, int qr) &#123; if (ql &gt; qr) return 0; if (l &gt;= ql &amp;&amp; r &lt;= qr) &#123; return t[id]; &#125; int mid = (l + r) &gt;&gt; 1; ll res = -INFLL; if (ql &lt;= mid) res = max(res, query(id &lt;&lt; 1, l, mid, ql, qr)); if (qr &gt; mid) res = max(res, query(id &lt;&lt; 1 | 1, mid + 1, r, ql, qr)); return res; &#125;&#125; seg[3]; // f, x, yvoid RUN() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; cin &gt;&gt; a[i][j]; s[i][j] = s[i][j - 1] + a[i][j]; &#125; &#125; seg[0].build(1, 1, m); seg[1].build(1, 1, m); seg[2].build(1, 1, m); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j + k - 1 &lt;= m; ++j) &#123; f[j] = max(seg[0].query(1, 1, m, 1, j - k), seg[0].query(1, 1, m, j + k, m)); f[j] = max(f[j], seg[1].query(1, 1, m, j - k + 1, j) + s[i][j - 1]); f[j] = max(f[j], seg[2].query(1, 1, m, j + 1, j + k) - s[i][j + k - 1]); f[j] = max(f[j], 0ll); &#125; for (int j = 1; j + k - 1 &lt;= m; ++j) &#123; f[j] += s[i][j + k - 1] - s[i][j - 1] + s[i + 1][j + k - 1] - s[i + 1][j - 1]; seg[0].modify(1, 1, m, j, f[j]); seg[1].modify(1, 1, m, j, f[j] - s[i + 1][j + k - 1]); seg[2].modify(1, 1, m, j, f[j] + s[i + 1][j - 1]); &#125; &#125; cout &lt;&lt; seg[0].t[1] &lt;&lt; endl;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); RUN(); return 0;&#125; F2. Animal Observation (hard version)题意：Gildong 计划拍摄森林中的野生动物们。森林被划分为 $m$ 个地区，依次编号为 $1$ 到 $m$，他的拍摄计划持续 $n$ 天。 每一天，他会选择森林中连续的 $k$ 个地区，并且录一段长为 $2$ 天的录像。（如果是最后一天，那就录一段长度为$1$ 天的录像）这样所有在这两天之内在这 $k$ 个地区中出现过的动物都会被拍摄到。 他知道未来 $n$ 天内每一天每一个地区会出现多少野生动物。他想拍摄下尽可能多的野生动物。注意如果一个动物被拍摄了两次，那么只会被计算一次。 你的任务是求出拍摄到的动物数量的最大值。 思路：$f[i][j]$表示第$i$天拍$[j,j+k-1]$的区间的前$i$天的最大值，那么 \\begin{equation*} \\begin{aligned} &g[i][j] = \\left\\{ \\begin{aligned} & f[i-1][l]-(S[i][l+k-1]-S[i][j-1]) \\quad &if \\ l \\in [j-k, j]\\\\ & f[i-1][l]-(S[i][j+k-1]-S[i][l-1]) \\quad &if \\ l \\in [j, j+k]\\\\ & f[i-1][l] &otherwise \\end{aligned} \\right.\\\\ &f[i][j] = g[i][j] + S[i][j+k-1] - S[i][j-1] + S[i + 1][j+k-1] - S[i + 1][j-1] \\end{aligned} \\end{equation*}所以可以用$segment \\ tree$维护三种情况 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/* * * Author: Hsueh- * Date: 2020-02-21 11:41:34 * * */#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template &lt;class T, class... Ts&gt;void err(const T&amp; arg, const Ts&amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using ll = long long;using db = double;using pII = pair&lt;int, int&gt;;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e4 + 10, M = 100;int n, m, k;ll a[M][N], s[M][N];ll f[N];struct SEG &#123; ll t[N &lt;&lt; 2]; void build(int id, int l, int r) &#123; t[id] = -INFLL; if (l == r) &#123; return; &#125; int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); &#125; void modify(int id, int l, int r, int pos, ll v) &#123; if (l == r) &#123; t[id] = v; return; &#125; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) modify(id &lt;&lt; 1, l, mid, pos, v); else modify(id &lt;&lt; 1 | 1, mid + 1, r, pos, v); t[id] = max(t[id &lt;&lt; 1], t[id &lt;&lt; 1 | 1]); &#125; ll query(int id, int l, int r, int ql, int qr) &#123; if (ql &gt; qr) return 0; if (l &gt;= ql &amp;&amp; r &lt;= qr) &#123; return t[id]; &#125; int mid = (l + r) &gt;&gt; 1; ll res = -INFLL; if (ql &lt;= mid) res = max(res, query(id &lt;&lt; 1, l, mid, ql, qr)); if (qr &gt; mid) res = max(res, query(id &lt;&lt; 1 | 1, mid + 1, r, ql, qr)); return res; &#125;&#125; seg[3]; // f, x, yvoid RUN() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; cin &gt;&gt; a[i][j]; s[i][j] = s[i][j - 1] + a[i][j]; &#125; &#125; seg[0].build(1, 1, m); seg[1].build(1, 1, m); seg[2].build(1, 1, m); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j + k - 1 &lt;= m; ++j) &#123; f[j] = max(seg[0].query(1, 1, m, 1, j - k), seg[0].query(1, 1, m, j + k, m)); f[j] = max(f[j], seg[1].query(1, 1, m, j - k + 1, j) + s[i][j - 1]); f[j] = max(f[j], seg[2].query(1, 1, m, j + 1, j + k) - s[i][j + k - 1]); f[j] = max(f[j], 0ll); &#125; for (int j = 1; j + k - 1 &lt;= m; ++j) &#123; f[j] += s[i][j + k - 1] - s[i][j - 1] + s[i + 1][j + k - 1] - s[i + 1][j - 1]; seg[0].modify(1, 1, m, j, f[j]); seg[1].modify(1, 1, m, j, f[j] - s[i + 1][j + k - 1]); seg[2].modify(1, 1, m, j, f[j] + s[i + 1][j - 1]); &#125; &#125; cout &lt;&lt; seg[0].t[1] &lt;&lt; endl;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); RUN(); return 0;&#125;","categories":[],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://hsueh37.gitee.io/blog/tags/Codeforces/"}]},{"title":"Codeforces Round 608 (Div. 2)","slug":"Codeforces_Round_608_(Div.-2)","date":"2020-02-11T03:10:00.000Z","updated":"2020-04-28T09:02:42.265Z","comments":true,"path":"2020/02/11/Codeforces_Round_608_(Div.-2)/","link":"","permalink":"https://hsueh37.gitee.io/blog/2020/02/11/Codeforces_Round_608_(Div.-2)/","excerpt":"","text":"A. Suits水 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* * * Author: Hsueh- * Date: 2020-02-11 10:15:51 * * */#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template &lt;class T, class... Ts&gt;void err(const T&amp; arg, const Ts&amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using pII = pair&lt;int, int&gt;;using ll = long long;using db = double;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;int gao1(int a, int b, int c, int d, int e, int f) &#123; int res = 0; res += min(a, d) * e; d -= min(a, d); res += min(b, min(c, d)) * f; return res;&#125;int gao2(int a, int b, int c, int d, int e, int f) &#123; int res = 0; res += min(b, min(c, d)) * f; d -= min(b, min(c, d)); res += min(a, d) * e; return res;&#125;int a, b, c, d, e, f;void RUN() &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f; cout &lt;&lt; max(gao1(a, b, c, d, e, f), gao2(a, b, c, d, e, f)) &lt;&lt; endl;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); RUN(); return 0;&#125; B. Blocks题意： 给一个01串，每次可以将$i, i+1$翻转，问能否将其翻转成为全黑全白，输出方案（方案次数$\\leq 3\\cdot n$） 思路： 尝试全黑和全白，暴力翻转 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* * * Author: Hsueh- * Date: 2020-02-11 10:21:13 * * */#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template &lt;class T, class... Ts&gt;void err(const T&amp; arg, const Ts&amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using pII = pair&lt;int, int&gt;;using ll = long long;using db = double;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;int n, a[N];char s[N];vector&lt;int&gt; res;void RUN() &#123; cin &gt;&gt; n; cin &gt;&gt; (s + 1); for (int i = 1; i &lt;= n; ++i) &#123; if (s[i] == 'W') a[i] = 0; else a[i] = 1; &#125; for (int i = 1; i &lt; n; ++i) &#123; if (!a[i]) &#123; a[i] ^= 1, a[i + 1] ^= 1; res.push_back(i); &#125; &#125; if (a[n]) &#123; cout &lt;&lt; res.size() &lt;&lt; endl; for (int i = 0, len = res.size(); i &lt; len; ++i) &#123; cout &lt;&lt; res[i] &lt;&lt; \" \\n\"[i==len - 1]; &#125; return; &#125; for (int i = 1; i &lt; n; ++i) &#123; if (a[i]) &#123; a[i] ^= 1, a[i + 1] ^= 1; res.push_back(i); &#125; &#125; if (!a[n]) &#123; cout &lt;&lt; res.size() &lt;&lt; endl; for (int i = 0, len = res.size(); i &lt; len; ++i) &#123; cout &lt;&lt; res[i] &lt;&lt; \" \\n\"[i == len - 1]; &#125; return; &#125; cout &lt;&lt; -1 &lt;&lt; endl;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); RUN(); return 0;&#125; C. Shawarma Tent题意： 有一个学校在$(sx,sy)$位置，有$n$个学生，每个人家的坐标在$(x_i,y_i)$ 现在想要开一个$shawarma $，如果这个学生可以经过$shawarma $后到达学校依旧是最短距离，那么认定这个学生给$shawarma $带来贡献 求最大的贡献值和坐标 思路： 很显然把$shawarma $开在学校的上下左右是最优的，暴力算一遍取$max$即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* * * Author: Hsueh- * Date: 2020-02-11 10:29:54 * * */#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template &lt;class T, class... Ts&gt;void err(const T&amp; arg, const Ts&amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using pII = pair&lt;int, int&gt;;using ll = long long;using db = double;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;int n, sx, sy;int x[N], y[N];int dir[4][2] = &#123;1, 0, 0, 1, -1, 0, 0, -1&#125;;void RUN() &#123; cin &gt;&gt; n &gt;&gt; sx &gt;&gt; sy; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; x[i] &gt;&gt; y[i]; &#125; int Max = -1, _x = 0, _y = 0; for (int i = 0; i &lt; 4; ++i) &#123; int ex = sx + dir[i][0], ey = sy + dir[i][1]; int cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (abs(x[i] - sx) + abs(y[i] - sy) == abs(x[i] - ex) + abs(y[i] - ey) + 1) &#123; ++cnt; &#125; &#125; if (cnt &gt; Max) &#123; Max = cnt, _x = ex, _y = ey; &#125; &#125; cout &lt;&lt; Max &lt;&lt; endl; cout &lt;&lt; _x &lt;&lt; \" \" &lt;&lt; _y &lt;&lt; endl;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); RUN(); return 0;&#125; D. Portals题意： 有$n$个城堡，刚开始你有$k$个军队，有$m$条路径 你现在按照$1 - n$的顺序攻打城堡 每个城堡你需要至少$a_i$个军队，但是攻打城堡不耗费军队，攻打后你可以招$b_i$个军队，同时每个城堡有$c_i$的重要性 当你派至少一个军队留在城堡的时候算占领 占领只有当你刚攻打城堡的时候可以占领或者通过$m$条路径占领 $m$条有向路径，$u&gt;v$ 问最后占领的城堡的最大重要性 如果不能攻打所有城堡输出$-1$ 思路： 首先判断$-1$ 其次对每个城堡维护一个$Max_i$，表示最远的可以通过路径可以占领的城堡下标 对每个城堡按照$(c_i,i)$排序，一个城堡的重要性有价值只有$Max_i+1-n$的城堡在少一个士兵的情况下依旧可以攻打，然后贪心即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/* * * Author: Hsueh- * Date: 2020-02-11 10:35:29 * * */#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template &lt;class T, class... Ts&gt;void err(const T&amp; arg, const Ts&amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using pII = pair&lt;int, int&gt;;using ll = long long;using db = double;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;struct node &#123; int a, b, c; void input() &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; &#125;&#125; a[N];int n, m, k;int Max[N], remind[N];void RUN() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) &#123; a[i].input(); Max[i] = i; &#125; for (int i = 1, u, v; i &lt;= m; ++i) &#123; cin &gt;&gt; u &gt;&gt; v; Max[v] = max(Max[v], u); &#125; remind[1] = k; for (int i = 1; i &lt;= n; ++i) &#123; if (remind[i] &lt; a[i].a) &#123; cout &lt;&lt; \"-1\" &lt;&lt; endl; return; &#125; remind[i + 1] = remind[i] + a[i].b; &#125; priority_queue&lt;pII&gt; pq; for (int i = 1; i &lt;= n; ++i) &#123; pq.push(pII(a[i].c, i)); &#125; int res = 0; while (!pq.empty()) &#123; pII t = pq.top(); pq.pop(); bool F = true; for (int i = Max[t.second] + 1; i &lt;= n + 1; ++i) &#123; if (remind[i] - 1 &lt; a[i].a) &#123; F = false; break; &#125; &#125; if (F) &#123; res += t.first; for (int i = Max[t.second] + 1; i &lt;= n + 1; ++i) &#123; remind[i]--; &#125; &#125; &#125; cout &lt;&lt; res &lt;&lt; endl;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); RUN(); return 0;&#125; E. Common Number题意： 定义 f(x)= \\begin{equation} \\left\\{ \\begin{array}{**lr**} \\frac{x}{2} \\quad & if \\; x \\; is \\; even \\\\ x-1 \\quad & otherwise \\end{array} \\right. \\end{equation}定义$path\\{x\\}$为通过一系列计算得到的结果 求最大的$y$满足$|\\{x|1\\leq x \\leq n, y \\in path\\{x\\}|\\geq k$ 思路： 很显然这是一棵树 其中$2x$的父亲是$x$，$2x+1$的父亲是$2x$ 所以就变成了最大的数，它的子树大小$\\geq k$ 那么很显然可以二分 我们分奇偶进行计算 偶数的时候要算上偶数加一的子树大小 对于一个数计算他的子树大小可以让他不断乘2计算 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* * * Author: Hsueh- * Date: 2020-02-11 11:13:58 * * */#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) \\ do &#123; \\ cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; \\ err(x); \\ &#125; while (0)void err() &#123; cout &lt;&lt; endl;&#125;template &lt;class T, class... Ts&gt;void err(const T&amp; arg, const Ts&amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"#define all(A) A.begin(), A.end()using pII = pair&lt;int, int&gt;;using ll = long long;using db = double;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const int N = 2e5 + 10;ll n, k;ll f(ll x) &#123; ll res = 0, t = 1; while (x &lt;= n) &#123; res += min(t, n - x + 1); x &lt;&lt;= 1, t &lt;&lt;= 1; &#125; return res;&#125;void RUN() &#123; cin &gt;&gt; n &gt;&gt; k; ll res = -1; ll l = 1, r = n / 2, x = -1; while (r - l &gt;= 0) &#123; ll mid = (l + r) &gt;&gt; 1; if (f(mid &lt;&lt; 1) + f(mid &lt;&lt; 1 | 1) &gt;= k) &#123; l = mid + 1; x = mid &lt;&lt; 1; &#125; else &#123; r = mid - 1; &#125; &#125; res = max(res, x); l = 1, r = (n + 1) / 2, x = -1; while (r - l &gt;= 0) &#123; ll mid = (l + r) &gt;&gt; 1; if (f(2 * mid - 1) &gt;= k) &#123; l = mid + 1; x = 2 * mid - 1; &#125; else &#123; r = mid - 1; &#125; &#125; cout &lt;&lt; max(res, x) &lt;&lt; endl;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); cout &lt;&lt; fixed &lt;&lt; setprecision(20); RUN(); return 0;&#125;","categories":[],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://hsueh37.gitee.io/blog/tags/Codeforces/"}]},{"title":"最大团 Bron-Kerbosch","slug":"最大团_Bron-Kerbosch","date":"2020-02-03T08:10:00.000Z","updated":"2020-04-28T09:02:42.276Z","comments":true,"path":"2020/02/03/最大团_Bron-Kerbosch/","link":"","permalink":"https://hsueh37.gitee.io/blog/2020/02/03/%E6%9C%80%E5%A4%A7%E5%9B%A2_Bron-Kerbosch/","excerpt":"","text":"Bron-Kerbosch1. 作用Bron-Kerbosch 算法用于计算图中的最大的全连通分量，即计算图的最大团。 2. 原理Bron-Kerbosch 算法的基础形式是一个递归回溯的搜索算法，其通过给定三个集合: $R,P,X$ 来递归的进行搜索 初始化集合 $R,X$ 分别为空，集合 $P$ 为所有顶点的集合 每次从集合 $P$ 中取顶点 ${v_i}$，当集合中没有顶点时，有两种情况： 集合 $R$ 是最大团，此时集合 $X$ 为空 无最大团，此时回溯 对于每一个从集合 $P$ 中取得的顶点 $v_i$，有如下处理 将顶点 ${v_i}$ 加到集合$R$ 中，集合 $P,X$ 与顶点 ${v_i}$ 的邻接顶点集合 $N{v_i}$ 相交，之后递归集合 $R,P,X$ 从集合 $P$ 中删除顶点 ${v_i}$，并将顶点 ${v_i}$ 添加到集合$X$ 中 若集合 $P,X$ 都为空，则集合$R$ 即为最大团 总的来看，就是每次从集合 $P$ 中取 $v_i$ 后，再从 $P \\cap N{v_i}$集合中取相邻结点，保证集合 $R$ 中任意顶点间都两两相邻 1234567BronKerbosch1(R,P,X): if P and X are both empty: report R as a maximal clique for each vertex v in P: BronKerbosch1(R ⋃ &#123;v&#125;, P ⋂ N(v), X ⋂ N(v)) P := P \\ &#123;v&#125; X := X ⋃ &#123;v&#125; 3. 算法优化对于基础的算法，由于其递归搜索了所有情况，对其中有些不是最大团的也进行了搜索，效率不高，为了节省时间让算法更快的回溯，可以通过设定关键点来进行搜索。 由于对于任意的最大团，其必须包括顶点${u}$ 或 $N-N{u}$，不然其必然需要通过添加它们来进行扩充，这显然矛盾，所以仅需测试顶点 ${u}$ 以及 $N-N{u}$ 即可。 12345678BronKerbosch2(R,P,X): if P and X are both empty: report R as a maximal clique choose a pivot vertex u in P ⋃ X for each vertex v in P \\ N(u): BronKerbosch2(R ⋃ &#123;v&#125;, P ⋂ N(v), X ⋂ N(v)) P := P \\ &#123;v&#125; X := X ⋃ &#123;v&#125; 由于其是通过选择特殊点，来进行最小化递归调用，一定程度上节省了时间，但还可以与降序的方式结合使用，来保证在线性的时间内求子图的最大团 1234567BronKerbosch3(G): P = V(G) R = X = empty for each vertex v in a degeneracy ordering of G: BronKerbosch2(R ⋃ &#123;v&#125;, P ⋂ N(v), X ⋂ N(v)) P := P \\ &#123;v&#125; X := X ⋃ &#123;v&#125; 4. 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e2 + 10;int n, m;int G[N][N];int group[N], vis[N], res, cnt[N];bool gao(int u, int _cnt) &#123; for (int i = u + 1; i &lt;= n; ++i) &#123; if (cnt[i] + _cnt &lt;= res) &#123; return false; &#125; if (G[u][i]) &#123; bool F = true; for (int j = 0; j &lt; _cnt; ++j) &#123; if (!G[i][vis[j]]) &#123; F = false; break; &#125; &#125; if (!F) continue; vis[_cnt] = i; if (gao(i, _cnt + 1)) &#123; return true; &#125; &#125; &#125; if (_cnt &gt; res) &#123; for (int i = 0; i &lt; _cnt; ++i) &#123; group[i] = vis[i]; &#125; res = _cnt; return true; &#125; return false;&#125;void maxclique() &#123; res = -1; for (int i = n; i &gt;= 1; --i) &#123; vis[0] = i; gao(i, 1); cnt[i] = res; &#125;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d %d\", &amp;n, &amp;m); memset(G, 0, sizeof G); for (int i = 1, u, v; i &lt;= m; ++i) &#123; scanf(\"%d %d\", &amp;u, &amp;v); G[u][v] = G[v][u] = 1; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (i == j) &#123; G[i][j] = 0; &#125; else &#123; G[i][j] ^= 1; &#125; &#125; &#125; maxclique(); if (res &lt; 0) res = 0; printf(\"%d\\n\", res); for (int i = 0; i &lt; res; ++i) &#123; printf(\"%d \", group[i]); &#125; putchar(10); &#125; return 0;&#125;","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"https://hsueh37.gitee.io/blog/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"HDU 4578","slug":"HDU-4578","date":"2019-11-05T14:10:00.000Z","updated":"2020-04-28T09:02:42.267Z","comments":true,"path":"2019/11/05/HDU-4578/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/11/05/HDU-4578/","excerpt":"","text":"Transformation区间维护加法，乘法，赋值，求三次方的和 思路an very old problem 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) do &#123; cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; err(x); &#125; while (0)void err() &#123; cout &lt;&lt; endl; &#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"using pii = pair&lt;int, int&gt;;using ll = long long;using db = double;const int N = 1e5 + 10;const int p = 10007;int n, q;struct SEG &#123; struct node &#123; int l, r; int sum[3], lazy[3];//+ * = node() &#123; sum[0] = sum[1] = sum[2] = 0; lazy[0] = lazy[2] = 0; lazy[1] = 1; &#125; node(int _l, int _r) &#123; l = _l; r = _r; sum[0] = sum[1] = sum[2] = 0; lazy[0] = lazy[2] = 0; lazy[1] = 1; &#125; &#125; t[N &lt;&lt; 2]; void add(int id, int v) &#123; int len = t[id].r - t[id].l + 1; t[id].sum[2] = (t[id].sum[2] + (len * v % p * v % p * v % p) + (3 * v % p * v % p * t[id].sum[0] % p) + (3 * v % p * t[id].sum[1] % p)) % p; t[id].sum[1] = (t[id].sum[1] + (2 * v % p * t[id].sum[0] % p) + (len * v % p * v % p)) % p; t[id].sum[0] = (t[id].sum[0] + len * v % p) % p; t[id].lazy[0] = (t[id].lazy[0] + v) % p; &#125; void mul(int id, int v) &#123; t[id].sum[0] = (t[id].sum[0] * v) % p; t[id].sum[1] = (t[id].sum[1] * v % p * v) % p; t[id].sum[2] = (t[id].sum[2] * v % p * v % p * v) % p; t[id].lazy[0] = t[id].lazy[0] * v % p; t[id].lazy[1] = t[id].lazy[1] * v % p; &#125; void equ(int id, int v) &#123; int len = t[id].r - t[id].l + 1; t[id].sum[0] = len * v % p; t[id].sum[1] = t[id].sum[0] * v % p; t[id].sum[2] = t[id].sum[1] * v % p; t[id].lazy[0] = 0; t[id].lazy[1] = 1; t[id].lazy[2] = v; &#125; void build(int id, int l, int r) &#123; t[id] = node(l, r); if (l == r) &#123; return; &#125; int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); &#125; void down(int id) &#123; if (t[id].l &gt;= t[id].r) return; if (t[id].lazy[2]) &#123; equ(id &lt;&lt; 1, t[id].lazy[2]); equ(id &lt;&lt; 1 | 1, t[id].lazy[2]); t[id].lazy[2] = 0; &#125; if (t[id].lazy[1] != 1) &#123; mul(id &lt;&lt; 1, t[id].lazy[1]); mul(id &lt;&lt; 1 | 1, t[id].lazy[1]); t[id].lazy[1] = 1; &#125; if (t[id].lazy[0]) &#123; add(id &lt;&lt; 1, t[id].lazy[0]); add(id &lt;&lt; 1 | 1, t[id].lazy[0]); t[id].lazy[0] = 0; &#125; &#125; void up(int id) &#123; int lson = id &lt;&lt; 1; int rson = id &lt;&lt; 1 | 1; t[id].sum[0] = (t[lson].sum[0] + t[rson].sum[0]) % p; t[id].sum[1] = (t[lson].sum[1] + t[rson].sum[1]) % p; t[id].sum[2] = (t[lson].sum[2] + t[rson].sum[2]) % p; &#125; void update(int id, int ql, int qr, int op, int v) &#123; if (t[id].l &gt;= ql &amp;&amp; t[id].r &lt;= qr) &#123; if (op == 0) &#123; add(id, v); &#125; else if (op == 1) &#123; mul(id, v); &#125; else if (op == 2) &#123; equ(id, v); &#125; return; &#125; down(id); int mid = (t[id].l + t[id].r) &gt;&gt; 1; if (ql &lt;= mid) update(id &lt;&lt; 1, ql, qr, op, v); if (qr &gt; mid) update(id &lt;&lt; 1 | 1, ql, qr, op, v); up(id); &#125; int query(int id, int ql, int qr, int idx) &#123; if (t[id].l &gt;= ql &amp;&amp; t[id].r &lt;= qr) &#123; return t[id].sum[idx]; &#125; down(id); int mid = (t[id].l + t[id].r) &gt;&gt; 1; int res = 0; if (ql &lt;= mid) res = (res + query(id &lt;&lt; 1, ql, qr, idx)) % p; if (qr &gt; mid) res = (res + query(id &lt;&lt; 1 | 1, ql, qr, idx)) % p; return res; &#125;&#125; seg;void RUN() &#123; while (scanf(\"%d %d\", &amp;n, &amp;q) != EOF) &#123; if (n == 0 &amp;&amp; q == 0) break; seg.build(1, 1, n); while (q--) &#123; int op, a, b, c; scanf(\"%d %d %d %d\", &amp;op, &amp;a, &amp;b, &amp;c); if (op &lt;= 3) &#123; seg.update(1, a, b, op - 1, c); &#125; else &#123; printf(\"%d\\n\", seg.query(1, a, b, c - 1)); &#125; &#125; &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif// ios::sync_with_stdio(false);// cin.tie(nullptr), cout.tie(nullptr); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125;","categories":[],"tags":[{"name":"HDU","slug":"HDU","permalink":"https://hsueh37.gitee.io/blog/tags/HDU/"}]},{"title":"2020_HZNU_winter_camp_最短路","slug":"HZNU_winter_camp_最短路","date":"2019-11-05T14:10:00.000Z","updated":"2020-04-28T09:02:42.268Z","comments":true,"path":"2019/11/05/HZNU_winter_camp_最短路/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/11/05/HZNU_winter_camp_%E6%9C%80%E7%9F%AD%E8%B7%AF/","excerpt":"","text":"HDU 18741234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 210;const int INF = 0x3f3f3f3f;int n, m;int dis[N][N];void Floyd() &#123; for (int k = 0; k &lt; n; ++k) &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); &#125; &#125; &#125;&#125;int main() &#123; while (scanf(\"%d %d\", &amp;n, &amp;m) != EOF) &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; dis[i][j] = INF; if (i == j) dis[i][j] = 0; &#125; &#125; for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); w = min(w, dis[u][v]); dis[u][v] = dis[v][u] = w; &#125; Floyd(); int S, T; scanf(\"%d %d\", &amp;S, &amp;T); if (dis[S][T] == INF) printf(\"%d\\n\", -1); else printf(\"%d\\n\", dis[S][T]); &#125; return 0;&#125; HDU 186912345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 210;const int INF = 0x3f3f3f3f;int n, m;int dis[N][N];void Floyd() &#123; for (int k = 0; k &lt; n; ++k) &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); &#125; &#125; &#125;&#125;bool ok() &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; if (dis[i][j] &gt; 7) &#123; return false; &#125; &#125; &#125; return true;&#125;int main() &#123; while (scanf(\"%d %d\", &amp;n, &amp;m) != EOF) &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; dis[i][j] = INF; if (i == j) dis[i][j] = 0; &#125; &#125; for (int i = 1, u, v; i &lt;= m; ++i) &#123; scanf(\"%d %d\", &amp;u, &amp;v); dis[u][v] = dis[v][u] = 1; &#125; Floyd(); puts(ok() ? \"Yes\" : \"No\"); &#125; return 0;&#125; HDU 206612345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3 + 10, INF = 0x3f3f3f3f;struct Edge &#123; int to, w; Edge() &#123;&#125; Edge(int to, int w) : to(to), w(w) &#123;&#125;&#125; edge[N &lt;&lt; 1];int n, m;int S, D, s[N], d[N];int dis[N];vector&lt;Edge&gt; G[N];struct qnode &#123; int u, w; qnode() &#123;&#125; qnode(int u, int w) : u(u), w(w) &#123;&#125; bool operator&lt;(const qnode &amp;other) const &#123; return w &gt; other.w; &#125;&#125;;void Dijkstra(int s) &#123; priority_queue&lt;qnode&gt; q; memset(dis, INF, sizeof dis); dis[s] = 0; q.push(qnode(s, 0)); while (!q.empty()) &#123; int u = q.top().u; q.pop(); for (int i = 0, len = G[u].size(); i &lt; len; ++i) &#123; int v = G[u][i].to, w = G[u][i].w; if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; q.push(qnode(v, dis[v])); &#125; &#125; &#125;&#125;int main() &#123; while (scanf(\"%d %d %d\", &amp;n, &amp;S, &amp;D) != EOF) &#123; for (int i = 0; i &lt; N; ++i) G[i].clear(); for (int i = 1, u, v, w; i &lt;= n; ++i) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); G[u].push_back(Edge(v, w)); G[v].push_back(Edge(u, w)); &#125; for (int i = 1; i &lt;= S; ++i) &#123; scanf(\"%d\", s + i);// 0-&gt;s[i] s[i]-&gt;0 G[0].push_back(Edge(s[i], 0)); G[s[i]].push_back(Edge(0, 0)); &#125; Dijkstra(0); int res = INF; for (int i = 1; i &lt;= D; ++i) &#123; scanf(\"%d\", d + i); res = min(res, dis[d[i]]); &#125; printf(\"%d\\n\", res); &#125; return 0;&#125; HDU 121712345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 50;int n, m, tot;map&lt;string, int&gt; mp;double dis[N][N];void Floyd() &#123; for (int k = 1; k &lt;= n; ++k) &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; dis[i][j] = max(dis[i][j], dis[i][k] * dis[k][j]); &#125; &#125; &#125;&#125;bool ok() &#123; for (int i = 1; i &lt;= n; ++i) &#123; if (dis[i][i] &gt; 1.0) &#123; return true; &#125; &#125; return false;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0), cout.tie(0); int cas = 1; while (cin &gt;&gt; n, n) &#123; cout &lt;&lt; \"Case \" &lt;&lt; cas++ &lt;&lt; \": \"; mp.clear(); tot = 0; memset(dis, 0, sizeof dis); for (int i = 1; i &lt;= n; ++i) dis[i][i] = 1.0; for (int i = 1; i &lt;= n; ++i) &#123; string s; cin &gt;&gt; s; mp[s] = i; &#125; cin &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) &#123; string a, b; double c; cin &gt;&gt; a &gt;&gt; c &gt;&gt; b; dis[mp[a]][mp[b]] = c; &#125; Floyd(); cout &lt;&lt; (ok() ? \"Yes\" : \"No\") &lt;&lt; endl; &#125; return 0;&#125; HDU 47251234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 0x3f3f3f3f;const int N = 3e5 + 10;vector&lt;pair&lt;int, int&gt; &gt; E[N];int dist[N];int n, m, c;void Dijkstra() &#123; priority_queue&lt;pair&lt;int, int&gt; &gt; q; dist[1] = 0; q.push(make_pair(-dist[1], 1)); while (!q.empty()) &#123; int now = q.top().second; q.pop(); for (int i = 0; i &lt; E[now].size(); ++i) &#123; int v = E[now][i].first; if (dist[v] &gt; dist[now] + E[now][i].second) &#123; dist[v] = dist[now] + E[now][i].second; q.push(make_pair(-dist[v], v)); &#125; &#125; &#125;&#125;void init() &#123; memset(dist, INF, sizeof(dist)); for (int i = 0; i &lt; N; ++i) &#123; E[i].clear(); &#125;&#125;int main() &#123; int T, cas = 0; scanf(\"%d\", &amp;T); while (T--) &#123; init(); scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;c); for (int i = 1; i &lt;= n; i++) &#123; int temp; scanf(\"%d\", &amp;temp); E[temp * 2 - 1 + n].push_back(make_pair(i, 0)); E[i].push_back(make_pair(temp * 2 + n, 0)); &#125; for (int i = 0; i &lt; m; ++i) &#123; int x, y, z; scanf(\"%d %d %d\", &amp;x, &amp;y, &amp;z); E[x].push_back(make_pair(y, z)); E[y].push_back(make_pair(x, z)); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (i != 1) &#123; E[n + 2 * i].push_back(make_pair(n + 2 * i - 3, c)); &#125; if (i != n) &#123; E[n + 2 * i].push_back(make_pair(n + 2 * i + 1, c)); &#125; &#125; Dijkstra(); if (dist[n] == INF) dist[n] = -1; printf(\"Case #%d: %d\\n\", ++cas, dist[n]); &#125;&#125; HDU 296212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3 + 10, INF = 0x3f3f3f3f;struct Edge &#123; int to, h, w; Edge() &#123;&#125; Edge(int to, int h, int w) : to(to), h(h), w(w) &#123;&#125;&#125;;int n, m;int dis[N];vector&lt;Edge&gt; G[N];struct qnode &#123; int u, w; qnode() &#123;&#125; qnode(int u, int w) : u(u), w(w) &#123;&#125; bool operator&lt;(const qnode &amp;other) const &#123; return w &gt; other.w; &#125;&#125;;void Dijkstra(int s, int h) &#123; priority_queue&lt;qnode&gt; q; memset(dis, INF, sizeof dis); dis[s] = 0; q.push(qnode(s, 0)); while (!q.empty()) &#123; int u = q.top().u; q.pop(); for (int i = 0, len = G[u].size(); i &lt; len; ++i) &#123; if (h &gt; G[u][i].h) continue; int v = G[u][i].to, w = G[u][i].w; if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; q.push(qnode(v, dis[v])); &#125; &#125; &#125;&#125;int main() &#123; int cas = 0; while (scanf(\"%d %d\", &amp;n, &amp;m) != EOF) &#123; if (n == 0 &amp;&amp; m == 0) break; if (cas) puts(\"\"); cas++; printf(\"Case %d:\\n\", cas); for (int i = 0; i &lt; N; ++i) G[i].clear(); int Min = INF, Max = 0; for (int i = 1, u, v, h, w; i &lt;= m; ++i) &#123; scanf(\"%d %d %d %d\", &amp;u, &amp;v, &amp;h, &amp;w); if (h == -1) &#123; h = INF; &#125; Min = min(Min, h); Max = max(Max, h); G[u].push_back(Edge(v, h, w)); G[v].push_back(Edge(u, h, w)); &#125; int st, ed, limit; scanf(\"%d %d %d\", &amp;st, &amp;ed, &amp;limit); Max = min(Max, limit); Dijkstra(st, 3); int l = Min, r = Max, res = -1; while (r - l &gt;= 0) &#123; int mid = (l + r) &gt;&gt; 1; Dijkstra(st, mid); if (dis[ed] != INF) &#123; l = mid + 1; res = mid; &#125; else &#123; r = mid - 1; &#125; &#125; if (res != -1) &#123; Dijkstra(st, res); printf(\"maximum height = %d\\n\", res); printf(\"length of shortest route = %d\\n\", dis[ed]); &#125; else &#123; printf(\"cannot reach destination\\n\"); &#125; &#125; return 0;&#125; HDU 485712345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3e4 + 10;int n, m;int in[N];vector&lt;vector&lt;int&gt;&gt; G;vector&lt;int&gt; ans;void topsort() &#123; priority_queue&lt;int&gt; q; for (int i = 1; i &lt;= n; ++i) &#123; if (in[i] == 0) &#123; q.push(i); &#125; &#125; while (!q.empty()) &#123; int u = q.top(); q.pop(); ans.push_back(u); for (auto v : G[u]) &#123; --in[v]; if (in[v] == 0) &#123; q.push(v); &#125; &#125; &#125;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) in[i] = 0; ans.clear(); G.clear(); G.resize(n + 1); for (int i = 1, u, v; i &lt;= m; ++i) &#123; scanf(\"%d %d\", &amp;u, &amp;v); in[u]++; G[v].push_back(u); &#125; topsort(); for (int i = ans.size() - 1; i &gt;= 0; --i) &#123; printf(\"%d%c\", ans[i], \" \\n\"[i == 0]); &#125; &#125; return 0;&#125; HYSBZ 2456123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main() &#123; int n; while (~scanf(\"%d\", &amp;n)) &#123; int ans = 0, tot = 0; for (int i = 1, num; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;num); if (!tot) &#123; ans = num; tot++; &#125; else if (num == ans) ++tot; else --tot; &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125; HihoCoder 1081123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3e4 + 10, INF = 0x3f3f3f3f;struct Edge &#123; int to, w; Edge() &#123;&#125; Edge(int to, int w) : to(to), w(w) &#123;&#125;&#125;;int n, m, S, T;int dis[N];vector&lt;Edge&gt; G[N];struct qnode &#123; int u, w; qnode() &#123;&#125; qnode(int u, int w) : u(u), w(w) &#123;&#125; bool operator&lt;(const qnode &amp;other) const &#123; return w &gt; other.w; &#125;&#125;;void Dijkstra(int s) &#123; priority_queue&lt;qnode&gt; q; memset(dis, INF, sizeof dis); dis[s] = 0; q.push(qnode(s, 0)); while (!q.empty()) &#123; int u = q.top().u; q.pop(); for (int i = 0, len = G[u].size(); i &lt; len; ++i) &#123; int v = G[u][i].to, w = G[u][i].w; if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; q.push(qnode(v, dis[v])); &#125; &#125; &#125;&#125;int main() &#123; while (scanf(\"%d %d %d %d\", &amp;n, &amp;m, &amp;S, &amp;T) != EOF) &#123; for (int i = 0; i &lt; N; ++i) &#123; G[i].clear(); &#125; for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); G[u].push_back(Edge(v, w)); G[v].push_back(Edge(u, w)); &#125; Dijkstra(S); printf(\"%d\\n\", dis[T]); &#125; return 0;&#125; HihoCoder 10891234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e2 + 10, INF = 0x3f3f3f3f;int n, m;int dis[N][N];void Floyd() &#123; for (int k = 1; k &lt;= n; ++k) &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); &#125; &#125; &#125;&#125;int main() &#123; while (scanf(\"%d %d\", &amp;n, &amp;m) != EOF) &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (i == j) dis[i][j] = 0; else dis[i][j] = INF; &#125; &#125; for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); w = min(dis[u][v], w); dis[u][v] = dis[v][u] = w; &#125; Floyd(); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; printf(\"%d%c\", dis[i][j], \" \\n\"[j == n]); &#125; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"讲课","slug":"讲课","permalink":"https://hsueh37.gitee.io/blog/tags/%E8%AE%B2%E8%AF%BE/"}]},{"title":"网络流拓展","slug":"网络流拓展","date":"2019-11-05T14:10:00.000Z","updated":"2020-11-30T05:04:55.314Z","comments":true,"path":"2019/11/05/网络流拓展/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/11/05/%E7%BD%91%E7%BB%9C%E6%B5%81%E6%8B%93%E5%B1%95/","excerpt":"","text":"网络流定义给定一个有向图$G=(V, E)$，其中每条边$(u, v)$都有一个非负的容量值，记做$c(u, v)\\geq 0$，同时图中存在两个特殊点源点$S$, 汇点$T$。其中从源点$S$到汇点$T$的最大可行流量，这个问题也被称为最大流问题 性质 容量限制：对于任意的$ &lt; u, v > \\in V,f(u,v)\\leq c(u,v)$ 反对称性：对于任意的$ &lt; u,v > \\in V,f(u,v)=-f(v,u)$ 流量守恒：对于任意的$u$，若$u$不为$S$且不为$T$，那么$\\sum f(u,v)=0$，即$u$到相邻节点的流量和为$0$，因为流入$u$的流量和$u$流出的流量相等，节点$u$本身不会产生和消耗流量。 解决思路寻找增广路，不断更新残余网络，直到找不到任何增广路 最大流最小割定理前言对于一个网络流$G=(V,E)$，其割的定义是一种点的划分方式，将所有点划分为$S$和$T=V-S$两部分，其中源点$s\\in S$，汇点$t \\in T$。对于一个割$(S,T)$，定义净流$f(S,T)$表示穿过割$S,T$的流量和。 f(S,t)=\\sum f(u,v) | u\\in S, v \\in T其中任意一个割的净流$f(S,T)$总是和网络流的流量$f$相等 解释根据网络流的定义，只有源点$s$会产生流量，汇点$t$会接收流量。因此对于任意非$s$和$t$的点$u$，净流量一定是$0$，也就是$\\sum f(u,v)=0$。而源点$s$的流量最终都会经过割$(S,T)$的边到达汇点$t$，所以网络流的流$f$等于割的净流$f(S,T)$ 定义在所有可能的割中，存在一个容量最小的割，我们称其为最小割 对于任意网络流图而言，其最大流一定小于等于最小割 定理对于一个网络流图$G=(V,E)$，其中有源点$s$和汇点$t$，我们可以推出一个最大流最小割定理 流$f$是图$G$的最大流 残留网络$Gf$不存在增广路 对于$G$的某一个割$(S,T)$，此时$f=C(S,T)$ 证明$1 \\Rightarrow 2$ 利用反证法，假设$f$是$G$的最大流，但是残留网络中存在增广路$p$，流量为$fp$，那么我们又$f’=f+fp&gt;f$。和$1$矛盾 $2 \\Rightarrow 3$ 假设参与网络$Gf$不存在增广路，所以在参与网络$Gf$中不存在路径从$s$到达$t$。我们定义$S$集合为：当前残留网络汇中$s$能够到达的点。同时定义$T = V - S$ 此时$(S,T)$构成一个割$S,T$。且对于任意的$u \\in S, v \\in T$有$f(u,v)=c(u,v)$。若$f(u,v)0$，$s$可以到达$v$，与$v$属于$T$矛盾 $3 \\Rightarrow 1$ 由于$f$的上界是最小割，当$f$到达割的容量的时候，显然达到了最大值，因此$f$是最大流 拓展二分图多重匹配 $S$连向$A$，流量为$A$中点可以连接的数量，$A$连向$B$表示可以匹配，$B$连向$T$，流量为可以连接的数量 最小路径覆盖定义给定一个有向无环图，用最少的路径数量去保证所有点都被覆盖住 对于每条路径，起点入度都为$0$，终点的出度都为$0$，中间节点的出入读都为$0$ 每个点最多有一个前驱，同时最多有一个后继节点 做法 将每个点$u$拆成$u,u’$，其中$S$连向每个$u$，每个$u’$连向$T$，对于每条边$(u,v)$，建立边$u\\rightarrow v’$，跑网络流，最终答案为点数$-$最大流 最大权闭合子图定义给定一有向图，从中选择一些点组成点集$V$。对于每个$V$中的节点，其后续节点仍然需要在$V$中。最权值最大的子图 做法 首先建立源点$s$和汇点$t$，将源点$s$和所有权值为正的点相连，流量为权值，将所有权值为负的点和汇点$t$相连，流量为权值的绝对值，权值为$0$的点不做选择，同时将原来的边的流量设置为无穷大，答案为所有正权值和$-$最小割 引理 最小割一定是简单割 简单割指得是：割$(S,T)$中每一条割边都与$s$或者$t$关联，这样的割叫做简单割。 简单割一定和一个闭合子图对应 闭合子图$V$和源点$s$构成$S$集，其余点和汇点$t$构成$T$集 证明 闭合子图是简单割 若闭合子图对应的割$(S,T)$不是简单割，则存在一条边$(u,v)$，$u\\in S$，$v \\in T$，且$c(u,v)=\\infty$。说明u的后续节点$v$不在$S$中，产生矛盾 简单割是闭合子图 对于$V$中任意一个点$u$，$u\\in S$。$u$的任意一条出边$c(u,v)=\\infty$，不会在简单割的割边集中，因此$v$不属于$T$，$v\\in S$。所以$V$的所有点均在$S$中，因此$S-s$是闭合子图 最小割就是最大权的闭合子图 割的容量$C(S,T)=T$中所有正权点的点权之和等于$+S$中所有负权点的权值绝对值之和 闭合子图的权值$W=S$中所有正权点的权值之和$-S$中所有负权点的权值绝对值之和 $C(S,T)+W=T$中所有正权点的权值之和$+S$中所有正权点的权值之和$=$所有正权点的权值之和 所以$W=$所有正权点的权值之和$-C(S,T)$","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"https://hsueh37.gitee.io/blog/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"前缀和优化建图2-SAT","slug":"前缀和优化建图2-SAT","date":"2019-10-25T14:10:00.000Z","updated":"2020-04-28T09:02:42.275Z","comments":true,"path":"2019/10/25/前缀和优化建图2-SAT/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/10/25/%E5%89%8D%E7%BC%80%E5%92%8C%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE2-SAT/","excerpt":"","text":"BZOJ #3495. PA2010 Riddle题目描述有$n$个城镇被分成了$k$个郡，有m条连接城镇的无向边。 要求给每个郡选择一个城镇作为首都，满足每条边至少有一个端点是首都。 思路每个城市只有是或者不是两个状态，很显然的$2-SAT$，其中$M$条边$(u, v)$很显然建边$u’\\rightarrow v, v’\\rightarrow u$ 对于每个郡只有一个城镇是首都 我们考虑前缀和。 首先新增$n$个点，对于$i$对应的新的节点为$i+n$。那么我们的$i+n$表示当前郡的前$i$个是否应有城市是否为首都，那么如果$i-1+n$选了，$i+n$必定选了，$i+n$没选，$i-1+n$必定没选。同时如果$i$选了，那么$i-1+n$必定没选，如果$i - 1 + n$选了，$i$一定没选 我们令$u1=i-1,u2=i,v1=i-1+n,v2=i+n$ 那么需要建边 $v1\\rightarrow v2$ $v2’\\rightarrow v1’$ $u2\\rightarrow v1’$ $v1 \\rightarrow u2’$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) do &#123; cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; err(x); &#125; while (0)void err() &#123; cout &lt;&lt; endl; &#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"using ll = long long;using db = double;const int N = 4e6 + 10;struct Edge &#123; int to, nxt; Edge() &#123;&#125; Edge(int to, int nxt) : to(to), nxt(nxt) &#123;&#125;&#125; edge[N &lt;&lt; 1];int head[N], tot;void Init() &#123; memset(head, -1, sizeof head); tot = 0;&#125;void addedge(int u, int v) &#123; edge[tot] = Edge(v, head[u]); head[u] = tot++;&#125;int Low[N], DFN[N], Stack[N], Belong[N];int Index, top;int scc;bool Instack[N];int num[N];void Tarjan(int u) &#123; int v; Low[u] = DFN[u] = ++Index; Stack[top++] = u; Instack[u] = true; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; v = edge[i].to; if (!DFN[v]) &#123; Tarjan(v); if (Low[u] &gt; Low[v]) Low[u] = Low[v]; &#125; else if (Instack[v] &amp;&amp; Low[u] &gt; DFN[v]) &#123; Low[u] = DFN[v]; &#125; &#125; if (Low[u] == DFN[u]) &#123; scc++; do &#123; v = Stack[--top]; Instack[v] = false; Belong[v] = scc; num[scc]++; &#125; while (u != v); &#125;&#125;bool solve(int n) &#123; memset(DFN, 0, sizeof DFN); memset(Instack, false, sizeof Instack); memset(num, 0, sizeof num); Index = scc = top = 0; for (int i = 0; i &lt; n; ++i) &#123; if (!DFN[i]) &#123; Tarjan(i); &#125; &#125; for (int i = 0; i &lt; n; i += 2) &#123; if (Belong[i] == Belong[i ^ 1]) &#123; return false; &#125; &#125; return true;&#125;int n, m, k;int a[N];void RUN() &#123; while (scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k) != EOF) &#123; Init(); for (int i = 1, x, y; i &lt;= m; ++i) &#123; scanf(\"%d %d\", &amp;x, &amp;y); --x, --y; addedge(x &lt;&lt; 1 ^ 1, y &lt;&lt; 1); addedge(y &lt;&lt; 1 ^ 1, x &lt;&lt; 1); &#125; for (int i = 0; i &lt; n; ++i) &#123; int x = i, y = i + n; addedge(x &lt;&lt; 1, y &lt;&lt; 1); addedge(y &lt;&lt; 1 ^ 1, x &lt;&lt; 1 ^ 1); &#125; for (int i = 1, w; i &lt;= k; ++i) &#123; scanf(\"%d\", &amp;w); for (int j = 1; j &lt;= w; ++j) &#123; scanf(\"%d\", a + j); --a[j]; &#125; for (int j = 2; j &lt;= w; ++j) &#123; int x = a[j - 1], y = a[j]; addedge((x + n) &lt;&lt; 1, (y + n) &lt;&lt; 1); addedge(((y + n) &lt;&lt; 1) ^ 1, ((x + n) &lt;&lt; 1) ^ 1); addedge(y &lt;&lt; 1, (x + n) &lt;&lt; 1 ^ 1); addedge((x + n) &lt;&lt; 1, y &lt;&lt; 1 ^ 1); &#125; &#125; puts(solve(4 * n) ? \"TAK\" : \"NIE\"); &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif// ios::sync_with_stdio(false);// cin.tie(nullptr), cout.tie(nullptr); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125;","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"https://hsueh37.gitee.io/blog/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"线段树优化建图","slug":"线段树优化建图","date":"2019-10-14T14:10:00.000Z","updated":"2020-09-09T14:03:27.316Z","comments":true,"path":"2019/10/14/线段树优化建图/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/10/14/%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE/","excerpt":"","text":"线段树优化建图模型需要多次一个区间向另一个区间连边的建图，求图的一些信息 思路建立两颗线段树，分别为$treeIn, treeOut$表示入边和出边 那么 到了$treeIn$的某个节点表示这个点所表示的区间进入 到了$treeOut$的某个节点表示从这个点表示的区间出去 连边： $treeIn$父亲节点向儿子节点连权值为$0$的边，表示进入这个父亲节点的边也可以到儿子节点 $treeOut$儿子节点向父亲节点连权值为$0$的边，表示从这个父亲节点出去的边也可以从儿子也可以走 那么对于每次连边最多连$log_2^n$条边 所以有$4n$个点，$4n+m*log_2^n$条边 模板CF 786B 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;bits/stdc++.h&gt;using namespace std;#define endl \"\\n\"using ll = long long;using db = double;const int N = 2e5 + 10;const ll INF = 0x3f3f3f3f3f3f3f3f;struct Edge &#123; int v, w; Edge() &#123;&#125; Edge(int v, int w) : v(v), w(w) &#123;&#125;&#125;;vector&lt;vector&lt;Edge&gt;&gt; G;int n, q, s, treeIn[N &lt;&lt; 2], treeOut[N &lt;&lt; 2];int cnt;ll dis[N &lt;&lt; 2];void build(int id, int l, int r) &#123; if (l == r) &#123; treeIn[id] = l; treeOut[id] = l; return; &#125; int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); treeIn[id] = ++cnt; treeOut[id] = ++cnt; G[treeOut[id &lt;&lt; 1]].push_back(Edge(treeOut[id], 0)); G[treeOut[id &lt;&lt; 1 | 1]].push_back(Edge(treeOut[id], 0)); G[treeIn[id]].push_back(Edge(treeIn[id &lt;&lt; 1], 0)); G[treeIn[id]].push_back(Edge(treeIn[id &lt;&lt; 1 | 1], 0));&#125;void updateIn(int id, int l, int r, int ql, int qr, int from, int cost) &#123; if (l &gt;= ql &amp;&amp; r &lt;= qr) &#123; G[from].push_back(Edge(treeIn[id], cost)); return; &#125; int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) updateIn(id &lt;&lt; 1, l, mid, ql, qr, from, cost); if (qr &gt; mid) updateIn(id &lt;&lt; 1 | 1, mid + 1, r, ql, qr, from, cost);&#125;void updateOut(int id, int l, int r, int ql, int qr, int to, int cost) &#123; if (l &gt;= ql &amp;&amp; r &lt;= qr) &#123; G[treeOut[id]].push_back(Edge(to, cost)); return; &#125; int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) updateOut(id &lt;&lt; 1, l, mid, ql, qr, to, cost); if (qr &gt; mid) updateOut(id &lt;&lt; 1 | 1, mid + 1, r, ql, qr, to, cost);&#125;struct node &#123; int v, w; node() &#123;&#125; node(int v, int w) : v(v), w(w) &#123;&#125; bool operator&lt;(const node &amp;other) const &#123; return w &gt; other.w; &#125;&#125;;void solve() &#123; memset(dis, 0x3f, sizeof dis); dis[s] = 0; priority_queue&lt;node&gt; pq; pq.push(node(s, 0)); while (!pq.empty()) &#123; int u = pq.top().v; pq.pop(); for (auto &amp;item: G[u]) &#123; if (dis[item.v] &gt; dis[u] + item.w) &#123; dis[item.v] = dis[u] + item.w; pq.push(node(item.v, dis[item.v])); &#125; &#125; &#125;&#125;void RUN() &#123; while (scanf(\"%d %d %d\", &amp;n, &amp;q, &amp;s) != EOF) &#123; G.clear(); G.resize(N &lt;&lt; 2); cnt = n; build(1, 1, n); for (int _q = 1, op, u, v, l, r, w; _q &lt;= q; ++_q) &#123; scanf(\"%d\", &amp;op); if (op == 1) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); G[u].push_back(Edge(v, w)); &#125; else if (op == 2) &#123; scanf(\"%d %d %d %d\", &amp;u, &amp;l, &amp;r, &amp;w); updateIn(1, 1, n, l, r, u, w); &#125; else if (op == 3) &#123; scanf(\"%d %d %d %d\", &amp;v, &amp;l, &amp;r, &amp;w); updateOut(1, 1, n, l, r, v, w); &#125; else &#123; assert(0); &#125; &#125; solve(); for (int i = 1; i &lt;= n; ++i) &#123; printf(\"%lld%c\", dis[i] == INF ? -1 : dis[i], \" \\n\"[i == n]); &#125; &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif// ios::sync_with_stdio(false);// cin.tie(nullptr), cout.tie(nullptr); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125;","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"https://hsueh37.gitee.io/blog/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"The 2018 ACM-ICPC Asia Beijing Regional Contest","slug":"The-2018-ACM-ICPC-Asia-Beijing-Regional-Contest","date":"2019-10-14T14:00:00.000Z","updated":"2020-04-28T09:02:42.271Z","comments":true,"path":"2019/10/14/The-2018-ACM-ICPC-Asia-Beijing-Regional-Contest/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/10/14/The-2018-ACM-ICPC-Asia-Beijing-Regional-Contest/","excerpt":"","text":"A. Jin Yong’s Wukong Ranking List签到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) do &#123; cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; err(x); &#125; while (0)void err() &#123; cout &lt;&lt; endl; &#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"using ll = long long;using db = double;const int N = 5e2 + 10;string s[N][2];map&lt;string, int&gt; mp;int tot;int getId(const string &amp;str) &#123; if (mp.count(str)) return mp[str]; mp[str] = ++tot; return mp[str];&#125;vector&lt;vector&lt;int&gt;&gt; G;int d[N];bool gao(int m) &#123; memset(d, 0, sizeof d); G.clear();G.resize(tot + 1); for (int i = 1; i &lt;= m; ++i) &#123; int u = getId(s[i][0]), v= getId(s[i][1]); G[u].push_back(v); ++d[v]; &#125; queue&lt;int&gt;q; for (int i =1; i &lt;= tot; ++i) &#123; if (d[i]) continue; q.push(i); &#125; int cnt = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); ++cnt; for (auto &amp;v : G[u]) &#123; if (--d[v] == 0) &#123; q.push(v); &#125; &#125; &#125; return cnt != tot;&#125;int n;void RUN() &#123; while (cin &gt;&gt; n) &#123; mp.clear(); tot = 0; for (int i = 1; i &lt;= n; ++i)&#123; cin &gt;&gt; s[i][0] &gt;&gt; s[i][1]; getId(s[i][0]); getId(s[i][1]); &#125; bool F = true; for (int i = 1; i &lt;= n; ++i) &#123; if (gao(i)) &#123; cout &lt;&lt; s[i][0] &lt;&lt; \" \" &lt;&lt; s[i][1] &lt;&lt; endl; F = false; break; &#125; &#125; if (F) cout &lt;&lt; \"0\\n\"; &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; B. Heshen’s Account Book模拟题 $Tips：$ 注意行末和下一行的连接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) do &#123; cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; err(x); &#125; while (0)void err() &#123; cout &lt;&lt; endl; &#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"using ll = long long;using db = double;using pSI = pair&lt;string, int&gt;;const int N = 2e5 + 10;int vis[N], num[N], pos;string s, t;bool f(const string &amp;str) &#123; int len = str.size(); if (len == 1) &#123; return isdigit(str[0]); &#125; if (str[0] == '0') return false; for (auto &amp;c : str) &#123; if (!isdigit(c)) &#123; return false; &#125; &#125; return true;&#125;int len;pSI get() &#123; pSI tmp = pSI(\"\", -1); while (pos &lt; len &amp;&amp; t[pos] == ' ') ++pos; while (pos &lt; len &amp;&amp; t[pos] != ' ') &#123; if (tmp.second == -1) tmp.second = vis[pos]; tmp.first += t[pos]; ++pos; &#125; return tmp;&#125;void RUN() &#123; s = t = \"\"; int pre = -1; int n = 0; while (getline(cin, s)) &#123; ++n; if (!t.empty() &amp;&amp; isdigit(t.end()[-1]) &amp;&amp; isdigit(s[0])) &#123; t += s; &#125; else &#123; t += \" \"; t += s; ++pre; &#125; int length = t.size(); for (int i = pre + 1; i &lt; length; ++i) vis[i] = n; pre = length - 1; &#125; len = t.size(); pos = 0; vector&lt;string&gt; vec; while (true) &#123; pSI tmp = get(); if (tmp.second == -1) break; if (f(tmp.first)) &#123; ++num[tmp.second]; vec.push_back(tmp.first); &#125; &#125; for (int i = 0, sze = vec.size(); i &lt; sze; ++i) &#123; cout &lt;&lt; vec[i] &lt;&lt; \" \\n\"[i == sze - 1]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; cout &lt;&lt; num[i] &lt;&lt; endl; &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; D. Frog and Portal构造 一个数可以被拆解成若干个斐波那契数，那么构造一种传送门方案使得走法是若干个斐波那契数累加即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) do &#123; cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; err(x); &#125; while (0)void err() &#123; cout &lt;&lt; endl; &#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"using ll = long long;using db = double;const int N = 2e2 + 10;ll m;ll f[N];int a[N];void RUN() &#123; f[0] = f[1] = 1; for (int i = 2; i &lt;= 50; ++i) &#123; f[i] = f[i - 1] + f[i - 2]; &#125; while (scanf(\"%lld\", &amp;m) != EOF) &#123; if (m == 0) &#123; puts(\"2\\n1 1\\n2 1\"); continue; &#125; *a = 0; for (int i = 50; i &gt;= 0; --i) &#123; if(m &gt;= f[i]) &#123; a[++*a] = i; m -= f[i]; &#125; &#125; printf(\"%d\\n\", *a + 1); for (int i = 1; i &lt;= *a; ++i) &#123; printf(\"%d %d\\n\", 2 * i - 1, 200 - a[i]); &#125; printf(\"%d %d\\n\", 2 * *a, 2 * *a); &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif// ios::sync_with_stdio(false);// cin.tie(nullptr), cout.tie(nullptr); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; H. Approximate Matching题意：给出一个长度为$n$个长度模式串，问有多少个长度为$m$文本串使得$Approximate Matching($找到一个最多一个字符不一样的子串$)$ 思路：构建$ACAM$，在$ACAM$上$dp$ $dp[i][j]$表示文本串的$i$个字符在$trie$的$j$节点转移即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) do &#123; cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; err(x); &#125; while (0)void err() &#123; cout &lt;&lt; endl; &#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"using ll = long long;using db = double;const int N = 1e4 + 10;int n, m;char str[N];ll f[50][N];struct ACAM &#123; struct node &#123; int nx[2], fail; int cnt; node() &#123; memset(nx, -1, sizeof nx); cnt = 0; &#125; &#125; t[N]; int root, tot; int newnode() &#123; ++tot; t[tot] = node(); return tot; &#125; void Init() &#123; tot = 0; root = newnode(); &#125; void insert(char *s) &#123; int len = strlen(s); int now = root; for (int i = 0; i &lt; len; ++i) &#123; if (t[now].nx[s[i] - '0'] == -1) t[now].nx[s[i] - '0'] = newnode(); now = t[now].nx[s[i] - '0']; &#125; ++t[now].cnt; &#125; void build() &#123; queue&lt;int&gt; q; t[root].fail = root; for (int i = 0; i &lt; 2; ++i) &#123; if (t[root].nx[i] == -1) &#123; t[root].nx[i] = root; &#125; else &#123; t[t[root].nx[i]].fail = root; q.push(t[root].nx[i]); &#125; &#125; while (!q.empty()) &#123; int now = q.front(); q.pop(); for (int i = 0; i &lt; 2; ++i) &#123; if (t[now].nx[i] == -1) &#123; t[now].nx[i] = t[t[now].fail].nx[i]; &#125; else &#123; t[t[now].nx[i]].fail = t[t[now].fail].nx[i]; q.push(t[now].nx[i]); &#125; &#125; &#125; &#125; ll gao() &#123; for (int i = 0; i &lt;= m; ++i) for (int j = 0; j &lt;= tot; ++j) f[i][j] = 0; f[0][root] = 1; for (int i = 0; i &lt; m; ++i) &#123; for (int j = 1; j &lt;= tot; ++j) &#123; if (t[j].cnt &gt; 0) continue; for (int k = 0; k &lt; 2; ++k) &#123; if (t[j].nx[k] != -1) &#123; f[i + 1][t[j].nx[k]] += f[i][j]; continue; &#125; &#125; &#125; &#125; ll res = 1ll &lt;&lt; m; for (int i = 1; i &lt;= tot; ++i) &#123; if (t[i].cnt) continue; res -= f[m][i]; &#125; return res; &#125;&#125; acam;void RUN() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d %d\", &amp;n, &amp;m); scanf(\"%s\", str); acam.Init(); acam.insert(str); for (int i = 0; i &lt; n; ++i) &#123; str[i] = ((str[i] - '0') ^ 1) + '0'; acam.insert(str); str[i] = ((str[i] - '0') ^ 1) + '0'; &#125; acam.build(); printf(\"%lld\\n\", acam.gao()); &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif// ios::sync_with_stdio(false);// cin.tie(nullptr), cout.tie(nullptr); RUN();#ifdef LOCAL_JUDGE// cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; I. Palindromes题意：询问第$k$大的回文数字 思路：打表找规律 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) do &#123; cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; err(x); &#125; while (0)void err() &#123; cout &lt;&lt; endl; &#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"using ll = long long;using db = double;const int N = 1e6 + 10;char str[N];void RUN() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%s\", str + 1); int len = strlen(str + 1); if (len == 1) &#123; printf(\"%c\\n\", str[1] - 1); continue; &#125; if (str[1] &gt; '1') &#123; str[1]--; printf(\"%s\", str + 1); for (int i = len - 1; i &gt;= 1; --i) &#123; putchar(str[i]); &#125; &#125; else &#123; if (str[2] == '0') &#123; for (int i = 1; i &lt; len; ++i) str[i] = str[i + 1]; str[1] = '9'; str[len] = 0; len--; printf(\"%s\", str + 1); reverse(str + 1, str + len); str[len] = 0; printf(\"%s\", str + 1); &#125; else &#123; for (int i = 1; i &lt; len; ++i) str[i] = str[i + 1]; str[len] = 0; len--; printf(\"%s\", str + 1); reverse(str + 1, str + len + 1); printf(\"%s\", str + 1); &#125; &#125; puts(\"\"); &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif// ios::sync_with_stdio(false);// cin.tie(nullptr), cout.tie(nullptr); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; J. Rikka with Triangles题意：给出$n$个点，求所有锐角三角形的面积和。$n\\leq2000$ 思路：枚举每个点进行极角排序，双指针枚举计算所有三角形面积$rea1$以及直角三角形和钝角三角形面积和$res2$那么答案为$\\frac{res1 - 2 \\times res2}{3}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) do &#123; cout &lt;&lt; \"\\033[32;1m\" &lt;&lt; #x &lt;&lt; \" -&gt; \"; err(x); &#125; while (0)void err() &#123; cout &lt;&lt; \"\\033[39;0m\" &lt;&lt; endl; &#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"using ll = long long;using db = double;using LL = __int128;const int N = 5e3 + 10;const ll mod = 998244353;template&lt;class T&gt;inline bool read(T &amp;ret) &#123; char c; int sgn; if (c = getchar(), c == EOF) return false; while (c != '-' &amp;&amp; !isdigit(c)) c = getchar(); sgn = (c == '-') ? -1 : 1; ret = (c == '-') ? 0 : (c - '0'); while (c = getchar(), isdigit(c)) ret = ret * 10 + (c - '0'); ret *= sgn; return true;&#125;ll qpow(ll x, ll n) &#123; ll res = 1; while (n) &#123; if (n &amp; 1) &#123; res = res * x % mod; &#125; x = x * x % mod; n &gt;&gt;= 1; &#125; return res;&#125;int n;struct Point &#123; LL x, y; Point() &#123;&#125; Point(LL x, LL y) : x(x), y(y) &#123;&#125; Point operator-(const Point &amp;other) const &#123; return &#123;x - other.x, y - other.y&#125;; &#125; Point operator+(const Point &amp;other) const &#123; return &#123;x + other.x, y + other.y&#125;; &#125; LL operator^(const Point &amp;other) const &#123; return x * other.y - y * other.x; &#125; bool operator&lt;(const Point &amp;other) const &#123; if (y &lt; 0 &amp;&amp; other.y &gt; 0) return true; if (y &gt; 0 &amp;&amp; other.y &lt; 0) return false; if (y == 0 &amp;&amp; other.y == 0) &#123; return (x &lt; 0 &amp;&amp; other.x &gt; 0); &#125; else &#123; return ((*this) ^ other) &gt; 0; &#125; &#125;&#125; p[N], qrr[N];LL sumx[N], sumy[N];LL gao() &#123; LL res1 = 0, res2 = 0; for (int i = 1; i &lt;= n; ++i) &#123; int cnt = 0; for (int j = 1; j &lt;= n; ++j) &#123; if (i == j) continue; qrr[++cnt] = p[j] - p[i]; &#125; sort(qrr + 1, qrr + 1 + cnt); for (int j = 1; j &lt;= cnt; ++j) &#123; qrr[j + cnt] = qrr[j]; &#125; sumx[0] = sumy[0] = 0; cnt &lt;&lt;= 1; for (int j = 1; j &lt;= cnt; ++j) &#123; sumx[j] = (sumx[j - 1] + qrr[j].x) % mod; sumy[j] = (sumy[j - 1] + qrr[j].y) % mod; &#125; int q = 1, s = 1, t = 1; for (int j = 1; j &lt; n; ++j) &#123; q = max(q, j); Point _90 = Point(-qrr[j].y, qrr[j].x); Point _180 = Point(-qrr[j].x, -qrr[j].y); while (q &lt; cnt &amp;&amp; (qrr[q + 1] ^ qrr[j]) == 0) ++q; while (s &lt; cnt &amp;&amp; (s &lt; q || ((qrr[s + 1] ^ _90) &gt; 0 &amp;&amp; (qrr[s + 1] ^ qrr[j]) &lt;= 0))) ++s; while (t &lt; cnt &amp;&amp; (t &lt; s || ((qrr[t + 1] ^ _180) &gt; 0 &amp;&amp; (qrr[t + 1] ^ _90) &lt;= 0))) ++t; res1 = (res1 + (sumy[s] - sumy[q] + mod) % mod * (qrr[j].x % mod) % mod - (sumx[s] - sumx[q] + mod) % mod * (qrr[j].y) % mod + mod) % mod; res2 = (res2 + (sumy[t] - sumy[s] + mod) % mod * (qrr[j].x % mod) % mod - (sumx[t] - sumx[s] + mod) % mod * (qrr[j].y) % mod + mod) % mod; &#125; &#125; return ((res1 - res2 * 2 % mod + mod) % mod * qpow(3, mod - 2) % mod) % mod;&#125;void RUN() &#123; int T; read(T); while (T--) &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(p[i].x), read(p[i].y); &#125; ll res = gao(); printf(\"%lld\\n\", res); &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif// ios::sync_with_stdio(false);// cin.tie(nullptr), cout.tie(nullptr); RUN();#ifdef LOCAL_JUDGE// cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125;","categories":[],"tags":[{"name":"Regional","slug":"Regional","permalink":"https://hsueh37.gitee.io/blog/tags/Regional/"}]},{"title":"有上下界的网络流学习","slug":"有上下界的网络流学习","date":"2019-10-08T07:00:00.000Z","updated":"2020-04-28T09:02:42.276Z","comments":true,"path":"2019/10/08/有上下界的网络流学习/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/10/08/%E6%9C%89%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%9A%84%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"无源汇有上下界可行流(也就是循环流)模型给定一个网络，求出一个流，是的每条边的流量满足$[L_i, R_i]$，同时每个点的流入量$=$流出量 核心将一个不满足流量守恒的初始流调整为满足流量守恒的流 思路如果存在可行解，那么每条边的流量一定大于$L_i$，因此我们假设让每条边的初始流量为下限，得到一个初始流同时建立残余网络（每条边的流量为$R_i-L_i$）。但是初始流不一定满足流量守恒。 建立附加顶点$SS,TT$后分以下三种情况 流入量$=$流出量 流入量$\\neq$流出量 流入量$&gt;$流出量，增加一条边到附加点$TT$ 流入量$&lt;$流出量，增加一条边从附加点到$SS$到当前点 其中$SS、TT$的流量的绝对值一定相同 最后检查最大流是否为$SS$的所有流量即可 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140//ZOJ2314 给定一个网络流模型，问否是每条边流量都能满足[L_i, R_i] 如果可以输出YES并且输出每条边的流量，否则输出NO#include &lt;bits/stdc++.h&gt;using namespace std;#define endl \"\\n\"using ll = long long;using db = double;const int N = 1e6 + 10;const int INF = 0x3f3f3f3f;struct Dicnic &#123; static const int M = 1e6 + 10; static const int N = 2e2 + 10; struct Edge &#123; int to, nxt, flow; Edge() &#123;&#125; Edge(int to, int nxt, int flow) : to(to), nxt(nxt), flow(flow) &#123;&#125; &#125; edge[M &lt;&lt; 1]; int S, T; int head[N], dep[N], tot; void Init() &#123; memset(head, -1, sizeof head); tot = 0; &#125; void set(int _S, int _T) &#123; S = _S, T = _T; &#125; void addedge(int u, int v, int w, int rw = 0) &#123; edge[tot] = Edge(v, head[u], w); head[u] = tot++; edge[tot] = Edge(u, head[v], rw); head[v] = tot++; &#125; bool BFS() &#123; memset(dep, -1, sizeof dep); queue&lt;int&gt; q; q.push(S); dep[S] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = edge[i].nxt) &#123; if (edge[i].flow &amp;&amp; dep[edge[i].to] == -1) &#123; dep[edge[i].to] = dep[u] + 1; q.push(edge[i].to); &#125; &#125; &#125; return dep[T] &gt;= 0; &#125; int DFS(int u, int f) &#123; if (u == T || f == 0) return f; int w, used = 0; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; if (edge[i].flow &amp;&amp; dep[edge[i].to] == dep[u] + 1) &#123; w = DFS(edge[i].to, min(f - used, edge[i].flow)); edge[i].flow -= w; edge[i ^ 1].flow += w; used += w; if (used == f) return f; &#125; &#125; if (!used) dep[u] = -1; return used; &#125; int gao() &#123; int res = 0; while (BFS()) &#123; res += DFS(S, INF); &#125; return res; &#125;&#125; dicnic;int n, m, low[N], totFlow[N];void RUN() &#123; memset(totFlow, 0, sizeof totFlow); scanf(\"%d %d\", &amp;n, &amp;m); dicnic.Init(); int S = 0, T = n + 1; dicnic.set(S, T); for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; scanf(\"%d %d %d %d\", &amp;u, &amp;v, low + i, &amp;w); dicnic.addedge(u, v, w - low[i]); totFlow[u] -= low[i]; totFlow[v] += low[i]; &#125; int sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (totFlow[i] &gt;= 0) &#123; sum += totFlow[i]; dicnic.addedge(S, i, totFlow[i]); &#125; else &#123; dicnic.addedge(i, T, -totFlow[i]); &#125; &#125; int tmp = dicnic.gao(); if (tmp == sum) &#123; puts(\"YES\"); for (int i = 1; i &lt;= m; ++i) &#123; printf(\"%d\\n\", low[i] + dicnic.edge[2 * i - 1].flow); &#125; &#125; else &#123; puts(\"NO\"); &#125; puts(\"\");&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif// ios::sync_with_stdio(false);// cin.tie(nullptr), cout.tie(nullptr); int _T; scanf(\"%d\", &amp;_T); while (_T--) &#123; RUN(); &#125;#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; 有源汇有上下界可行流模型现在的网络有一个源点$S$和汇点$T$,求出一个流使得源点的总流出量等于汇点的总流入量,其他的点满足流量守恒,而且每条边的流量满足上界和下界限制 核心将有源汇右上下界可行流转换为无源汇上下界可行流 思路由于存在$S, T$两个点，他们的流入量$\\neq$流出量，但是$S$的流出量$=$$T$的流出量，增加一条变$T\\rightarrow S$，流量为无限的边，就使得每个点的流入量等于流出量，在增加虚拟源汇点$SS,TT$即可转换为无源汇右上下界可行流 有源汇有上下界最大流模型现在的网络有一个源点s和汇点t,求出一个流使得源点的总流出量等于汇点的总流入量,其他的点满足流量守恒,而且每条边的流量满足上界和下界限制.在这些前提下要求总流量最大 核心先进行有源汇有上下界可行流判断，然后在残余网络上跑$S-T$的最大流即可 思路代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161// ZOJ 3229 一个人给m个女神拍照，总共拍摄n天，其中每天会给C个女神拍照，每天拍照限定数量为D，同时给每个女神拍照数量限制为[L_i, R_i], 对于每个女神拍照总数不能少于Gi，问总的拍照数量最大值#include &lt;bits/stdc++.h&gt;using namespace std;#define endl \"\\n\"using ll = long long;using db = double;const int N = 1e3 + 10;const int M = 2e3 + 10;const int INF = 0x3f3f3f3f;struct Dicnic &#123; static const int M = 1e6 + 10; static const int N = 3e3 + 10; struct Edge &#123; int to, nxt, flow; Edge() &#123;&#125; Edge(int to, int nxt, int flow) : to(to), nxt(nxt), flow(flow) &#123;&#125; &#125; edge[M &lt;&lt; 1]; int S, T; int head[N], dep[N], tot; void Init() &#123; memset(head, -1, sizeof head); tot = 0; &#125; void set(int _S, int _T) &#123; S = _S, T = _T; &#125; void addedge(int u, int v, int w, int rw = 0) &#123; edge[tot] = Edge(v, head[u], w); head[u] = tot++; edge[tot] = Edge(u, head[v], rw); head[v] = tot++; &#125; bool BFS() &#123; memset(dep, -1, sizeof dep); queue&lt;int&gt; q; q.push(S); dep[S] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = edge[i].nxt) &#123; if (edge[i].flow &amp;&amp; dep[edge[i].to] == -1) &#123; dep[edge[i].to] = dep[u] + 1; q.push(edge[i].to); &#125; &#125; &#125; return dep[T] &gt; 0; &#125; int DFS(int u, int f) &#123; if (u == T || f == 0) return f; int w, used = 0; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; if (edge[i].flow &amp;&amp; dep[edge[i].to] == dep[u] + 1) &#123; w = DFS(edge[i].to, min(f - used, edge[i].flow)); edge[i].flow -= w; edge[i ^ 1].flow += w; used += w; if (used == f) return f; &#125; &#125; if (!used) dep[u] = -1; return used; &#125; int gao() &#123; int res = 0; while (BFS()) &#123; res += DFS(S, INF); &#125; return res; &#125;&#125; dicnic;int n, m, low[N][M], totFlow[N * M], pos[N][M];void RUN() &#123; memset(pos, -1, sizeof pos); memset(totFlow, 0, sizeof totFlow); int S = 0, T = n + m + 1; dicnic.Init(); for (int i = 1, x; i &lt;= m; ++i) &#123; scanf(\"%d\", &amp;x); dicnic.addedge(i + n, T, INF - x); totFlow[i + n] -= x; totFlow[T] += x; &#125; for (int i = 1, x, y; i &lt;= n; ++i) &#123; scanf(\"%d %d\", &amp;x, &amp;y); dicnic.addedge(S, i, y); for (int j = 1, ith, up, down; j &lt;= x; ++j) &#123; scanf(\"%d %d %d\", &amp;ith, &amp;down, &amp;up); ++ith; pos[i][ith] = dicnic.tot; dicnic.addedge(i, n + ith, up - down); totFlow[i] -= down; totFlow[n + ith] += down; low[i][ith] = down; &#125; &#125; int sum = 0; dicnic.addedge(T, S, INF); int SS = n + m + 2, TT = n + m + 3; for (int i = S; i &lt;= T; ++i) &#123; if (totFlow[i] &lt; 0) &#123; dicnic.addedge(i, TT, -totFlow[i]); &#125; if (totFlow[i] &gt; 0) &#123; sum += totFlow[i]; dicnic.addedge(SS, i, totFlow[i]); &#125; &#125; dicnic.set(SS, TT); if (dicnic.gao() == sum) &#123; dicnic.set(S, T); int res = dicnic.gao(); printf(\"%d\\n\", res); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (pos[i][j] != -1) &#123; printf(\"%d\\n\", low[i][j] + dicnic.edge[pos[i][j] ^ 1].flow); &#125; &#125; &#125; &#125; else &#123; puts(\"-1\"); &#125; puts(\"\");&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif// ios::sync_with_stdio(false);// cin.tie(nullptr), cout.tie(nullptr); while (scanf(\"%d %d\", &amp;n, &amp;m) != EOF) &#123; RUN(); &#125;#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; 有源汇有上下界最小流模型现在的网络有一个源点s和汇点t,求出一个流使得源点的总流出量等于汇点的总流入量,其他的点满足流量守恒,而且每条边的流量满足上界和下界限制.在这些前提下要求总流量最小. 核心跑完有源汇有上下界可行流后删除原图中的所有流量 思路先跑出一个有源汇可行流，假如我们能在残量网络上找到一条$S-T$的路径使得去掉这条路径上的流量之后仍然满足流量下限,我们就可以得到一个更小的流。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143//bzoj2502 给定一个DAG，每轮选择一个点开始清除一条路上的所有路径，问最小轮数#include &lt;bits/stdc++.h&gt;using namespace std;#define endl \"\\n\"typedef long long ll;const int N = 1e3 + 10;const int INF = 0x3f3f3f3f;struct Dicnic &#123; static const int M = 1e6 + 10; static const int N = 3e3 + 10; struct Edge &#123; int to, nxt, flow; Edge() &#123;&#125; Edge(int to, int nxt, int flow) : to(to), nxt(nxt), flow(flow) &#123;&#125; &#125; edge[M &lt;&lt; 1]; int S, T; int head[N], dep[N], tot; void Init() &#123; memset(head, -1, sizeof head); tot = 0; &#125; void set(int _S, int _T) &#123; S = _S, T = _T; &#125; void addedge(int u, int v, int w, int rw = 0) &#123; edge[tot] = Edge(v, head[u], w); head[u] = tot++; edge[tot] = Edge(u, head[v], rw); head[v] = tot++; &#125; bool BFS() &#123; memset(dep, -1, sizeof dep); queue&lt;int&gt; q; q.push(S); dep[S] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = edge[i].nxt) &#123; if (edge[i].flow &amp;&amp; dep[edge[i].to] == -1) &#123; dep[edge[i].to] = dep[u] + 1; q.push(edge[i].to); &#125; &#125; &#125; return dep[T] &gt; 0; &#125; int DFS(int u, int f) &#123; if (u == T || f == 0) return f; int w, used = 0; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; if (edge[i].flow &amp;&amp; dep[edge[i].to] == dep[u] + 1) &#123; w = DFS(edge[i].to, min(f - used, edge[i].flow)); edge[i].flow -= w; edge[i ^ 1].flow += w; used += w; if (used == f) return f; &#125; &#125; if (!used) dep[u] = -1; return used; &#125; int gao() &#123; int res = 0; while (BFS()) &#123; res += DFS(S, INF); &#125; return res; &#125; void Del(int u) &#123; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; edge[i].flow = edge[i ^ 1].flow = 0; &#125; &#125;&#125; dicnic;int n, totFlow[N];void RUN() &#123; dicnic.Init(); memset(totFlow, 0, sizeof totFlow); for (int i = 1, m; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;m); for (int j = 1, x; j &lt;= m; ++j) &#123; scanf(\"%d\", &amp;x); dicnic.addedge(i, x, INF); totFlow[i]--, totFlow[x]++; &#125; &#125; int S = 0, T = n + 1, SS = n + 2, TT = n + 3; for (int i = 1; i &lt;= n; ++i) &#123; dicnic.addedge(S, i, INF); dicnic.addedge(i, T, INF); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (totFlow[i] &lt; 0) &#123; dicnic.addedge(i, TT, -totFlow[i]); &#125; else &#123; dicnic.addedge(SS, i, totFlow[i]); &#125; &#125; dicnic.addedge(T, S, INF); dicnic.set(SS, TT); dicnic.gao(); int Max = dicnic.edge[dicnic.tot - 1].flow; dicnic.edge[dicnic.tot - 1].flow = dicnic.edge[dicnic.tot - 2].flow = 0; dicnic.Del(SS), dicnic.Del(TT); dicnic.set(T, S); printf(\"%d\\n\", Max - dicnic.gao());&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif// ios::sync_with_stdio(false);// cin.tie(nullptr), cout.tie(nullptr); while (scanf(\"%d\", &amp;n) != EOF) &#123; RUN(); &#125;#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125;","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"https://hsueh37.gitee.io/blog/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"期望","slug":"期望","date":"2019-09-05T11:00:00.000Z","updated":"2020-04-28T09:02:42.276Z","comments":true,"path":"2019/09/05/期望/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/09/05/%E6%9C%9F%E6%9C%9B/","excerpt":"","text":"LOJ-2538 「PKUWC2018」Slay the Spire$f[i][j]$表示前$i$张用了$j$张强化，那么转移为 f[i][j] = \\begin{cases} f[i - 1][j] + f[i - 1][j - 1] * a[i] \\quad j\\leq k-1\\\\ f[i-1][j]+f[i][j] \\quad otherwise \\end{cases}$g[i][j]$表示前$i$张用了$j$张攻击，那么转移为 g[i][j]= \\begin{cases} g[i - 1][j]+C_{i-1}^{j-1}*b[i] \\quad j\\leq m-(k-1)\\\\ g[i - 1][j - 1] + g[i - 1][j] + C_{i-1}^{j-1}*b[i] \\quad otherwise \\end{cases}那么答案为$\\sum_{i=0}^{m} f[i]\\cdot g[m-i]$ LightOJ-1151 Snakes and Ladders题意: 每次抛骰子走$1-6$步，问走到$100$的期望，其中有$n$个格子进行传送 思路：如果没有传送则，$f[i]=\\frac{1}{6}\\cdot \\sum_{j=1}^{6} f[i+j]$如果有传送，则$f[i]=f[nxt[i]]$ 高斯消元","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"https://hsueh37.gitee.io/blog/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"几何","slug":"几何","date":"2019-09-03T06:00:00.000Z","updated":"2020-04-28T09:02:42.275Z","comments":true,"path":"2019/09/03/几何/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/09/03/%E5%87%A0%E4%BD%95/","excerpt":"","text":"2018-2019 ACM-ICPC, Asia Shenyang Regional ContestL. Machining Disc Rotors题意：给定一个圆，被$n$个圆切割，求剩下部分最远距离 思路：最远距离一定是两个交点或者原本圆的直径(水) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &lt;bits/stdc++.h&gt;using namespace std;#define endl \"\\n\"using ll = long long;using db = double;const int N = 110;const db eps = 1e-11;int sgn(db x) &#123; if (fabs(x) &lt; eps) return 0; else return x &gt; 0 ? 1 : -1;&#125;struct Point &#123; db x, y; Point() &#123;&#125; Point(db _x, db _y) &#123; x = _x, y = _y; &#125; db len() &#123; return hypot(x, y); &#125; db distance(Point &amp;other) &#123; return hypot(x - other.x, y - other.y); &#125; Point operator+(const Point &amp;other) const &#123; return &#123;x + other.x, y + other.y&#125;; &#125; Point operator-(const Point &amp;other) const &#123; return &#123;x - other.x, y - other.y&#125;; &#125; Point trunc(db r) &#123; db l = len(); if (!sgn(l)) &#123; return *this; &#125; r /= l; return &#123;x * r, y * r&#125;; &#125; Point rotright() &#123; return &#123;-y, x&#125;; &#125; Point rotleft() &#123; return &#123;y, -x&#125;; &#125; Point change() &#123; return &#123;-x, -y&#125;; &#125;&#125;;struct Circle &#123; Point p; db r; void input() &#123; scanf(\"%lf %lf %lf\", &amp;p.x, &amp;p.y, &amp;r); &#125; Circle() &#123;&#125; Circle(Point _p, db _r) &#123; p = _p, r = _r; &#125; Circle(db _x, db _y, db _r) &#123; p = Point(_x, _y); r = _r; &#125; int relationcicle(Circle v) &#123; db d = p.distance(v.p); if (sgn(d - r - v.r) &gt; 0) return 5; if (sgn(d - r - v.r) == 0) return 4; db l = fabs(r - v.r); if (sgn(d - r - v.r) &lt; 0 &amp;&amp; sgn(d - l) &gt; 0) return 3; if (sgn(d - l) == 0) return 2; else return 1; &#125; int pointcrosscircle(Circle v, Point &amp;p1, Point &amp;p2) &#123; int rel = relationcicle(v); if (rel == 1 || rel == 5) return 0; db d = p.distance(v.p); db l = (d * d + r * r - v.r * v.r) / (2 * d); db h = sqrt(r * r - l * l); Point tmp = p + (v.p - p).trunc(l); p1 = tmp + ((v.p - p).rotleft().trunc(h)); p2 = tmp + ((v.p - p).rotright().trunc(h)); if (rel == 2 || rel == 4) &#123; return 1; &#125; return 2; &#125;&#125; o, a[N];int n;db r;vector&lt;Point&gt; vec;void gao(Circle tmp) &#123; Point p[2]; int res = o.pointcrosscircle(tmp, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; vec.push_back(p[i]); &#125;&#125;bool check() &#123; for (auto p : vec) &#123; p = p.change(); bool F = true; for (int i = 1; i &lt;= n; ++i) &#123; db dis = p.distance(a[i].p); if (sgn(dis - a[i].r) &lt; 0) &#123; F = false; break; &#125; &#125; if (F) &#123; return true; &#125; &#125; return false;&#125;void RUN() &#123; vec.clear(); scanf(\"%d %lf\", &amp;n, &amp;r); o = Circle(0.0, 0.0, r); for (int i = 1; i &lt;= n; ++i) &#123; a[i].input(); gao(a[i]); &#125; db res = 0; for (int i = 0, len = vec.size(); i &lt; len; ++i) &#123; for (int j = i + 1; j &lt; len; ++j) &#123; res = max(res, vec[i].distance(vec[j])); &#125; &#125; if (check()) &#123; res = 2 * r; &#125; printf(\"%.15f\\n\", res);&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif// ios::sync_with_stdio(false);// cin.tie(nullptr), cout.tie(nullptr); int _T; scanf(\"%d\", &amp;_T); for (int cas = 1; cas &lt;= _T; ++cas) &#123; printf(\"Case #%d: \", cas); RUN(); &#125;#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; 2018 German Collegiate Programming Contest (GCPC 18)B. Battle Royale题意：求两个点不穿过圆的最短距离 思路：高中数学水一水 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;bits/stdc++.h&gt;using namespace std;#define endl \"\\n\"using ll = long long;using db = double;const db eps = 1e-9;int sgn(db x) &#123; if (fabs(x) &lt; eps) return false; else return x &gt; 0 ? 1 : -1;&#125;struct Point &#123; db x, y; Point() &#123;&#125; Point(db _x, db _y) &#123; x = _x, y = _y; &#125; db operator^(const Point &amp;other) const &#123; return x * other.y - y * other.x; &#125; db operator*(const Point &amp;other) const &#123; return x * other.x + y * other.y; &#125; Point operator-(const Point &amp;other) const &#123; return &#123;x - other.x, y - other.y&#125;; &#125; db distance(Point p) &#123; return hypot(x - p.x, y - p.y); &#125;&#125; A, B, o;struct Line &#123; Point s, e; Line() &#123;&#125; db length() &#123; return s.distance(e); &#125; Line(Point _s, Point _e) &#123; s = _s, e = _e; &#125; db dispointtoline(Point p) &#123; return fabs((p - s) ^ (e - s)) / length(); &#125; db dispointtoseg(Point p) &#123; if (sgn((p - s) * (e - s)) &lt; 0 || sgn((p - e) * (s - e)) &lt; 0) &#123; return min(p.distance(s), p.distance(e)); &#125; else &#123; return dispointtoline(p); &#125; &#125;&#125; l;db r;db f(db a, db b, db c) &#123; return acos((a * a + b * b - c * c) / (2.0 * a * b));&#125;void RUN() &#123; scanf(\"%lf %lf\", &amp;A.x, &amp;A.y); scanf(\"%lf %lf\", &amp;B.x, &amp;B.y); scanf(\"%lf %lf %lf\", &amp;o.x, &amp;o.y, &amp;r); scanf(\"%lf %lf %lf\", &amp;o.x, &amp;o.y, &amp;r); l = Line(A, B); db dis = l.dispointtoseg(o); db res = 0; if (sgn(dis - r) &gt;= 0) &#123; res = A.distance(B); &#125; else &#123; dis = A.distance(B); db dis1 = A.distance(o); db c1 = sqrt(dis1 * dis1 - r * r); res += c1; db dis2 = B.distance(o); db c2 = sqrt(dis2 * dis2 - r * r); res += c2; db arc = f(dis1, dis2, dis); db arc1 = f(dis1, r, c1); db arc2 = f(dis2, r, c2); db arc3 = arc - arc1 - arc2; res += r * arc3; &#125; printf(\"%.10f\\n\", res);&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; ACM-ICPC Asia Beijing Regional Contest 2018 ReproductionJ. Rikka with Triangles题意：给出$n$个点，求所有锐角三角形的面积和。$n\\leq2000$ 思路：枚举每个点进行极角排序，双指针枚举计算所有三角形面积$rea1$以及直角三角形和钝角三角形面积和$res2$那么答案为$\\frac{res1 - 2 \\times res2}{3}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146#include &lt;bits/stdc++.h&gt;using namespace std;#define dbg(x...) do &#123; cout &lt;&lt; \"\\033[32;1m\" &lt;&lt; #x &lt;&lt; \" -&gt; \"; err(x); &#125; while (0)void err() &#123; cout &lt;&lt; \"\\033[39;0m\" &lt;&lt; endl; &#125;template&lt;class T, class... Ts&gt;void err(const T &amp;arg, const Ts &amp;... args) &#123; cout &lt;&lt; arg &lt;&lt; ' '; err(args...);&#125;#define endl \"\\n\"using ll = long long;using db = double;using LL = __int128;const int N = 5e3 + 10;const ll mod = 998244353;template&lt;class T&gt;inline bool read(T &amp;ret) &#123; char c; int sgn; if (c = getchar(), c == EOF) return false; while (c != '-' &amp;&amp; !isdigit(c)) c = getchar(); sgn = (c == '-') ? -1 : 1; ret = (c == '-') ? 0 : (c - '0'); while (c = getchar(), isdigit(c)) ret = ret * 10 + (c - '0'); ret *= sgn; return true;&#125;ll qpow(ll x, ll n) &#123; ll res = 1; while (n) &#123; if (n &amp; 1) &#123; res = res * x % mod; &#125; x = x * x % mod; n &gt;&gt;= 1; &#125; return res;&#125;int n;struct Point &#123; LL x, y; Point() &#123;&#125; Point(LL x, LL y) : x(x), y(y) &#123;&#125; Point operator-(const Point &amp;other) const &#123; return &#123;x - other.x, y - other.y&#125;; &#125; Point operator+(const Point &amp;other) const &#123; return &#123;x + other.x, y + other.y&#125;; &#125; LL operator^(const Point &amp;other) const &#123; return x * other.y - y * other.x; &#125; bool operator&lt;(const Point &amp;other) const &#123; if (y &lt; 0 &amp;&amp; other.y &gt; 0) return true; if (y &gt; 0 &amp;&amp; other.y &lt; 0) return false; if (y == 0 &amp;&amp; other.y == 0) &#123; return (x &lt; 0 &amp;&amp; other.x &gt; 0); &#125; else &#123; return ((*this) ^ other) &gt; 0; &#125; &#125;&#125; p[N], qrr[N];LL sumx[N], sumy[N];LL gao() &#123; LL res1 = 0, res2 = 0; for (int i = 1; i &lt;= n; ++i) &#123; int cnt = 0; for (int j = 1; j &lt;= n; ++j) &#123; if (i == j) continue; qrr[++cnt] = p[j] - p[i]; &#125; sort(qrr + 1, qrr + 1 + cnt); for (int j = 1; j &lt;= cnt; ++j) &#123; qrr[j + cnt] = qrr[j]; &#125; sumx[0] = sumy[0] = 0; cnt &lt;&lt;= 1; for (int j = 1; j &lt;= cnt; ++j) &#123; sumx[j] = (sumx[j - 1] + qrr[j].x) % mod; sumy[j] = (sumy[j - 1] + qrr[j].y) % mod; &#125; int q = 1, s = 1, t = 1; for (int j = 1; j &lt; n; ++j) &#123; q = max(q, j); Point _90 = Point(-qrr[j].y, qrr[j].x); Point _180 = Point(-qrr[j].x, -qrr[j].y); while (q &lt; cnt &amp;&amp; (qrr[q + 1] ^ qrr[j]) == 0) ++q; while (s &lt; cnt &amp;&amp; (s &lt; q || ((qrr[s + 1] ^ _90) &gt; 0 &amp;&amp; (qrr[s + 1] ^ qrr[j]) &lt;= 0))) ++s; while (t &lt; cnt &amp;&amp; (t &lt; s || ((qrr[t + 1] ^ _180) &gt; 0 &amp;&amp; (qrr[t + 1] ^ _90) &lt;= 0))) ++t; res1 = (res1 + (sumy[s] - sumy[q] + mod) % mod * (qrr[j].x % mod) % mod - (sumx[s] - sumx[q] + mod) % mod * (qrr[j].y) % mod + mod) % mod; res2 = (res2 + (sumy[t] - sumy[s] + mod) % mod * (qrr[j].x % mod) % mod - (sumx[t] - sumx[s] + mod) % mod * (qrr[j].y) % mod + mod) % mod; &#125; &#125; return ((res1 - res2 * 2 % mod + mod) % mod * qpow(3, mod - 2) % mod) % mod;&#125;void RUN() &#123; int T; read(T); while (T--) &#123; read(n); for (int i = 1; i &lt;= n; ++i) &#123; read(p[i].x), read(p[i].y); &#125; ll res = gao(); printf(\"%lld\\n\", res); &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif// ios::sync_with_stdio(false);// cin.tie(nullptr), cout.tie(nullptr); RUN();#ifdef LOCAL_JUDGE// cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125;","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"https://hsueh37.gitee.io/blog/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"The Preliminary Contest for ICPC Asia Nanjing 2019","slug":"The-Preliminary-Contest-for-ICPC-Asia-Nanjing-2019","date":"2019-09-02T11:30:00.000Z","updated":"2020-04-28T09:02:42.272Z","comments":true,"path":"2019/09/02/The-Preliminary-Contest-for-ICPC-Asia-Nanjing-2019/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/09/02/The-Preliminary-Contest-for-ICPC-Asia-Nanjing-2019/","excerpt":"","text":"D. Robots题意：给定一个$DAG$，机器人每次等概率的选择一个点走或者停留，每次花费是当前天数，求$1\\rightarrow n$的花费期望 思路：$f_u$表示到$u$的期望，那么很显然$f_u = \\frac{f_u}{out_u + 1} + \\sum f_v + 1$，$g_u$表示花费期望，那么$g_u=\\frac{g_u}{out_u+1}+\\sum g_v + f_u$。看错题可还行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;#define endl \"\\n\"using ll = long long;using db = double;const int N = 1e5 + 10;int n, m;db f[N], g[N];int d1[N], d2[N], in[N], out[N];vector&lt;vector&lt;int&gt;&gt; G;void gao() &#123; queue&lt;int&gt; q; q.push(n); while (!q.empty()) &#123; int u = q.front(); q.pop(); if (out[u]) &#123; f[u] += out[u] + 1; f[u] /= out[u]; &#125; for (auto v: G[u]) &#123; f[v] += f[u]; --d1[v]; if (d1[v] == 0) &#123; q.push(v); &#125; &#125; &#125; q.push(n); while (!q.empty()) &#123; int u = q.front(); q.pop(); if (out[u]) &#123; g[u] += f[u] * (out[u] + 1); g[u] /= out[u]; &#125; for (auto v : G[u]) &#123; g[v] += g[u]; --d2[v]; if (d2[v] == 0) &#123; q.push(v); &#125; &#125; &#125;&#125;void RUN() &#123; int _T; scanf(\"%d\", &amp;_T); while (_T--) &#123; scanf(\"%d %d\", &amp;n, &amp;m); G.clear(); G.resize(n + 1); for (int i = 1; i &lt;= n; ++i) &#123; f[i] = 0.0; g[i] = 0.0; d1[i] = 0; d2[i] = 0; in[i] = 0; out[i] = 0; &#125; for (int i = 1, u, v; i &lt;= m; ++i) &#123; scanf(\"%d %d\", &amp;u, &amp;v); G[v].push_back(u); d1[u]++; d2[u]++; out[u]++, in[v]++; &#125; gao(); printf(\"%.2f\\n\", g[1]); &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125;","categories":[],"tags":[{"name":"online","slug":"online","permalink":"https://hsueh37.gitee.io/blog/tags/online/"}]},{"title":"Manthan, Codefest 19 (open for everyone, rated, Div. 1 + Div. 2)","slug":"Manthan,-Codefest-19-(open-for-everyone,-rated,-Div.-1-+-Div.-2)","date":"2019-08-26T01:30:00.000Z","updated":"2020-04-28T09:02:42.268Z","comments":true,"path":"2019/08/26/Manthan,-Codefest-19-(open-for-everyone,-rated,-Div.-1-+-Div.-2)/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/08/26/Manthan,-Codefest-19-(open-for-everyone,-rated,-Div.-1-+-Div.-2)/","excerpt":"","text":"A. XORinacci签到 B. Uniqueness题意：删除一个最短的子串，使得剩下的数字唯一出现 思路：枚举左端点，右边不断向左扩展。 C. Magic Grid题意：构造一个$n\\cdot n$的矩阵，里面填入$0-n^2-1$，使得每行每列异或和都相同。 思路：对于每个$4\\cdot 4$的矩阵都构造出 \\begin{matrix} 0 & 1 & 2 & 3 \\\\ 4 & 5 & 6 & 7 \\\\ 8 & 9 & 10 & 11\\\\ 12 & 13 & 14 & 15 \\end{matrix}D. Restore Permutation题意：给出一个序列，$a_i$ 的权值是满足$j&lt;i \\&amp; a_j&lt;a_i$的$a_j$和，现在给出权值，问原序列 思路：倒过来求，在权值线段树上二分 E. Let Them Slide题意：有$n$个滑块，滑块长度不同，每个滑块第$i$列有权值，单独求每列的和的最大值。 思路：$multiset$维护第$i$列可选取的滑块，维护即可。","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://hsueh37.gitee.io/blog/tags/ACM/"}]},{"title":"2019中国大学生程序设计竞赛（CCPC） - 网络选拔赛","slug":"2019中国大学生程序设计竞赛（CCPC）---网络选拔赛","date":"2019-08-23T14:40:00.000Z","updated":"2020-04-28T09:02:42.260Z","comments":true,"path":"2019/08/23/2019中国大学生程序设计竞赛（CCPC）---网络选拔赛/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/08/23/2019%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%EF%BC%88CCPC%EF%BC%89---%E7%BD%91%E7%BB%9C%E9%80%89%E6%8B%94%E8%B5%9B/","excerpt":"","text":"A.\\^\\&amp;\\^签到 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll A, B, C;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif int _T; scanf(\"%d\", &amp;_T); while (_T--) &#123; scanf(\"%lld%lld\", &amp;A, &amp;B); C = 0; for (int i = 32; i &gt;= 0; --i) &#123; if ((A &gt;&gt; i) % 2 &amp;&amp; (B &gt;&gt; i) % 2) C |= (1ll &lt;&lt; i); &#125; if (C == 0) &#123; for (int i = 0; i &lt;= 32; ++i) &#123; if (((A &gt;&gt; i) % 2) + ((B &gt;&gt; i) % 2) == 1) &#123; C |= (1ll &lt;&lt; i); break; &#125; &#125; &#125; printf(\"%lld\\n\", C); &#125; return 0;&#125; B. array权值线段树线段树维护每个数出现的下标，树上二分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;const int INF = 0x3f3f3f3f;int n, q, m, a[N], b[N];struct SEG &#123; int t[N &lt;&lt; 2]; void build(int id, int l, int r) &#123; if (l == r) &#123; t[id] = b[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); t[id] = max(t[id &lt;&lt; 1], t[id &lt;&lt; 1 | 1]); &#125; void update(int id, int l, int r, int pos) &#123; if (l == r) &#123; t[id] = INF; return; &#125; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) update(id &lt;&lt; 1, l, mid, pos); else update(id &lt;&lt; 1 | 1, mid + 1, r, pos); t[id] = max(t[id &lt;&lt; 1], t[id &lt;&lt; 1 | 1]); &#125; int ask(int id, int l, int r, int ql, int qr) &#123; if (l &gt;= ql &amp;&amp; r &lt;= qr) return t[id]; int mid = (l + r) &gt;&gt; 1; int res = 0; if (ql &lt;= mid) res = max(res, ask(id &lt;&lt; 1, l, mid, ql, qr)); if (qr &gt; mid) res = max(res, ask(id &lt;&lt; 1 | 1, mid + 1, r, ql, qr)); return res; &#125; int query(int id, int l, int r, int k, int R) &#123; if (l == r) return l; int mid = (l + r) &gt;&gt; 1; if (mid &lt; k || ask(id &lt;&lt; 1, l, mid, k, mid) &lt;= R) return query(id &lt;&lt; 1 | 1, mid + 1, r, k, R); if (t[id &lt;&lt; 1] &lt;= R) return query(id &lt;&lt; 1 | 1, mid + 1, r, k, R); else return query(id &lt;&lt; 1, l, mid, k, R); &#125;&#125;seg;int main() &#123; int _T; cin &gt;&gt; _T; while (_T--) &#123; scanf(\"%d%d\", &amp;n, &amp;q); m = n + 1; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), b[a[i]] = i; b[m] = INF; seg.build(1, 1, m); int lstans = 0; for (int _q = 1, op, x, k; _q &lt;= q; ++_q) &#123; scanf(\"%d%d\", &amp;op, &amp;x); x ^= lstans; if (op == 1) &#123; seg.update(1, 1, m, a[x]); &#125; else &#123; scanf(\"%d\", &amp;k); k ^= lstans; printf(\"%d\\n\", lstans = seg.query(1, 1, m, k, x)); &#125; &#125; &#125; return 0;&#125; C. K-th occurrence队友太强了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;const int M = 23;int n, q;char s[N];struct DA &#123; int t1[N], t2[N], c[N]; int sa[N]; int Rank[N]; int height[N]; int str[N]; int n, m; void init(char *s, int m, int n) &#123; this-&gt;m = m; this-&gt;n = n; for (int i = 0; i &lt; n; ++i) str[i] = s[i]; str[n] = 0; &#125; bool cmp(int *r, int a, int b, int l) &#123; return r[a] == r[b] &amp;&amp; r[a + l] == r[b + l]; &#125; void work() &#123; ++n; int i, j, p, *x = t1, *y = t2; for (i = 0; i &lt; m; ++i) c[i] = 0; for (i = 0; i &lt; n; ++i) c[x[i] = str[i]]++; for (i = 1; i &lt; m; ++i) c[i] += c[i - 1]; for (i = n - 1; i &gt;= 0; --i) sa[--c[x[i]]] = i; for (j = 1; j &lt;= n; j &lt;&lt;= 1) &#123; p = 0; //直接利用sa数组排序第二关键字 //后面的j个数第二关键字为空的最小 for (i = n - j; i &lt; n; ++i) &#123; y[p++] = i; &#125; for (i = 0; i &lt; n; ++i) if (sa[i] &gt;= j) y[p++] = sa[i] - j; //这样数组y保存的就是按照第二关键字排序的结果 //基数排序第一关键字 for (i = 0; i &lt; m; ++i) c[i] = 0; for (i = 0; i &lt; n; ++i) c[x[y[i]]]++; for (i = 1; i &lt; m; ++i) c[i] += c[i - 1]; for (i = n - 1; i &gt;= 0; --i) sa[--c[x[y[i]]]] = y[i]; //根据sa和x数组计算新的x数组 swap(x, y); p = 1; x[sa[0]] = 0; for (i = 1; i &lt; n; ++i) &#123; x[sa[i]] = cmp(y, sa[i - 1], sa[i], j) ? p - 1 : p++; &#125; if (p &gt;= n) break; //下次基数排序的最大值 m = p; &#125; int k = 0; --n; for (i = 0; i &lt;= n; ++i) Rank[sa[i]] = i; //build height for (i = 0; i &lt; n; ++i) &#123; if (k) --k; j = sa[Rank[i] - 1]; while (str[i + k] == str[j + k]) ++k; height[Rank[i]] = k; &#125; &#125; struct RMQ &#123; int Min[N][M]; int mm[N]; void init(int n, int *b) &#123; mm[0] = -1; for (int i = 1; i &lt;= n; ++i) &#123; mm[i] = ((i &amp; (i - 1)) == 0) ? mm[i - 1] + 1 : mm[i - 1]; Min[i][0] = b[i]; &#125; for (int j = 1; j &lt;= mm[n]; ++j) &#123; for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) &#123; Min[i][j] = min(Min[i][j - 1], Min[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125; &#125; int queryMin(int x, int y) &#123; int k = mm[y - x + 1]; return min(Min[x][k], Min[y - (1 &lt;&lt; k) + 1][k]); &#125; &#125;rmq; void initrmq() &#123; rmq.init(n, height); &#125; int lcp(int x, int y) &#123; if (x == y) return 1e9; if (x &gt; y) swap(x, y); ++x; return rmq.queryMin(x, y); &#125;&#125;da;int getl(int x, int len) &#123; int l = 1, r = x, res = x; while (r - l &gt;= 0) &#123; int mid = (l + r) &gt;&gt; 1; if (da.lcp(x, mid) &gt;= len) &#123; res = mid; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; return res;&#125;int getr(int x, int len) &#123; int l = x, r = n, res = x; while (r - l &gt;= 0) &#123; int mid = (l + r) &gt;&gt; 1; if (da.lcp(x, mid) &gt;= len) &#123; res = mid; l = mid + 1; &#125; else &#123; r = mid - 1; &#125; &#125; return res;&#125;struct SEG &#123; struct node &#123; int sum, ls, rs; node() &#123; ls = rs = sum = 0; &#125; &#125;t[N * 50]; int rt[N], cnt; void init() &#123; cnt = 0; memset(rt, 0, sizeof rt); &#125; void build(int &amp;id, int l, int r) &#123; id = ++cnt; t[id] = node(); if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(t[id].ls, l, mid); build(t[id].rs, mid + 1, r); &#125; void up(int id) &#123; int ls = t[id].ls, rs = t[id].rs; t[id].sum = 0; if (ls) t[id].sum += t[ls].sum; if (rs) t[id].sum += t[rs].sum; &#125; void update(int &amp;now, int pre, int l, int r, int pos) &#123; now = ++cnt; t[now] = t[pre]; if (l == r) &#123; ++t[now].sum; return; &#125; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) update(t[now].ls, t[pre].ls, l, mid, pos); else update(t[now].rs, t[pre].rs, mid + 1, r, pos); up(now); &#125; int query(int tl, int tr, int l, int r, int k) &#123; if (l == r) return l; int mid = (l + r) &gt;&gt; 1; int lsum = t[t[tr].ls].sum - t[t[tl].ls].sum; if (lsum &gt;= k) &#123; return query(t[tl].ls, t[tr].ls, l, mid, k); &#125; else &#123; return query(t[tl].rs, t[tr].rs, mid + 1, r, k - lsum); &#125; &#125;&#125;seg;int main() &#123; int _T; scanf(\"%d\", &amp;_T); while (_T--) &#123; scanf(\"%d%d\", &amp;n, &amp;q); scanf(\"%s\", s); da.init(s, 220, n); da.work(); da.initrmq(); seg.init(); seg.build(seg.rt[0], 1, n); for (int i = 1; i &lt;= n; ++i) seg.update(seg.rt[i], seg.rt[i - 1], 1, n, da.sa[i] + 1); for (int i = 1, x, l, r, k, len; i &lt;= q; ++i) &#123; scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k); len = r - l + 1; x = da.Rank[l - 1]; int L = getl(x, len); int R = getr(x, len); if (R - L + 1 &lt; k) puts(\"-1\"); else printf(\"%d\\n\", seg.query(seg.rt[L - 1], seg.rt[R], 1, n, k)); &#125; &#125; return 0;&#125; D. path维护一个大小为$MaxK$的$multiset$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 100010struct Edge &#123; int to, w; Edge() &#123;&#125; Edge(int to, int w) : to(to), w(w) &#123;&#125; bool operator&lt;(const Edge &amp;other) const &#123; return w &lt; other.w; &#125;&#125;;struct node &#123; int now; ll w; node() &#123;&#125; node(int now, ll w) : now(now), w(w) &#123;&#125; bool operator&lt;(const node &amp;other) const &#123; if (w == other.w) &#123; return now &lt; other.w; &#125; else &#123; return w &lt; other.w; &#125; &#125;&#125;;int n, m, q, MaxK;vector&lt;vector&lt;Edge&gt;&gt; G;int Q[N];ll res[N];multiset&lt;node&gt; s;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;q); G.clear(); G.resize(n + 1); s.clear(); for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); G[u].push_back(Edge(v, w)); &#125; MaxK = 0; for (int i = 1; i &lt;= q; ++i) &#123; scanf(\"%d\", Q + i); MaxK = max(MaxK, Q[i]); &#125; for (int i = 1; i &lt;= n; ++i) &#123; sort(G[i].begin(), G[i].end()); for (auto it : G[i]) &#123; if (s.empty()) &#123; s.insert(node(it.to, it.w)); continue; &#125; if (s.size() &gt;= MaxK + 1) &#123; auto item = s.end(); item--; if (it.w &gt;= (*item).w) &#123; break; &#125; else &#123; s.erase(item); s.insert(node(it.to, it.w)); &#125; &#125; else &#123; s.insert(node(it.to, it.w)); &#125; &#125; &#125; for (int i = 1; i &lt;= MaxK; ++i) &#123; res[i] = (*s.begin()).w; if (i == MaxK) break; int u = (*s.begin()).now; ll w = (*s.begin()).w; s.erase(s.begin()); for (auto it : G[u]) &#123; node now = node(it.to, w + it.w); if (s.empty()) &#123; s.insert(now); continue; &#125; if (s.size() &gt;= MaxK - i + 1) &#123; auto item = s.end(); item--; if (now.w &gt;= (*item).w) &#123; break; &#125; else &#123; s.erase(item); s.insert(now); &#125; &#125; else &#123; s.insert(now); &#125; &#125; &#125; for (int i = 1; i &lt;= q; ++i) &#123; printf(\"%lld\\n\", res[Q[i]]); &#125; &#125; return 0;&#125; E. huntian oy队友太强了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 2e6 + 10;const int M = 1e5 + 10;const ll mod = 1e9 + 7;int pri[N], check[N], phi[N], tot;ll f[N], F[N], inv2, inv6, n, a, b; void init() &#123; memset(check, 0, sizeof check); tot = 0; phi[1] = 1; for (int i = 2; i &lt; N; ++i) &#123; if (!check[i]) &#123; pri[++tot] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= tot; ++j) &#123; if (1ll * i * pri[j] &gt;= N) break; check[i * pri[j]] = 1; if (i % pri[j] == 0) &#123; phi[i * pri[j]] = phi[i] * pri[j]; break; &#125; else &#123; phi[i * pri[j]] = phi[i] * (pri[j] - 1); &#125; &#125; &#125; f[1] = 0; for (int i = 1; i &lt; N; ++i) &#123; f[i] = f[i - 1]; f[i] += 1ll * i * phi[i] % mod; f[i] %= mod; &#125;&#125;ll qpow(ll base, ll n) &#123; ll res = 1; while (n) &#123; if (n &amp; 1) res = res * base % mod; base = base * base % mod; n &gt;&gt;= 1; &#125; return res;&#125;ll sum_2(ll n) &#123; return n * (n + 1) % mod * (2 * n + 1) % mod * inv6 % mod;&#125;ll sum(ll n) &#123; return n * (n + 1) % mod * inv2 % mod;&#125;map &lt;int, int&gt; mp;bool vis[M]; ll S(ll x) &#123; if (x &lt; N) return f[x]; if (mp.find(x) != mp.end()) return mp[x]; ll res = sum_2(x); for (int i, j = 1; j &lt; x; ) &#123; i = j + 1; j = x / (x / i); res += mod - (sum(j) - sum(i - 1) + mod) % mod * S(x / i) % mod; res = res % mod; &#125; return mp[x] = res;&#125;int main() &#123; init(); inv2 = qpow(2, mod - 2); inv6 = qpow(6, mod - 2); mp.clear(); memset(vis, 0, sizeof vis); int _T; scanf(\"%d\", &amp;_T); while (_T--) &#123; scanf(\"%lld%lld%lld\", &amp;n, &amp;a, &amp;b); ll res = S(n); res = (res + mod - 1) % mod; res = res * inv2 % mod; printf(\"%lld\\n\", res); &#125; return 0;&#125; F. Shuffle Card签到 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 100010int n, m;int a[N], b[N], vis[N], res[N];int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif while (~scanf(\"%d %d\", &amp;n, &amp;m)) &#123; memset(vis, 0, sizeof vis); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); &#125; for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d\", b + i); &#125; int cnt = 0; for (int i = m; i &gt;= 1; --i) &#123; if (vis[b[i]]) &#123; continue; &#125; vis[b[i]] = 1; res[++cnt] = b[i]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (!vis[a[i]]) &#123; res[++cnt] = a[i]; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; printf(\"%d \", res[i]); &#125; &#125; return 0;&#125; G. Windows Of CCPC签到 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1100;int n, k;char s[N][N]; void gao(int x, int y, int k) &#123; if (k == 1) &#123; s[x][y] = 'C'; s[x][y + 1] = 'C'; s[x + 1][y] = 'P'; s[x + 1][y + 1] = 'C'; return; &#125; else &#123; int n = 1 &lt;&lt; (k - 1); gao(x, y, k - 1); gao(x, y + n, k - 1); gao(x + n, y, k - 1); gao(x + n, y + n, k - 1); for (int i = x + n; i &lt; x + 2 * n; ++i) &#123; for (int j = y; j &lt; y + n; ++j) &#123; if (s[i][j] == 'C') s[i][j] = 'P'; else s[i][j] = 'C'; &#125; &#125; &#125;&#125;int main() &#123; int _T; scanf(\"%d\", &amp;_T); while (_T--) &#123; int k; scanf(\"%d\", &amp;k); n = 1 &lt;&lt; k; gao(1, 1, k); for (int i = 1; i &lt;= n; ++i) &#123; s[i][n + 1] = 0; printf(\"%s\\n\", s[i] + 1); &#125; &#125; return 0;&#125; H. Fishing Master假设都在炖鱼的时候捕鱼，那么再补一条鱼的时间为$k-a[i]\\%k$，根据这个排序，保证正好$n$条鱼 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 100010int n, k;ll a[N];int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d %d\", &amp;n, &amp;k); ll cnt = 1, res = k; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%lld\", a + i); res += a[i]; cnt += a[i] / k; a[i] %= k; &#125; cnt -= n; cnt = -cnt; sort(a + 1, a + 1 + n); for (int i = n; i &gt;= 1 &amp;&amp; cnt &gt; 0; --i, --cnt) &#123; res += k - a[i]; &#125; printf(\"%lld\\n\", res); &#125; return 0;&#125; I. Kaguya题意：一个二分图，左边有有$n$个点，右边有$m$个点，两点连接概率为$\\frac{1}{2}$，其期望 思路：$dp[i][j][k][l]$表示$BFS$到第$i$层，左边用了$j$个点，右边用了$k$个点，当前层有$l$个点，那么如果当前层为左边，下一层为右边，$dp[i+1][j][k+o][o]=dp[i][j][k][l]*P, P=\\tbinom{m-k}{o}\\cdot \\frac{(2^l-1)^o}{2^{l\\cdot (m-k)}}$ 枚举转移 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 31;ll p;ll qpow(ll x, ll n) &#123; ll res = 1;; while (n) &#123; if (n &amp; 1)res = res * x % p; x = x * x % p; n &gt;&gt;= 1; &#125; return res;&#125;int n, m;int C[N][N];int pw2[N * N], pw3[N][N], INV[N * N];int f[N &lt;&lt; 1][N][N][N];void pre() &#123; C[0][0] = 1ll; for (int i = 1; i &lt; N; ++i) &#123; C[i][0] = 1ll; for (int j = 1; j &lt; N; ++j) &#123; C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % p; &#125; &#125; pw2[0] = 1; for (int i = 1; i &lt; N * N; ++i) &#123; pw2[i] = pw2[i - 1] * 2ll % p; &#125; for (int i = 1; i &lt; N; ++i) &#123; ll x = (pw2[i] + p - 1) % p; pw3[i][0] = 1; for (int j = 1; j &lt; N; ++j) &#123; pw3[i][j] = 1ll * pw3[i][j - 1] * x % p; &#125; &#125; for (int i = 1; i &lt; N * N; ++i) &#123; INV[i] = qpow(pw2[i], p - 2); &#125;&#125;void up(int &amp;x, int y) &#123; x += y; if (x &gt;= p) x -= p;&#125;void RUN() &#123; scanf(\"%d %d %lld\", &amp;n, &amp;m, &amp;p); pre(); memset(f, 0, sizeof f); f[0][1][0][1] = 1ll; ll res = 0; ll inv = qpow(m, p - 2); for (int i = 0; i &lt;= n + m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; for (int k = 0; k &lt;= m; ++k) &#123; if (i &amp; 1) &#123; for (int l = 1; l &lt;= k - (i / 2); ++l) &#123; if (f[i][j][k][l] == 0) continue; res = (res + 1ll * i * f[i][j][k][l] % p * inv % p * l % p) % p; for (int o = 1; o + j &lt;= n; ++o) &#123;//f[i + 1][j + o][k][o] += f[i][j][k][l] * P, P = C[n - j][o] * (2^l - 1)^o/2^l(n-j) up(f[i + 1][j + o][k][o], 1ll * f[i][j][k][l] * C[n - j][o] % p * pw3[l][o] % p * INV[l * (n - j)] % p); &#125; &#125; &#125; else &#123; for (int l = 1; l &lt;= j - (i / 2); ++l) &#123; if (f[i][j][k][l] == 0) continue; for (int o = 1; o + k &lt;= m; ++o) &#123;//f[i + 1][j][k + o][o] += f[i][j][k][l]*P, P = C[m - k][o]*(2^l-1)^o/2^l(m-k) up(f[i + 1][j][k + o][o], 1ll * f[i][j][k][l] * C[m - k][o] % p * pw3[l][o] % p * INV[l * (m - k)] % p); &#125; &#125; &#125; &#125; &#125; &#125; printf(\"%d\\n\", res);&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); int _T; scanf(\"%d\", &amp;_T); while (_T--) &#123; RUN(); &#125;#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125;","categories":[],"tags":[{"name":"online","slug":"online","permalink":"https://hsueh37.gitee.io/blog/tags/online/"}]},{"title":"动态规划","slug":"动态规划","date":"2019-08-22T01:40:00.000Z","updated":"2020-04-28T09:02:42.275Z","comments":true,"path":"2019/08/22/动态规划/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/08/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"前缀和优化P2511 [HAOI2008]木棍分割$f[i][j]=\\sum_{k=0}^{min(i-1.j)}f[i-1][j-k]$维护前缀和即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define N 1010const ll p = 10000;int n, k;ll f[N][N];void RUN() &#123; while (cin &gt;&gt; n &gt;&gt; k) &#123; f[1][0] = 1ll; for (int i = 2; i &lt;= n; ++i) &#123; ll sum = 0; for (int j = 0; j &lt;= k; ++j) &#123; sum = (sum + f[i - 1][j]) % p; f[i][j] = sum; if (j &gt;= i - 1) &#123; sum = (sum - f[i - 1][j - i + 1] + p) % p; &#125; &#125; &#125; cout &lt;&lt; f[n][k] &lt;&lt; \"\\n\"; &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125; 单调队列优化用于优化$f_i=min/max\\{g_j\\}+w_i$ 前置技能 单调队列单调队列性质 队列中的元素其对应在原来的列表中的顺序必须是单调递增的。 队列中元素的大小必须是单调递*(增/减/甚至是自定义也可以) P1886 滑动窗口12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;#define N 1000010struct node &#123; int v, id; node() &#123;&#125; node(int id, int v) : id(id), v(v) &#123;&#125; void input(int _id) &#123; id = _id; cin &gt;&gt; v; &#125;&#125; a[N], q[N];int n, k;void RUN() &#123; while (cin &gt;&gt; n &gt;&gt; k) &#123; for (int i = 1; i &lt;= n; ++i) &#123; a[i].input(i); &#125; int head = 1, tail = 0; for (int i = 1; i &lt;= n; ++i) &#123; while (head &lt;= tail &amp;&amp; q[tail].v &gt;= a[i].v) &#123; --tail; &#125; q[++tail] = a[i]; while (q[head].id &lt;= i - k) &#123; head++; &#125; if (i &gt;= k) &#123; cout &lt;&lt; q[head].v &lt;&lt; \" \\n\"[i == n]; &#125; &#125; head = 1, tail = 0; for (int i = 1; i &lt;= n; ++i) &#123; while (head &lt;= tail &amp;&amp; q[tail].v &lt;= a[i].v) &#123; --tail; &#125; q[++tail] = a[i]; while (q[head].id &lt;= i - k) &#123; head++; &#125; if (i &gt;= k) &#123; cout &lt;&lt; q[head].v &lt;&lt; \" \\n\"[i == n]; &#125; &#125; &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); RUN();#ifdef LOCAL_JUDGE cerr &lt;&lt; \"Time elapsed: \" &lt;&lt; 1.0 * clock() / CLOCKS_PER_SEC &lt;&lt; \" s.\\n\";#endif return 0;&#125;","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"https://hsueh37.gitee.io/blog/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"Multi-University-Training-Contest-8","slug":"Multi-University-Training-Contest-8","date":"2019-08-14T13:00:00.000Z","updated":"2020-04-28T09:02:42.270Z","comments":true,"path":"2019/08/14/Multi-University-Training-Contest-8/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/08/14/Multi-University-Training-Contest-8/","excerpt":"","text":"C. Acesrc and Good Numbers题意：$f(d, n)$表示$1\\cdots n$中有几个$d$，定义一个$good \\; number$为$f(d, k)=k$，现在给一个$x, d$问不超过$x$的最大$good \\; number$的$k$ 思路：很显然这种数不多，就可以快乐的打表了… F. Acesrc and Travel12 H. Andy and Maze题意：一张$n$个点，$m$条边的无向图，问经过$k$个点的最大代价。 思路：搜索…如果当前值加上剩下路径条数$\\times Max$依旧比$ans$小，则$return$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; pii;#define N 10010int n, m, k, ans, Max, vis[N];vector&lt;vector&lt;pii&gt;&gt; G;void DFS(int u, int cur, int v) &#123; if (cur == k) &#123; ans = max(ans, v); return; &#125; if (v + (k - cur) * Max &lt;= ans) &#123; return; &#125; for (auto it : G[u]) &#123; if (vis[it.first]) &#123; continue; &#125; vis[it.first] = 1; DFS(it.first, cur + 1, v + it.second); vis[it.first] = 0; &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k); G.clear(); G.resize(n + 1); for (int i = 1; i &lt;= n; ++i) &#123; vis[i] = 0; &#125; Max = -1; for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); G[u].emplace_back(v, w); G[v].emplace_back(u, w); Max = max(Max, w); &#125; ans = -1; for (int i = 1; i &lt;= n; ++i) &#123; vis[i] = 1; DFS(i, 1, 0); vis[i] = 0; &#125; if (ans == -1) &#123; puts(\"impossible\"); &#125; else &#123; printf(\"%d\\n\", ans); &#125; &#125; return 0;&#125; I. Calabash and Landlord题意：给定两个矩形，问将二维平面分成几部分 思路：$BFS$… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;bits/stdc++.h&gt;using namespace std;#define N 10#define INF 0x3f3f3f3fstruct node &#123; int l, t, r, b; int x[2], y[2]; void input() &#123; scanf(\"%d %d %d %d\", x, y, x + 1, y + 1); &#125; bool in(int _x, int _y) &#123; return x[0] &lt; _x &amp;&amp; _x &lt; x[1] &amp;&amp; y[0] &lt; _y &amp;&amp; _y &lt; y[1]; &#125;&#125; a[N * N];struct Hash &#123; int cnt, a[N]; void Init() &#123; cnt = 0; &#125; void add(int x) &#123; a[++cnt] = x; &#125; void work() &#123; sort(a + 1, a + 1 + cnt); cnt = unique(a + 1, a + 1 + cnt) - a - 1; &#125; int get(int x) &#123; return lower_bound(a + 1, a + 1 + cnt, x) - a; &#125;&#125; hx, hy;int vis[N][N];int dir[4][2] = &#123;1, 0, 0, 1, -1, 0,0, -1&#125;;bool check(int x, int y, int dx, int dy) &#123; if (x == dx) &#123; for (int i = 0; i &lt; 2; ++i) &#123; if ( x == a[i].x[0] || x == a[i].x[1]) &#123; if (a[i].y[0] &lt;= y &amp;&amp; dy &lt;= a[i].y[1]) &#123; return false; &#125; &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; 2; ++i) &#123; if (y == a[i].y[0] || y == a[i].y[1]) &#123; if (a[i].x[0] &lt;= x &amp;&amp; dx &lt;= a[i].x[1]) &#123; return false; &#125; &#125; &#125; &#125; return true;&#125;bool judge(int x, int y, int d) &#123; if (d == 0) &#123; return check(x + 1, y, x + 1, y + 1); &#125; else if (d == 1) &#123; return check(x, y + 1, x + 1, y + 1); &#125; else if (d == 2) &#123; return check(x, y, x, y + 1); &#125; else &#123; return check(x, y, x + 1, y); &#125;&#125;void DFS(int x, int y) &#123; vis[x][y] = 1; for (int i = 0; i &lt; 4; ++i) &#123; int dx = x + dir[i][0]; int dy = y + dir[i][1]; if (dx &gt;= 1 &amp;&amp; dx &lt; hx.cnt &amp;&amp; dy &gt;= 1 &amp;&amp; dy &lt; hy.cnt) &#123; if (!vis[dx][dy] &amp;&amp; judge(x, y, i)) &#123; DFS(dx, dy); &#125; &#125; &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif int T; scanf(\"%d\", &amp;T); while (T--) &#123; a[0].input(); a[1].input(); hx.Init(), hy.Init(); hx.add(-INF), hx.add(INF); hx.add(a[0].x[0]), hx.add(a[0].x[1]); hx.add(a[1].x[0]), hx.add(a[1].x[1]); hy.add(-INF), hy.add(INF); hy.add(a[0].y[0]), hy.add(a[0].y[1]); hy.add(a[1].y[0]), hy.add(a[1].y[1]); hx.work(), hy.work(); for (int i = 0; i &lt; 2; ++i) &#123; a[i].x[0] = hx.get(a[i].x[0]); a[i].x[1] = hx.get(a[i].x[1]); a[i].y[0] = hy.get(a[i].y[0]); a[i].y[1] = hy.get(a[i].y[1]); &#125; memset(vis, 0, sizeof vis); int res = 0; for (int i = 1; i &lt; hx.cnt; ++i) &#123; for (int j = 1; j &lt; hy.cnt; ++j) &#123; if (!vis[i][j]) &#123; DFS(i, j); res++; &#125; &#125; &#125; printf(\"%d\\n\", res); &#125; return 0;&#125; J.Quailty and CCPC签到 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int n, d;struct node &#123; char s[10]; int p, t; node() &#123;&#125; void scan() &#123; scanf(\"%s%d%d\", s, &amp;p, &amp;t); &#125; bool operator &lt; (const node &amp;other) const &#123; if (p != other.p) return p &gt; other.p; return t &lt; other.t; &#125;&#125;a[N];int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;d); for (int i = 1; i &lt;= n; ++i) &#123; a[i].scan(); &#125; sort(a + 1, a + 1 + n); if (n * d % 10 == 5) &#123; int t = n * d / 10 + 1; puts(a[t].s); &#125; else &#123; puts(\"Quailty is very great\"); &#125; &#125; return 0;&#125; K. Roundgod and Milk Tea题意：$n$个班，每个班有$a_i$个人，$b_i$个牛奶，每个班的人不能和自己班的牛奶，问最多有多少人喝到牛奶。 思路：枚举… 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 1e6 + 10;int n;ll a[N][2];int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); ll sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%lld%lld\", a[i], a[i] + 1); sum += a[i][1]; &#125; ll res = 0; for (int i = 1; i &lt;= n; ++i) &#123; ll now = sum - a[i][1]; if (res &gt; a[i][1]) &#123; now -= res - a[i][1]; &#125; res += min(now, a[i][0]); &#125; printf(\"%lld\\n\", res); &#125; return 0;&#125;","categories":[],"tags":[{"name":"HDU多校","slug":"HDU多校","permalink":"https://hsueh37.gitee.io/blog/tags/HDU%E5%A4%9A%E6%A0%A1/"}]},{"title":"Codeforces Round 579 (Div. 3)","slug":"Codeforces-Round-579-(Div.-3)","date":"2019-08-14T02:20:00.000Z","updated":"2020-04-28T09:02:42.264Z","comments":true,"path":"2019/08/14/Codeforces-Round-579-(Div.-3)/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/08/14/Codeforces-Round-579-(Div.-3)/","excerpt":"","text":"A.Circle of Students签到 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010int n;int a[N];bool solve() &#123; int p = -1; for (int i = 0; i &lt; n; ++i) &#123; if (a[i] == 1) &#123; p = i; break; &#125; &#125; int now = 1; for (int i = p, j = 0; j &lt; n; i = (i + 1) % n, ++j) &#123; if (a[i] == now) &#123; now++; &#125; else &#123; break; &#125; &#125; if (now == n + 1) &#123; return true; &#125; now = 1; for (int i = p, j = 0; j &lt; n; i = (i - 1 + n) % n, ++j) &#123; if (a[i] == now) &#123; now++; &#125; else &#123; break; &#125; &#125; return now == n + 1;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%d\", a + i); &#125; puts(solve() ? \"YES\" : \"NO\"); &#125; return 0;&#125; B.Equal Rectangles签到 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;#define N 500010typedef long long ll;int n;ll a[N];bool solve() &#123; int m = 4 * n; sort(a + 1, a + 1 + m); if (a[1] != a[2] || a[m] != a[m - 1]) &#123; return false; &#125; ll S = a[1] * a[m]; for (int i = 3, j = m - 2; i &lt;= 2 * n; i += 2, j -= 2) &#123; if (a[i] != a[i + 1] || a[j] != a[j - 1]) &#123; return false; &#125; if (a[i] * a[j] != S) &#123; return false; &#125; &#125; return true;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= 4 * n; ++i) &#123; scanf(\"%lld\", a + i); &#125; puts(solve() ? \"YES\" : \"NO\"); &#125;&#125; C.Common Divisors签到 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 400010int n;ll a[N];ll solve() &#123; ll res = a[1]; for (int i = 2; i &lt;= n; ++i) &#123; if (a[i] % res != 0) &#123; res = __gcd(res, a[i]); if (res == 1) &#123; return res; &#125; &#125; &#125; int tmp = 0; for (ll i = 1; i * i &lt;= res; ++i) &#123; if (res % i == 0) &#123; ++tmp; if (res / i != i) &#123; ++tmp; &#125; &#125; &#125; res = tmp; return res;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif while (~scanf(\"%d\", &amp;n)) &#123; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%lld\", a + i); &#125; printf(\"%lld\\n\", solve()); &#125; return 0;&#125; D1.Remove the Substring (easy version)题意：给定$s, t$串，删去$s$的一段区间，使得$t$是$s$的子序列，问最大的区间 思路：正着算一遍$t$每个位置在$s$中第一次满足的下标，倒着算一遍最后满足的下标，答案就是$t_i$和$t_{i+1}$的区间长度的$MAX$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;#define N 500010typedef long long ll;char s[N], t[N];int a[N], b[N];int solve() &#123; memset(a, 0, sizeof a); memset(b, 0, sizeof b); int len1 = strlen(s + 1), len2 = strlen(t + 1); int p = 1; for (int i = 1; i &lt;= len1; ++i) &#123; if (s[i] == t[p]) &#123; a[p] = i; ++p; &#125; &#125; p = len2; for (int i = len1; i &gt;= 1; --i) &#123; if (s[i] == t[p]) &#123; b[p] = i; --p; &#125; &#125; int res = 0; res = max(res, max(len1 - a[len2], b[1] - 1)); for (int i = 1; i &lt;= len2 - 1; ++i) &#123; res = max(res, b[i + 1] - a[i] - 1); &#125; return res;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif while (~scanf(\"%s\", s + 1)) &#123; scanf(\"%s\", t + 1); printf(\"%d\\n\", solve()); &#125;&#125; D2.Remove the Substring (hard version)题意：给定$s, t$串，删去$s$的一段区间，使得$t$是$s$的子序列，问最大的区间 思路：正着算一遍$t$每个位置在$s$中第一次满足的下标，倒着算一遍最后满足的下标，答案就是$t_i$和$t_{i+1}$的区间长度的$MAX$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;#define N 500010typedef long long ll;char s[N], t[N];int a[N], b[N];int solve() &#123; memset(a, 0, sizeof a); memset(b, 0, sizeof b); int len1 = strlen(s + 1), len2 = strlen(t + 1); int p = 1; for (int i = 1; i &lt;= len1; ++i) &#123; if (s[i] == t[p]) &#123; a[p] = i; ++p; &#125; &#125; p = len2; for (int i = len1; i &gt;= 1; --i) &#123; if (s[i] == t[p]) &#123; b[p] = i; --p; &#125; &#125; int res = 0; res = max(res, max(len1 - a[len2], b[1] - 1)); for (int i = 1; i &lt;= len2 - 1; ++i) &#123; res = max(res, b[i + 1] - a[i] - 1); &#125; return res;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif while (~scanf(\"%s\", s + 1)) &#123; scanf(\"%s\", t + 1); printf(\"%d\\n\", solve()); &#125;&#125; E.Boxers题意：每个数可以进行$+1,-1$以及不变，问变化后序列中拥有的不同元素个数 思路：对于每个数，优先$-1$再不变在$+1$即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;#define N 500010typedef long long ll;int n;int a[N];int cnt[N];int solve() &#123; memset(cnt, 0, sizeof cnt); sort(a + 1, a + 1 + n); int res = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (a[i] - 1 &gt;= 1 &amp;&amp; !cnt[a[i] - 1]) &#123; cnt[a[i] - 1] = 1; res++; &#125; else if (!cnt[a[i]]) &#123; cnt[a[i]] = 1; res++; &#125; else if (!cnt[a[i] + 1]) &#123; cnt[a[i] + 1] = 1; res++; &#125; &#125; return res;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif while (~scanf(\"%d\", &amp;n)) &#123; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); &#125; printf(\"%d\\n\", solve()); &#125;&#125; F1.Complete the Projects (easy version)题意：有$n$件事，每件事有$a, b$表示当你的$Rank$大于等于$a$的时候才能做，做完后$Rank$变化$b$，其中$Rank$不能为负，现在有一个初始$Rank$问能否做完所有事情。 思路：优先做$b$非负的事情，对于$b$为负的，按照$a+b$排序，模拟一边即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 110struct node &#123; ll a, b, vis; void input() &#123; scanf(\"%lld %lld\", &amp;a, &amp;b); vis = 0; &#125;&#125; a[N];int n, r;bool cmp1(node x, node y) &#123; return x.a &lt; y.a;&#125;bool cmp2(node x, node y) &#123; return x.a + x.b &gt; y.a + y.b;&#125;bool solve() &#123; int tr = r; sort(a + 1, a + 1 + n, cmp1); for (int i = 1; i &lt;= n; ++i) &#123; if (a[i].b &gt;= 0) &#123; if (a[i].a &lt;= tr) &#123; tr += a[i].b; a[i].vis = 1; &#125; &#125; &#125; sort(a + 1, a + 1 + n, cmp2); for (int i = 1; i &lt;= n; ++i) &#123; if (a[i].vis) continue; if (a[i].a &lt;= tr &amp;&amp; tr + a[i].b &gt;= 0) &#123; tr += a[i].b; a[i].vis = 1; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (!a[i].vis) &#123; return false; &#125; &#125; return true;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif while (~scanf(\"%d %d\", &amp;n, &amp;r)) &#123; for (int i = 1; i &lt;= n; ++i) &#123; a[i].input(); &#125; puts(solve() ? \"YES\" : \"NO\"); &#125; return 0;&#125; F2.Complete the Projects (hard version)题意：有$n$件事，每件事有$a, b$表示当你的$Rank$大于等于$a$的时候才能做，做完后$Rank$变化$b$，其中$Rank$不能为负，现在有一个初始$Rank$问能否做的最大数量。 思路：优先做$b$非负的事情，对于$b$为负的，按照$a+b$排序，进行$01$背包 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 110#define M 60010#define INF 0x3f3f3f3fstruct node &#123; ll a, b, vis; void input() &#123; scanf(\"%lld %lld\", &amp;a, &amp;b); vis = 0; &#125; bool operator&lt;(const node &amp;other) const &#123; return a &lt; other.a; &#125;&#125; a[N];bool cmp(node x, node y) &#123; return x.a + x.b &gt; y.a + y.b;&#125;int n, r;int dp[M];int solve() &#123; sort(a + 1, a + 1 + n); memset(dp, -INF, sizeof dp); int tr = r; int res = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (a[i].b &gt;= 0) &#123; if (a[i].a &lt;= tr) &#123; tr += a[i].b; a[i].vis = 1; res++; &#125; &#125; &#125; sort(a + 1, a + 1 + n, cmp); dp[tr] = res; int ans = res; for (int i = 1; i &lt;= n; ++i) &#123; if (a[i].b &gt;= 0) continue; for (int j = 0; j &lt;= tr; ++j) &#123; if (dp[j] == -INF) continue; if (a[i].a &lt;= j &amp;&amp; j + a[i].b &gt;= 0) &#123; int tmp = j + a[i].b; dp[tmp] = max(dp[tmp], dp[j] + 1); ans = max(ans, dp[tmp]); &#125; &#125; &#125; return ans;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif while (~scanf(\"%d %d\", &amp;n, &amp;r)) &#123; for (int i = 1; i &lt;= n; ++i) &#123; a[i].input(); &#125; printf(\"%d\\n\", solve()); &#125; return 0;&#125;","categories":[],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://hsueh37.gitee.io/blog/tags/Codeforces/"}]},{"title":"Codeforces Round 578 (Div. 2)","slug":"Codeforces-Round-578-(Div.-2)","date":"2019-08-14T01:50:00.000Z","updated":"2020-04-28T09:02:42.264Z","comments":true,"path":"2019/08/14/Codeforces-Round-578-(Div.-2)/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/08/14/Codeforces-Round-578-(Div.-2)/","excerpt":"","text":"A. Hotelier签到 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 100010int n;string s;int a[10];void solve() &#123; memset(a, 0, sizeof a); for (char i : s) &#123; if (i == 'L') &#123; for (int j = 0; j &lt; 10; ++j) &#123; if (!a[j]) &#123; a[j] = 1; break; &#125; &#125; &#125; else if (i == 'R') &#123; for (int j = 9; j &gt;= 0; --j) &#123; if (!a[j]) &#123; a[j] = 1; break; &#125; &#125; &#125; else &#123; a[i - '0'] = 0; &#125; &#125; for (int i = 0; i &lt; 10; ++i) &#123; cout &lt;&lt; a[i]; &#125; cout &lt;&lt; endl;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); while (cin &gt;&gt; n) &#123; cin &gt;&gt; s; solve(); &#125; return 0;&#125; B.Block Adventure题意：有$n$个房子，每个房子有一个高度$h_i$，从$i$跳到$i+1$的条件是$\\vert h_i-h_{i+1}\\vert\\leq k$ 同时刚开始有$m$个积木，可以选择使用或者拆房子。 问能否到达$n$ 签到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 100010int n, m, k;ll a[N];bool solve() &#123; for (int i = 1; i &lt; n; ++i) &#123; if (a[i] &lt; a[i + 1]) &#123; if (a[i + 1] - a[i] &gt; k) &#123; if (a[i + 1] - a[i] - k &gt; m) &#123; return false; &#125; else &#123; m -= a[i + 1] - a[i] - k; &#125; &#125; else &#123; m += min(k - (a[i + 1] - a[i]), a[i]); &#125; &#125; else &#123; m += a[i] - a[i + 1] + min(1ll * k, a[i + 1]); &#125; &#125; return true;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125; cout &lt;&lt; (solve() ? \"YES\\n\" : \"NO\\n\"); &#125; return 0;&#125; C. Round Corridor题意：有一个圆盘，外面分成$n$个扇形，里面$m$个扇形，问两个坐标能否到达对方。 思路：计算$gcd(n, m)$那么如果$x$在外面区域，那么它属于$\\frac{x-1}{\\frac{n}{gcd(n, m)}}$，在里面属于$\\frac{x-1}{\\frac{m}{gcd(n, m)}}$ 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 100010ll n, m, q, sx, sy, ex, ey;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; q) &#123; ll G = __gcd(m, n); n /= G, m /= G; while (q--) &#123; cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey; int res1 = 0, res2 = 0; if (sx == 1) &#123; res1 = (sy - 1) / n; &#125; else &#123; res1 = (sy - 1) / m; &#125; if (ex == 1) &#123; res2 = (ey - 1) / n; &#125; else &#123; res2 = (ey - 1) / m; &#125; cout &lt;&lt; (res1 == res2 ? \"YES\" : \"NO\") &lt;&lt; endl; &#125; &#125; return 0;&#125; D.White Lines题意：有一个$n\\cdot n$的矩形，里面有$W、B$，在只能染色一块$k\\cdot k$的正方形的时候，只有$W$的行和只有$W$的列的最大值。 思路：处理第$i$行的出现$B$的左端点$L$右端点$R$，当$R-L+1\\geq k$的时候，那么$k\\cdot k$正方形的左端点出现在$(max(1, i-k+1)， max（1， R - k + 1）), (i, L)$范围内才能将这一行染色。同样道理处理每一列，然后求二维矩阵前缀和 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 2010#define INF 0x3f3f3f3fint n, k;char s[N][N];int a[N][N];void add(int x1, int y1, int x2, int y2) &#123; a[x1][y1]++; a[x1][y2 + 1]--; a[x2 + 1][y1]--; a[x2 + 1][y2 + 1]++;&#125;int solve() &#123; memset(a, 0, sizeof a); for (int i = 1; i &lt;= n; ++i) &#123; int L = INF, R = -INF; for (int j = 1; j &lt;= n; ++j) &#123; if (s[i][j] == 'B') &#123; L = min(L, j); R = max(R, j); &#125; &#125; if (L != INF) &#123; if (R - L + 1 &lt;= k) &#123; add(max(1, i - k + 1), max(1, R - k + 1), i, L); &#125; &#125; else &#123; add(1, 1, n, n); &#125; &#125; for (int j = 1; j &lt;= n; ++j) &#123; int L = INF, R = -INF; for (int i = 1; i &lt;= n; ++i) &#123; if (s[i][j] == 'B') &#123; L = min(L, i); R = max(R, i); &#125; &#125; if (L != INF) &#123; if (R - L + 1 &lt;= k) &#123; add(max(1, R - k + 1), max(1, j - k + 1), L, j); &#125; &#125; else &#123; add(1, 1, n, n); &#125; &#125; int res = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; a[i][j] += a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1]; res = max(res, a[i][j]); &#125; &#125; return res;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); while (cin &gt;&gt; n &gt;&gt; k) &#123; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; (s[i] + 1); &#125; cout &lt;&lt; solve() &lt;&lt; endl; &#125; return 0;&#125; E.Compress Words题意：给出$n$个字符串拼接，选择前面的后缀和后面的前缀的最长部分去掉一个，求拼接后的字符串 思路：$KMP$模板题…失配位置就是我们需要求的拼接长度，注意每次只需要做前后字符串最短长度部分即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010int nxt[N];void get_next(string x) &#123; nxt[0] = nxt[1] = 0; for (int i = 1, len = x.size(); i &lt; len; ++i) &#123; int j = nxt[i]; while (j &amp;&amp; x[i] != x[j]) j = nxt[j]; nxt[i + 1] = (x[j] == x[i]) ? j + 1 : 0; &#125;&#125;int kmp(const string &amp;s, string p) &#123; get_next(p); int j = 0; for (char i : s) &#123; while (j &amp;&amp; p[j] != i) j = nxt[j]; if (p[j] == i) ++j; &#125; return j;&#125;int n;string ans, p, tmp;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); while (cin &gt;&gt; n) &#123; for (int i = 1; i &lt;= n; ++i) &#123; if (i == 1) &#123; cin &gt;&gt; ans; continue; &#125; cin &gt;&gt; p; int len = min(ans.size(), p.size()); tmp.clear(); for (int j = ans.size() - len, sze = ans.size(); j &lt; sze; ++j) &#123; tmp += ans[j]; &#125; len = kmp(tmp, p); for (int j = len, sze = p.size(); j &lt; sze; ++j) &#123; ans += p[j]; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; F. Graph Traveler题意：有$n$个点，每个点有一个$k, m$，一个人刚开始有一个权值$c$，如果他走到$x$点，那么他的$c$会变成$c+k_x$，他下一步走向$G[x][c\\% m_x]$，有$q$次查询，每次给出$x, c$，问有多少个点是不断经过的。 思路：注意到$m$取值只有$[1,10]$，那么一个点只有$2520(ps:lcm(1\\cdots 10))$种本质不同的$c$，记忆化即可… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 1010#define M 2560#define INF 0x3f3f3f3fconst int p = 2520;int n, m, k[N], q;vector&lt;vector&lt;int&gt; &gt; G;int f[N * M];int gao(int x, int y) &#123; int now = x * p + y; if (f[now] != -1) &#123; return f[now]; &#125; set&lt;int&gt; se; stack&lt;int&gt; st; se.insert(now); st.push(now); while (true) &#123; x = now / p, y = now % p; int ny = ((y + k[x]) % p + p) % p; int nx = G[x][ny % G[x].size()]; int nxt = nx * p + ny; if (f[nxt] != -1) &#123; while (!st.empty()) &#123; f[st.top()] = f[nxt]; st.pop(); &#125; return f[nxt]; &#125; if (se.find(nxt) != se.end()) &#123; set&lt;int&gt; tmp; while (true) &#123; int Top = st.top(); tmp.insert(Top / p); st.pop(); if (Top == nxt) &#123; break; &#125; &#125; for (auto it : se) &#123; f[it] = tmp.size(); &#125; return tmp.size(); &#125; now = nxt; st.push(now); se.insert(now); &#125; return 0;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); while (cin &gt;&gt; n) &#123; G.clear(); G.resize(n + 1); for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; k[i]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; m; G[i].resize(m); for (auto &amp;it : G[i]) &#123; cin &gt;&gt; it; &#125; &#125; memset(f, -1, sizeof f); cin &gt;&gt; q; while (q--) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; y = (y % p + p) % p; cout &lt;&lt; gao(x, y) &lt;&lt; \"\\n\"; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://hsueh37.gitee.io/blog/tags/Codeforces/"}]},{"title":"XIV Open Cup named after E.V. Pankratiev. GP of SPb","slug":"XIV-Open-Cup-named-after-E.V.-Pankratiev.-GP-of-SPb","date":"2019-08-13T08:20:00.000Z","updated":"2020-04-28T09:02:42.273Z","comments":true,"path":"2019/08/13/XIV-Open-Cup-named-after-E.V.-Pankratiev.-GP-of-SPb/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/08/13/XIV-Open-Cup-named-after-E.V.-Pankratiev.-GP-of-SPb/","excerpt":"","text":"A. Bracket Expression签到 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define N 110char s[N];int n, id[N], sta[N], top; ll gao(int l, int r) &#123; if (l == r + 1) return 1; if (l + 1 == r) return 2; ll res = 1; for (int i = l; i &lt;= r; ) &#123; res *= 1ll + gao(i + 1, id[i] - 1); i = id[i] + 1; &#125; return res;&#125;int main() &#123; freopen(\"bracket-expression.in\", \"r\", stdin); freopen(\"bracket-expression.out\", \"w\", stdout); while (gets(s + 1)) &#123; top = 0; n = strlen(s + 1); if (n == 0) &#123; puts(\"1\"); continue; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (s[i] == '(') &#123; sta[++top] = i; &#125; else &#123; assert(top); int T = sta[top]; id[T] = i; id[i] = T; --top; &#125; &#125; printf(\"%lld\\n\", gao(1, n)); &#125; return 0;&#125; B. Checkers题意：有$n$台游戏机，每台游戏机有游玩历史，$Alice$从$1−n$循环去玩每个游戏机，每个游戏机可以玩$1$到$2$次。定义了一条规则判断$Alice$当前跟这个游戏机所玩的是$W$还是$B$。规则就是拿$Alice$的游戏历史跟机器的游戏历史向上比对，如果找到一条不同的，当前玩的局面就和那次交换。如果没有找到，$Alice$就可以玩$W$$Alice$想要尽可能多的玩$W$，最多能玩几次？ 思路：爆搜每种状态，复杂度$O(2^n\\cdot k)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;#define N 30int n, k;string s[N];int ans;//B 1 W 0int judge(string engin, vector&lt;int&gt; res) &#123; for (int i = engin.size() - 1, j = res.size() - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) &#123; if (engin[i] == 'B' &amp;&amp; res[j] == 0) &#123; return 1; &#125; if (engin[i] == 'W' &amp;&amp; res[j] == 1) &#123; return 0; &#125; &#125; return 0;&#125;void DFS(int cur, int pos, int cnt, vector&lt;int&gt; res) &#123; if (cur &gt;= k) &#123; ans = max(ans, cnt); return ; &#125; for (int i = 1; i + cur &lt;= k &amp;&amp; i &lt;= 2; ++i) &#123; string tmp = s[pos]; vector&lt;int&gt; temp = res; int tmpcnt = cnt; for (int j = 1; j &lt;= i; ++j) &#123; int nxt = judge(s[pos], temp); temp.push_back(nxt); s[pos].push_back(nxt ? 'W' : 'B'); if (nxt == 0) &#123; tmpcnt++; &#125; &#125; DFS(cur + i, pos % n + 1, tmpcnt, temp); s[pos] = tmp; &#125;&#125;int main() &#123; freopen(\"checkers.in\", \"r\", stdin); freopen(\"checkers.out\", \"w\", stdout); ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); while (cin &gt;&gt; n &gt;&gt; k) &#123; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; s[i]; &#125; ans = 0; vector&lt;int&gt; res; DFS(0, 1, 0, res); cout &lt;&lt; ans &lt;&lt;\"\\n\"; &#125; return 0;&#125; E. Four Prime Numbers题意：给出一个数，为它能被分解四个素数的方案数 思路：$f[i]$表示用两个素数拼出$i$的方案数，答案为$\\sum_{i=0}^{n}f[i]\\cdot f[n-i]$ 复杂度为$O(\\frac{n ^ 2}{log_2^2n})$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 1e5 + 10;int pri[N], check[N], ptot;void init() &#123; memset(check, 0, sizeof check); ptot = 0; for (int i = 2; i &lt; N; ++i) &#123; if (!check[i]) &#123; pri[++ptot] = i; &#125; for (int j = 1; j &lt;= ptot; ++j) &#123; if (1ll * i * pri[j] &gt;= N) break; check[i * pri[j]] = 1; if (i % pri[j] == 0) &#123; break; &#125; &#125; &#125;&#125;int n;ll f[N];int main() &#123; freopen(\"fourprimes.in\", \"r\", stdin); freopen(\"fourprimes.out\", \"w\", stdout); init(); while (scanf(\"%d\", &amp;n) != EOF) &#123; memset(f, 0, sizeof f); for (int i = 1; i &lt;= ptot; ++i) &#123; if (pri[i] + pri[i] &lt;= n) &#123; f[pri[i] + pri[i]] += 1; &#125; for (int j = 1; j &lt; i &amp;&amp; pri[i] + pri[j] &lt;= n; ++j) &#123; f[pri[i] + pri[j]] += 2; &#125; &#125; ll res = 0; for (int i = 1; i &lt;= n; ++i) &#123; res += f[i] * f[n - i]; &#125; printf(\"%lld\\n\", res); &#125; return 0;&#125; F. Set Intersection打表 12345678910111213141516#include &lt;bits/stdc++.h&gt;using namespace std;int n, l, m;int main() &#123; freopen(\"intset.in\", \"r\", stdin); freopen(\"intset.out\", \"w\", stdout); while (scanf(\"%d %d %d\", &amp;n, &amp;l, &amp;m) != EOF) &#123; int k = round(1.0 * l * m / n); printf(\"%d\\n\", k); &#125; return 0;&#125; G. Medals题意：有$n$个运动员，每个运动员只能参加一个项目，一个项目只能由一个运动员参加。现在知道哪些运动员去参加哪些项目可以获得什么类型的奖牌。现在要求给出一种方案，要求保证第一种类型的奖牌数量最多的情况下再保证第二种类型的奖牌数量最多，以此类推 思路：将第$i$种奖牌权值赋为$1001^{10-i}$ 跑费用流。 为了保证费用最大，因此每次只有在$dis[T]&lt;0$的时候才能增广 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;bits/stdc++.h&gt;using namespace std;typedef __int128 ll;const int MAXN = 10000;const int MAXM = 1000000;struct Edge&#123; int to, nxt, cap; ll cost; Edge() &#123;&#125; Edge (int _to, int _nxt, int _cap, ll _cost) &#123; to = _to; nxt = _nxt; cap = _cap; cost = _cost; &#125;&#125; edge[MAXM &lt;&lt; 1];int n;int head[MAXN], tot;int pre[MAXN], pe[MAXN];ll dis[MAXN];bool vis[MAXN];int num[MAXN];ll prize[MAXN];ll INF = 1LL &lt;&lt; 60;void out(ll x) &#123; if (x) &#123; out(x / 10); printf(\"%d\", (int)(x % 10)); &#125;&#125;void Init() &#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u,int v, int cap, ll cost) &#123; edge[tot] = Edge(v, head[u], cap, cost); head[u] = tot++; edge[tot] = Edge(u, head[v], 0, -cost); head[v] = tot++;&#125;bool SPFA(int S, int T) &#123; queue&lt;int&gt; q; for (int i = 0; i &lt;= T; ++i) &#123; dis[i] = INF; pre[i] = -1; vis[i] = false; &#125; dis[S] = 0; vis[S] = true; q.push(S); while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to; if (edge[i].cap &amp;&amp; dis[v] &gt; dis[u] + edge[i].cost) &#123; dis[v] = dis[u] + edge[i].cost; pre[v] = u; pe[v] = i; if (!vis[v]) &#123; vis[v] = true; q.push(v); &#125; &#125; &#125; &#125; return dis[T] &lt; 0;&#125;void solve(int S, int T) &#123; ll cost = 0; while (SPFA(S, T)) &#123; cost -= dis[T]; for (int i = T; i != S; i = pre[i]) &#123; edge[pe[i]].cap--; edge[pe[i] ^ 1].cap++; &#125; &#125; for (int i = 10; i &gt;= 1; --i) &#123; num[i] = cost % 1001; cost /= 1001; &#125; for (int i = 1; i &lt;= 10; ++i) &#123; printf(\"%d%c\", num[i], \" \\n\"[i == 10]); &#125; for (int i = 1; i &lt;= n; ++i) &#123; int res = 0; for (int j = head[i]; ~j; j = edge[j].nxt) &#123; if (edge[j].to != S &amp;&amp; (!edge[j].cap)) &#123; res = edge[j].to - n; break; &#125; &#125; printf(\"%d%c\", res, \" \\n\"[i == n]); &#125;&#125;int main() &#123; freopen(\"medals.in\", \"r\", stdin); freopen(\"medals.out\", \"w\", stdout); INF = INF * INF; prize[0] = 1ll; for (int i = 1; i &lt;= 11; ++i) &#123; prize[i] = prize[i - 1] * 1001; &#125; while (scanf(\"%d\", &amp;n) != EOF) &#123; Init(); for (int i = 1, k, a, b; i &lt;= n; ++i) &#123; scanf(\"%d\", &amp;k); for (int j = 1; j &lt;= k; ++j) &#123; scanf(\"%d %d\", &amp;a, &amp;b); addedge(i, a + n, 1, -prize[10 - b]); &#125; &#125; int S = 0, T = n + 1001; for (int i = 1; i &lt;= n; ++i) &#123; addedge(S, i, 1, 0); &#125; for (int i = n + 1; i &lt; T; ++i) &#123; addedge(i, T, 1, 0); &#125; solve(S, T); &#125; return 0;&#125; H. Reachability题意：给出一张$n$个点的图，每次操作增加或删去边，输出可达矩阵的值。 思路：$bitsset$优化跑闭包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;#define N 510#define uint unsigned intint n, q;uint A[N], B[N];bitset &lt;N&gt; G[N], H[N];uint gao() &#123; for (int i = 1; i &lt;= n; ++i) &#123; H[i] = G[i]; &#125; for (int k = 1; k &lt;= n; ++k) &#123; for (int i = 1; i &lt;= n; ++i) &#123; if (H[i][k]) &#123; H[i] |= H[k]; &#125; &#125; &#125; uint res = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (i != j &amp;&amp; H[i][j]) &#123; res += A[i - 1] * B[j - 1]; &#125; &#125; &#125; return res;&#125;int main() &#123; freopen(\"reachability.in\", \"r\", stdin); freopen(\"reachability.out\", \"w\", stdout); A[0] = B[0] = 1; scanf(\"%d%d%u%u\", &amp;n, &amp;q, A + 1, B + 1); for (int i = 1; i &lt;= n; ++i) &#123; A[i] = A[i - 1] * A[1]; B[i] = B[i - 1] * B[1]; &#125; for (int i = 1; i &lt;= n; ++i) G[i].reset(); char op1[5], op2[5]; int v, a[N]; for (int _q = 1; _q &lt;= q; ++_q) &#123; scanf(\"%s%s%d%d\", op1, op2, &amp;v, a); for (int i = 1; i &lt;= a[0]; ++i) &#123; scanf(\"%d\", a + i); if (op2[0] == 'o') &#123; G[v][a[i]] = G[v][a[i]] ^ 1; &#125; else &#123; G[a[i]][v] = G[a[i]][v] ^ 1; &#125; &#125; printf(\"%u\\n\", gao()); &#125; return 0;&#125; J. Snakes on the Stone题意：有若干条蛇躺在平面上，要求蛇与蛇之间不打结，每个点最多有两条蛇在那里交叉，问如果安排交叉点哪条蛇在上，哪条蛇在下使得所有蛇不交叉。 思路：感性理解一下，第一次经过交叉点向下，第二次向上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;#define pii pair &lt;int, int&gt;#define fi first#define se secondconst int N = 100;vector &lt;vector&lt;pii&gt;&gt; vec;int n, cnt[N][N], vis[N][N];int main() &#123; freopen(\"snakes2.in\", \"r\", stdin); freopen(\"snakes2.out\", \"w\", stdout); ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); while (cin &gt;&gt; n) &#123; vec.clear(); vec.resize(n + 1); memset(cnt, 0, sizeof cnt); memset(vis, 0, sizeof vis); for (int i = 1, m; i &lt;= n; ++i) &#123; cin &gt;&gt; m; vec[i].resize(m); for (auto &amp;it : vec[i]) &#123; cin &gt;&gt; it.fi &gt;&gt; it.se; ++cnt[it.fi][it.se]; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (auto it : vec[i]) &#123; if (cnt[it.fi][it.se] &gt;= 2) &#123; cout &lt;&lt; (vis[it.fi][it.se] ? \"+\" : \"-\"); ++vis[it.fi][it.se]; &#125; &#125; cout &lt;&lt; \"\\n\"; &#125; &#125; return 0;&#125;#include &lt;bits/stdc++.h&gt;using namespace std;#define pii pair &lt;int, int&gt;#define fi first#define se secondconst int N = 100;vector &lt;vector&lt;pii&gt;&gt; vec;int n, cnt[N][N], vis[N][N];int main() &#123; freopen(\"snakes2.in\", \"r\", stdin); freopen(\"snakes2.out\", \"w\", stdout); ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); while (cin &gt;&gt; n) &#123; vec.clear(); vec.resize(n + 1); memset(cnt, 0, sizeof cnt); memset(vis, 0, sizeof vis); for (int i = 1, m; i &lt;= n; ++i) &#123; cin &gt;&gt; m; vec[i].resize(m); for (auto &amp;it : vec[i]) &#123; cin &gt;&gt; it.fi &gt;&gt; it.se; ++cnt[it.fi][it.se]; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (auto it : vec[i]) &#123; if (cnt[it.fi][it.se] &gt;= 2) &#123; cout &lt;&lt; (vis[it.fi][it.se] ? \"+\" : \"-\"); ++vis[it.fi][it.se]; &#125; &#125; cout &lt;&lt; \"\\n\"; &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://hsueh37.gitee.io/blog/tags/ACM/"}]},{"title":"2011-2012 Summer Petrozavodsk Camp, Warsaw U Contest, 2011-09-11","slug":"2011-2012-Summer-Petrozavodsk-Camp,-Warsaw-U-Contest,-2011-09-11","date":"2019-08-12T12:20:00.000Z","updated":"2020-04-28T09:02:42.258Z","comments":true,"path":"2019/08/12/2011-2012-Summer-Petrozavodsk-Camp,-Warsaw-U-Contest,-2011-09-11/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/08/12/2011-2012-Summer-Petrozavodsk-Camp,-Warsaw-U-Contest,-2011-09-11/","excerpt":"","text":"A.Chocolate题意：给定一个$n\\cdot m$的巧克力，上面有个标记的$cell$每次选择一个水平线或者竖直线，沿线切开，如果迟到标记的点则输，问先手输的方案数 思路：显然是一个$Nim$游戏，即求$\\sum_{i=0}^{n - 1}\\sum_{j=1}^{m-1}i\\oplus (n-1-i)\\oplus j \\oplus(m-1-j)$ 打表 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;map&lt;pii, ll&gt; mp;ll gao(ll n, ll m) &#123; if (mp.find(pii(n, m)) != mp.end()) return mp[pii(n, m)]; if (n == 1 || m == 1) &#123; if (n % 2 != m % 2) &#123; mp[pii(n, m)] = 0; &#125; else &#123; mp[pii(n, m)] = 1; &#125; &#125; else if (n % 2 != m % 2) &#123; mp[pii(n, m)] = 0ll; &#125; else if (n == 1 &amp;&amp; m == 1) &#123; mp[pii(n, m)] = 1ll; &#125; else if (n % 2 == 0) &#123; mp[pii(n, m)] = 4ll * gao(n / 2, m / 2); &#125; else &#123; mp[pii(n, m)] = 1ll * gao(n / 2, m / 2) + 1ll * gao(n / 2 + 1, m / 2 + 1) + gao(n / 2 + 1, m / 2) + gao(n / 2, m / 2 + 1); &#125; return mp[pii(n, m)];&#125;ll n, m;int main() &#123; freopen(\"chocolate.in\", \"r\", stdin); freopen(\"chocolate.out\", \"w\", stdout); int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%lld %lld\", &amp;n, &amp;m); printf(\"%lld\\n\", gao(n, m)); &#125; return 0;&#125; B. Programming Contest题意：有$n$个人，$m$道题，每个人有自己能做的题以及做出一道题时间为$r$，比赛持续时间为$t$，求一个方案使得题目最多，罚时最少。 思路：考虑匈牙利不会导致之前匹配的点失配，那么直接做匈牙利，每次减少一道题或者一个人不能在做题，最多做$1000$次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;#define N 510vector&lt;vector&lt;int&gt; &gt; G;int linker[N];bool used[N];int uN;bool DFS(int u) &#123; for (auto v : G[u]) &#123; if (!used[v]) &#123; used[v] = true; if (linker[v] == -1 || DFS(linker[v])) &#123; linker[v] = u; return true; &#125; &#125; &#125; return false;&#125;int n, m, r, t, k;int Time[N];int main() &#123; freopen(\"contest.in\", \"r\", stdin); freopen(\"contest.out\", \"w\", stdout); while (scanf(\"%d %d %d %d %d\", &amp;n, &amp;m, &amp;r, &amp;t, &amp;k) != EOF) &#123; G.clear(); G.resize(n + 1); memset(linker, -1, sizeof linker); memset(Time, 0, sizeof Time); for (int i = 1, a, b; i &lt;= k; ++i) &#123; scanf(\"%d %d\", &amp;a, &amp;b); G[a].push_back(b); &#125; int ans1 = 0, ans2 = 0; for (int i = 1; i * r &lt;= t; ++i) &#123; bool F = 0; for (int u = 1; u &lt;= n; ++u) &#123; memset(used, false, sizeof used); if (DFS(u)) &#123; F = 1; ans1++; ans2 += i; &#125; &#125; if (!F) &#123; break; &#125; &#125; printf(\"%d %d\\n\", ans1, ans2 * r); for (int i = 1; i &lt;= m; ++i) &#123; if (linker[i] == -1) continue; int u = linker[i]; printf(\"%d %d %d\\n\", u, i, Time[u]); Time[u] += r; &#125; &#125; return 0;&#125; D. Evacuation题意：有$n$个点，$m$条有向边，$q$次操作，每次删除一个点或者查询$1$到$p$ 的距离 思路： 考虑倒过来就是加边，每次只会修改一个点，将这个点暴力$BFS$，每个点最多修改$n$次，复杂度为$O(n^2)$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1010#define M 200010const int INF = 0x3f3f3f3f;int e[M][3], res[M];vector &lt;vector&lt;int&gt;&gt; G;struct qnode &#123; //0加边 1 询问 int op, p; qnode() &#123;&#125; qnode(int op, int p) : op(op), p(p) &#123;&#125;&#125;que[M];int n, m, q;int dis[N];void BFS(int u) &#123; queue &lt;int&gt; qu; qu.push(u); while (!qu.empty()) &#123; u = qu.front(); qu.pop(); for (auto v : G[u]) &#123; if (dis[u] + 1 &lt; dis[v]) &#123; dis[v] = dis[u] + 1; qu.push(v); &#125; &#125; &#125;&#125;int main() &#123; freopen(\"evacuation.in\", \"r\", stdin); freopen(\"evacuation.out\", \"w\", stdout); while (scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;q) != EOF) &#123; G.clear(); G.resize(n + 1); memset(dis, 0x3f, sizeof dis); dis[1] = 0; for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d%d\", &amp;e[i][0], &amp;e[i][1]); e[i][2] = 0; &#125; for (int i = 1; i &lt;= q; ++i) &#123; char op[10]; int p; scanf(\"%s %d\", op, &amp;p); que[i] = qnode(op[0] == 'U' ? 0 : 1, p); if (op[0] == 'U') &#123; e[p][2] = 1; &#125; &#125; for (int i = 1; i &lt;= m; ++i) if (e[i][2] == 0) &#123; G[e[i][0]].push_back(e[i][1]); // G[e[i][1]].push_back(e[i][0]); &#125; BFS(1); for (int i = q; i &gt;= 1; --i) &#123; if (que[i].op == 0) &#123; int x = e[que[i].p][0], y = e[que[i].p][1]; G[x].push_back(y); if (dis[x] + 1 &lt; dis[y]) &#123; dis[y] = dis[x] + 1; BFS(y); &#125; &#125; else &#123; res[i] = dis[que[i].p]; &#125; &#125; for (int i = 1; i &lt;= q; ++i) &#123; if (que[i].op == 1) &#123; printf(\"%d\\n\", res[i] &gt;= INF ? -1 : res[i]); &#125; &#125; &#125; return 0;&#125; E. Inspection题意：有$n$个点的树 选定一个点$S$ 从$S$出发访问每个节点，访问完回到$S$，一次的访问时间为路径长度，最后一次访问可以补回来 连续的两次不能走同一条路 输出最小时间 思路：经典树形$dp$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define pii pair &lt;int, int&gt;#define fi first#define se secondconst int N = 1e6 + 10;int n;vector &lt;vector&lt;int&gt;&gt; G;ll f[N], g[N], res[N];pii mf[N][2];int sze[N], fa[N], mg[N]; void DFS(int u) &#123; sze[u] = 1; f[u] = 0; mf[u][0] = pii(0, u); mf[u][1] = pii(-1, -1); for (auto v : G[u]) if (v != fa[u]) &#123; fa[v] = u; DFS(v); sze[u] += sze[v]; f[u] += f[v] + sze[v]; if (mf[v][0].fi + 1 &gt; mf[u][0].fi) &#123; mf[u][1] = mf[u][0]; mf[u][0] = mf[v][0]; ++mf[u][0].fi; mf[u][0].se = v; &#125; else if (mf[v][0].fi + 1 &gt; mf[u][1].fi) &#123; mf[u][1] = mf[v][0]; ++mf[u][1].fi; mf[u][1].se = v; &#125; &#125;&#125;void DFS2(int u) &#123; for (auto v : G[u]) if (v != fa[u]) &#123; g[v] = 0; g[v] += n - sze[v]; g[v] += g[u]; g[v] += f[u] - sze[v] - f[v]; mg[v] = mg[u] + 1; if (mf[u][0].se == v) &#123; mg[v] = max(mg[v], mf[u][1].fi + 1); &#125; else &#123; mg[v] = max(mg[v], mf[u][0].fi + 1); &#125; DFS2(v); &#125;&#125;int main() &#123; freopen(\"inspection.in\", \"r\", stdin); freopen(\"inspection.out\", \"w\", stdout); while (scanf(\"%d\", &amp;n) != EOF) &#123; G.clear(); G.resize(n + 1); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d%d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; g[1] = 0; mg[1] = 0; DFS(1); DFS2(1); for (int u = 1; u &lt;= n; ++u) &#123; int Max = 0, num; for (auto v : G[u]) if (v != fa[u]) &#123; if (sze[v] &gt; Max) &#123; Max = sze[v]; num = mf[v][0].fi + 1; &#125; &#125; if (n - sze[u] &gt; Max) &#123; Max = max(Max, n - sze[u]); num = mg[u]; &#125; if (Max &gt; n - 1 - Max + 1) &#123; res[u] = -1; &#125; else &#123; res[u] = 2ll * (f[u] + g[u]); if (Max == n - 1 - Max + 1) &#123; res[u] -= num; &#125; else &#123; res[u] -= max(mf[u][0].fi, mg[u]); &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) printf(\"%lld\\n\", res[i]); &#125; return 0;&#125; F. Meteors题意：有$n$个城市，$m$个地点，每个地点属于一个城市，接下来有$q$次操作，每次操作是的$[L,R]$区间内的点下$a_i$雨，每个城市有一个目标降雨量$p_i$，为最早到达目标的操作次数 思路：经典整体二分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longconst int N = 3e5 + 10;int n, m, q, res[N];ll tar[N];struct tnode &#123; int l, r; ll a; tnode() &#123;&#125; tnode(int l, int r, ll a) : l(l), r(r), a(a) &#123;&#125; void scan() &#123; scanf(\"%d%d%lld\", &amp;l, &amp;r, &amp;a); &#125;&#125;arr[N];struct qnode &#123; int id; ll v; qnode() &#123;&#125; qnode(int id, ll v) : id(id), v(v) &#123;&#125;&#125;que[N], ql[N], qr[N]; vector &lt;vector&lt;int&gt;&gt; vec;struct BIT &#123; ll a[N]; void init() &#123; memset(a, 0, sizeof a); &#125; void update(int x, ll v) &#123; for (; x &lt; N; x += x &amp; -x) &#123; a[x] += v; &#125; &#125; ll query(int x) &#123; ll res = 0; for (; x &gt; 0; x -= x &amp; -x) &#123; res += a[x]; &#125; return res; &#125; void update(int l, int r, ll v) &#123; if (l &gt; r) &#123; update(l, v); update(m + 1, -v); update(1, v); update(r + 1, -v); &#125; else &#123; update(l, v); update(r + 1, -v); &#125; &#125;&#125;bit; void gao(int L, int R, int l, int r) &#123; if (L &gt; R) return;// cout &lt;&lt; L &lt;&lt; \" \" &lt;&lt; R &lt;&lt; \" \" &lt;&lt; l &lt;&lt; \" \" &lt;&lt; r &lt;&lt; endl; if (l == r) &#123; // cout &lt;&lt; l &lt;&lt; endl; for (int i = L; i &lt;= R; ++i) &#123; res[que[i].id] = l; &#125; return; &#125; int mid = (l + r) &gt;&gt; 1; for (int i = l; i &lt;= mid; ++i) &#123; bit.update(arr[i].l, arr[i].r, arr[i].a); &#125; int posl = 0, posr = 0; for (int i = L; i &lt;= R; ++i) &#123; ll tot = 0; for (auto it : vec[que[i].id]) &#123; tot += bit.query(it); if (tot &gt; que[i].v) break; &#125; // cout &lt;&lt; que[i].id &lt;&lt; \" \" &lt;&lt; tot &lt;&lt; endl; if (tot &lt; que[i].v) &#123; que[i].v -= tot; qr[++posr] = que[i]; &#125; else &#123; ql[++posl] = que[i]; &#125; &#125; for (int i = 1; i &lt;= posl; ++i) que[L + i - 1] = ql[i]; for (int i = 1; i &lt;= posr; ++i) que[L + posl + i - 1] = qr[i]; for (int i = l; i &lt;= mid; ++i) bit.update(arr[i].l, arr[i].r, -arr[i].a); gao(L, L + posl - 1, l, mid); gao(L + posl, R, mid + 1, r);&#125;void out(int x) &#123; if (x == q + 1) puts(\"NIE\"); else &#123; printf(\"%d\\n\", x); &#125;&#125;int main() &#123; freopen(\"meteors.in\", \"r\", stdin); freopen(\"meteors.out\", \"w\", stdout); while (scanf(\"%d%d\", &amp;n, &amp;m) != EOF) &#123; vec.clear(); vec.resize(n + 1); bit.init(); for (int i = 1; i &lt;= n; ++i) res[i] = q + 1; for (int i = 1, x; i &lt;= m; ++i) &#123; scanf(\"%d\", &amp;x); vec[x].push_back(i); &#125; for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", tar + i); scanf(\"%d\", &amp;q); for (int i = 1; i &lt;= q; ++i) &#123; arr[i].scan(); &#125; arr[q + 1] = tnode(1, m, 2000000000ll); for (int i = 1; i &lt;= n; ++i) &#123; que[i] = qnode(i, tar[i]); &#125; gao(1, n, 1, q + 1); for (int i = 1; i &lt;= n; ++i) out(res[i]); &#125; return 0;&#125; G. Party题意：给定一个有$\\frac{2n}{3}$大小的团，求出$\\frac{n}{3}$使得这些点是团 思路：感性理解 假设都是团，枚举每个假设是团的点，如果这个点和一个你假设的点不相连，那么将这两个点都删除，每次只会删除两个不是团中的点或者一个团中的点以及一个不是团中的点，那么最多误删$\\frac{n}{3}$个点，剩下的就是团中的点。 思路二 每次选取度最小的点删除，直到所有点度数相同，感性理解即可 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;#define N 3010int n, m;int vis[N];int G[N][N];int main() &#123; freopen(\"party.in\", \"r\", stdin); freopen(\"party.out\", \"w\", stdout); while (scanf(\"%d %d\", &amp;n, &amp;m) != EOF) &#123; memset(vis, 0, sizeof vis); memset(G, 0, sizeof G); for (int i = 1, u, v; i &lt;= m; ++i) &#123; scanf(\"%d %d\", &amp;u, &amp;v); G[u][v] = G[v][u] = 1; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (vis[i]) continue; for (int j = i + 1; j &lt;= n; ++j) &#123; if (!vis[j] &amp;&amp; !G[i][j]) &#123; vis[i] = vis[j] = 1; break; &#125; &#125; &#125; vector&lt;int&gt; res; for (int i = 1; i &lt;= n; ++i) &#123; if (!vis[i]) &#123; res.push_back(i); &#125; &#125; for (int i = 0; i &lt; n / 3; ++i) &#123; printf(\"%d%c\", res[i], \" \\n\"[i == n / 3 - 1]); &#125; &#125; return 0;&#125; I. Sticks题意：有$k$ 个颜色，每个颜色有$n_i$个棍子，问能否有方案是的三根不同颜色的棍子拼成三角形 思路：排序后枚举一根棍子，往前找最大的不同颜色的棍子，往后找最小的不同颜色的棍子，$check$。考虑到如果$n$很大，那么很显然这很快就能找到方案。 可以考虑不合法方案，那就是一个斐波那契数列，只有$50$就会超过$1e9$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;bits/stdc++.h&gt;using namespace std;#define pii pair &lt;int, int&gt;#define fi first#define se secondconst int N = 1e6 + 10;int n, m;vector &lt;vector&lt;int&gt;&gt; vec; pii a[N];int Max[55];void solve() &#123; sort(a + 1, a + 1 + m); memset(Max, 0, sizeof Max); set &lt;int&gt; se[55]; for (int i = 1; i &lt;= m; ++i) &#123; se[a[i].se].insert(a[i].fi); &#125; for (int i = 1; i &lt;= m; ++i) &#123; se[a[i].se].erase(a[i].fi); vector &lt;pii&gt; b; for (int j = 1; j &lt;= n; ++j) &#123; if (!se[j].empty()) &#123; b.push_back(pii(*se[j].begin(), j)); &#125; &#125; sort(b.begin(), b.end(), [](pii x, pii y) &#123; return x.fi &lt; y.fi; &#125;); for (int j = 1; j &lt;= n; ++j) if (j != a[i].se) &#123; int x, y, z; y = a[i].fi; if (Max[j] != 0) &#123; x = Max[j]; for (auto &amp;it : b) &#123; if (it.se != a[i].se &amp;&amp; it.se != j) &#123; z = it.fi; if (x + y &gt; z) &#123; cout &lt;&lt; a[i].se &lt;&lt; \" \" &lt;&lt; a[i].fi &lt;&lt; \" \" &lt;&lt; j &lt;&lt; \" \" &lt;&lt; x &lt;&lt; \" \" &lt;&lt; it.se &lt;&lt; \" \" &lt;&lt; it.fi &lt;&lt; \"\\n\"; return; &#125; break; &#125; &#125; &#125; &#125; Max[a[i].se] = max(Max[a[i].se], a[i].fi); &#125; cout &lt;&lt; \"NIE\\n\";&#125;int main() &#123; freopen(\"sticks.in\", \"r\", stdin); freopen(\"sticks.out\", \"w\", stdout); ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); while (cin &gt;&gt; n) &#123; m = 0; vec.clear(); vec.resize(n + 1); for (int i = 1, num; i &lt;= n; ++i) &#123; cin &gt;&gt; num; vec[i].resize(num); for (auto &amp;it : vec[i]) cin &gt;&gt; it; sort(vec[i].begin(), vec[i].end()); vec[i].erase(unique(vec[i].begin(), vec[i].end()), vec[i].end()); for (auto &amp;it : vec[i]) &#123; a[++m] = pii(it, i); &#125; &#125; solve(); &#125; return 0;&#125;","categories":[],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://hsueh37.gitee.io/blog/tags/ACM/"}]},{"title":"Educational Codeforces Round 70 (Rated for Div. 2)","slug":"Educational-Codeforces-Round-70-(Rated-for-Div.-2)","date":"2019-08-09T02:20:00.000Z","updated":"2020-04-28T09:02:42.266Z","comments":true,"path":"2019/08/09/Educational-Codeforces-Round-70-(Rated-for-Div.-2)/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/08/09/Educational-Codeforces-Round-70-(Rated-for-Div.-2)/","excerpt":"","text":"A. You Are Given Two Binary Strings…签到 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 500010char x[N], y[N];int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%s\", x + 1); scanf(\"%s\", y + 1); int cnt1 = 0; for (int i = strlen(y + 1); i &gt;= 1; --i) &#123; if (y[i] != '0') &#123; break; &#125; cnt1++; &#125; int res = 0; for (int i = strlen(x + 1) - cnt1; i &gt;= 1; --i) &#123; if (x[i] != '0') &#123; break; &#125; else &#123; res++; &#125; &#125; printf(\"%d\\n\", res); &#125; return 0;&#125; B. You Are Given a Decimal String…题意：给定一个$x-y$计数器，每次只能加$x$或者$y$，且每次输出个位，现在有一个缺失了的打印结果，问对于一个$x-y(0\\leq x\\leq 9, 0\\leq y\\leq0)$最少的填充字符数 思路：预处理$x-y$计数器的$i-j(0\\leq i\\leq9,0\\leq j\\leq 9)$从$i$到达$j$的最小填充数字。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 2000010#define INF 0x3f3f3f3fchar s[N];ll ans[20][20];int a[20][20][20][20];void Init() &#123; memset(a, 0x3f, sizeof a); for (int x = 0; x &lt; 10; ++x) &#123; for (int y = 0; y &lt; 10; ++y) &#123; for (int o1 = 0; o1 &lt; 10; ++o1) &#123; for (int o2 = 0; o2 &lt; 10; ++o2) &#123; for (int i = 0; i &lt; 100; ++i) &#123; for (int j = 0; j &lt; 100; ++j) &#123; if (i == 0 &amp;&amp; j == 0) &#123; continue; &#125; if ((o1 + i * x + j * y) % 10 == o2) &#123; a[x][y][o1][o2] = min(a[x][y][o1][o2], i + j); &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif Init(); while (scanf(\"%s\", s + 1) != EOF) &#123; int len = strlen(s + 1); for (int x = 0; x &lt; 10; ++x) &#123; for (int y = 0; y &lt; 10; ++y) &#123; ans[x][y] = 0; if (len == 1) &#123; continue; &#125; for (int i = 2; i &lt;= len; ++i) &#123; int c1 = s[i] - '0', c2 = s[i - 1] - '0'; if (a[x][y][c2][c1] == INF) &#123; ans[x][y] = -1; break; &#125; else &#123; ans[x][y] += a[x][y][c2][c1] - 1; &#125; &#125; &#125; &#125; for (int x = 0; x &lt; 10; ++x) &#123; for (int y = 0; y &lt; 10; ++y) &#123; printf(\"%lld%c\", ans[x][y], \" \\n\"[y == 9]); &#125; &#125; &#125; return 0;&#125; C. You Are Given a WASD-string…题意：给定一个机器人，最多填充一个命令，使得包围住机器人走过路径的矩形的最小面积 思路：填充一个命令$=$回推一步，枚举到达上下左右边界的位置，回推一步后算面积 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 2000010#define INF 0x3f3f3f3fchar s[N];int Left[N], Right[N], Up[N], Down[N];void change(int &amp;x, int &amp;y, char c) &#123; if (c == 'W') &#123; ++y; &#125; else if (c == 'A') &#123; --x; &#125; else if (c == 'S') &#123; --y; &#125; else if (c == 'D') &#123; ++x; &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%s\", s + 1); int len = strlen(s + 1); int x = 0, y = 0; int x1 = INF, x2 = INF, y1 = INF, y2 = INF; int left = 0, right = 0, up = 0, down = 0; for (int i = 1; i &lt;= len; ++i) &#123; change(x, y, s[i]); if (left &gt; x) &#123; x1 = i; left = x; &#125; if (right &lt; x) &#123; x2 = i; right = x; &#125; if (up &lt; y) &#123; y1 = i; up = y; &#125; if (down &gt; y) &#123; y2 = i; down = y; &#125; &#125; ll ans = 1ll * (up - down + 1) * (right - left + 1); //right if (x1 != INF) &#123; x = y = left = right = up = down = 0; for (int i = 1; i &lt;= len; ++i) &#123; if (i == x1) &#123; change(x, y, 'D'); left = min(left, x); right = max(right, x); up = max(up, y); down = min(down, y); &#125; change(x, y, s[i]); left = min(left, x); right = max(right, x); up = max(up, y); down = min(down, y); &#125; ans = min(ans, 1ll * (up - down + 1) * (right - left + 1)); &#125; if (x2 != INF) &#123; x = y = left = right = up = down = 0; for (int i = 1; i &lt;= len; ++i) &#123; if (i == x2) &#123; change(x, y, 'A'); left = min(left, x); right = max(right, x); up = max(up, y); down = min(down, y); &#125; change(x, y, s[i]); left = min(left, x); right = max(right, x); up = max(up, y); down = min(down, y); &#125; ans = min(ans, 1ll * (up - down + 1) * (right - left + 1)); &#125; if (y1 != INF) &#123; x = y = left = right = up = down = 0; for (int i = 1; i &lt;= len; ++i) &#123; if (i == y1) &#123; change(x, y, 'S'); left = min(left, x); right = max(right, x); up = max(up, y); down = min(down, y); &#125; change(x, y, s[i]); left = min(left, x); right = max(right, x); up = max(up, y); down = min(down, y); &#125; ans = min(ans, 1ll * (up - down + 1) * (right - left + 1)); &#125; if (y2 != INF) &#123; x = y = left = right = up = down = 0; for (int i = 1; i &lt;= len; ++i) &#123; if (i == y2) &#123; change(x, y, 'W'); left = min(left, x); right = max(right, x); up = max(up, y); down = min(down, y); &#125; change(x, y, s[i]); left = min(left, x); right = max(right, x); up = max(up, y); down = min(down, y); &#125; ans = min(ans, 1ll * (up - down + 1) * (right - left + 1)); &#125; printf(\"%lld\\n\", ans); &#125; return 0;&#125; D. Print a 1337-string…题意：构造一个长度不大于$1e5$的字符串，使得$1337$子串出现次数为$n$ 思路：在字符串末尾放一个$7$，那么$1337$出现次数为每个$1$到$7$的$3$的个数$x$,贡献为$\\frac{x(x-1)}{2}$，同时$n$可以分解为若干个$\\frac{x(x-1)}{2}$的累加，构造即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 2000010ll n;char str[N];int cnt[N];ll calc(ll x) &#123; return x * (x - 1) &gt;&gt; 1;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%lld\", &amp;n); cnt[0] = 0; for (int i = 100000; i &gt;= 1; --i) &#123; ll C = calc(i); if (C == 0) &#123; continue; &#125; while (n &gt;= C) &#123; n -= C; cnt[++cnt[0]] = i; &#125; &#125; str[1] = '7'; int pos = 1, c1 = 0; for (int i = cnt[0]; i &gt;= 1; --i) &#123; for (int j = c1; j &lt; cnt[i]; ++j) &#123; str[++pos] = '3'; ++c1; &#125; str[++pos] = '1'; &#125; reverse(str + 1, str + 1 + pos); str[++pos] = 0; puts(str + 1); &#125; return 0;&#125; E.You Are Given Some Strings…题意：定义$f(t,s)$表示字符串$s$在$t$中出现的次数，现在给定一个$t$以及$n$个$s$，问$\\sum_{i=1}^{n}\\sum_{j=1}^{n}f(t, s_i+s_j)$。 思路：单独考虑每个$s_i$的贡献，那么如果$s_i$出现的末尾位置是$L_i$，那么他能和出现的初始位置为$L_i+1$的每个$j$产生一个贡献。我们用$L_i$表示在$s$中末尾位置在$t$字符串的$i$位置出现字符串个数，$R_i$表示$s$中起始位置在$t$字符串的$i$位置出现的字符串个数，那么答案就是$\\sum_{i=1}^{len-1}L_i\\cdot R_i+1$其中$len$表示$t$的长度。对于$L,R$可以用$ac$自动机处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 200010struct Trie &#123; struct node &#123; int nxt[26], fail, cnt; node() &#123; memset(nxt, -1, sizeof nxt); cnt = 0; &#125; &#125; t[N]; int root, L; int newnode() &#123; t[++L] = node(); return L; &#125; void Init() &#123; L = 0; root = newnode(); &#125; void insert(const string &amp;s) &#123; int now = root; for (char i : s) &#123; if (t[now].nxt[i - 'a'] == -1) t[now].nxt[i - 'a'] = newnode(); now = t[now].nxt[i - 'a']; &#125; ++t[now].cnt; &#125; void build() &#123; queue&lt;int&gt; q; t[root].fail = root; for (int i = 0; i &lt; 26; ++i) &#123; if (t[root].nxt[i] == -1) &#123; t[root].nxt[i] = root; &#125; else &#123; t[t[root].nxt[i]].fail = root; q.push(t[root].nxt[i]); &#125; &#125; while (!q.empty()) &#123; int now = q.front(); q.pop(); t[now].cnt += t[t[now].fail].cnt; for (int i = 0; i &lt; 26; ++i) &#123; if (t[now].nxt[i] == -1) &#123; t[now].nxt[i] = t[t[now].fail].nxt[i]; &#125; else &#123; t[t[now].nxt[i]].fail = t[t[now].fail].nxt[i]; q.push(t[now].nxt[i]); &#125; &#125; &#125; &#125; void query(string s, ll *a) &#123; int now = root; for (int i = 0, len = s.length(); i &lt; len; ++i) &#123; now = t[now].nxt[s[i] - 'a']; a[i] = t[now].cnt; &#125; &#125; void debug() &#123; for (int i = 1; i &lt;= L; ++i) &#123; cout &lt;&lt; t[i].cnt &lt;&lt; \" \\n\"[i == L]; &#125; &#125;&#125; trie;int n;string s[N], t, tr;ll L[N], R[N];int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); while (cin &gt;&gt; t) &#123; tr = t; reverse(tr.begin(), tr.end()); memset(L, 0, sizeof L); memset(R, 0, sizeof R); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; s[i]; &#125; trie.Init(); for (int i = 1; i &lt;= n; ++i) &#123; trie.insert(s[i]); &#125; trie.build(); trie.query(t, L);; trie.Init(); for (int i = 1; i &lt;= n; ++i) &#123; reverse(s[i].begin(), s[i].end()); trie.insert(s[i]); &#125; trie.build(); trie.query(tr, R); int len = t.length(); reverse(R, R + len); ll ans = 0; for (int i = 0; i &lt; len; ++i) &#123; ans += L[i] * R[i + 1]; &#125; cout &lt;&lt; ans &lt;&lt; \"\\n\"; &#125; return 0;&#125;","categories":[],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://hsueh37.gitee.io/blog/tags/Codeforces/"}]},{"title":"2019牛客暑期多校训练营（第七场）","slug":"2019牛客暑期多校训练营（第七场）","date":"2019-08-08T13:30:00.000Z","updated":"2020-04-28T09:02:42.261Z","comments":true,"path":"2019/08/08/2019牛客暑期多校训练营（第七场）/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/08/08/2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B8%83%E5%9C%BA%EF%BC%89/","excerpt":"","text":"A. String题意：定义一个$prefect \\; string$表示它是循环字符串中字典序最小的，问将一个字符串分解成若干个$prefect \\; string$。 思路：暴力 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;using namespace std;#define N 210int n;string s;vector &lt;string&gt; res;int minRep(string s) &#123; int len = s.size(); int i = 0, j = 1, k = 0; while (i &lt; len &amp;&amp; j &lt; len &amp;&amp; k &lt; len) &#123; int t = s[(i + k) % len] - s[(j + k) % len]; if (!t) ++k; else &#123; if (t &gt; 0) i += k + 1; else if (t &lt; 0) j += k + 1; if (i == j) j = i + 1; k = 0; &#125; // printf(\"%d %d %d\\n\", i, j, k); &#125; return min(i, j);&#125;int ok(string s) &#123; string t = s; s += t; if (minRep(s) == 0) return 1; return 0;&#125;void solve(string s) &#123; int len = s.size(); string t = \"\"; for (int i = len; i &gt;= 1; --i) &#123; if (ok(s)) &#123; res.push_back(s); reverse(t.begin(), t.end()); solve(t); return; &#125; else &#123; t += s[i - 1]; s.pop_back(); &#125; &#125;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int T; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; s; res.clear(); solve(s); for (int i = 0, sze = (int)res.size(); i &lt; sze; ++i) &#123; cout &lt;&lt; res[i] &lt;&lt; \" \\n\"[i == sze - 1]; &#125; &#125; return 0;&#125; B. Irreducible Polynomial题意：判断一个多项式能否被分解 思路：对于$3$阶以及以上的多项式一定能被分解，剩下的只需要判断$0,1,2$多项式 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 110int n;ll a[N];int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); for (int i = n; i &gt;= 0; --i) &#123; scanf(\"%lld\", a + i); &#125; if (n &gt;= 3) &#123; puts(\"No\"); continue; &#125; else if (n &lt;= 1) &#123; puts(\"Yes\"); continue; &#125; else if (n == 2) &#123; ll A = a[2], B = a[1], C = a[0]; ll d = B * B - 4 * A * C; if (d &gt;= 0) &#123; puts(\"No\"); &#125; else &#123; puts(\"Yes\"); &#125; &#125; &#125; return 0;&#125; C. Governing sand题意：有$n$种树，每种树具有$H_i, P_i,C_i$，分别表示高度，数量，砍掉的代价，问砍掉最小代价的树，使得剩下的最高的树的个数大于一半。 思路：枚举高度，权值线段树上二分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define N 100010const ll INF = 0x3f3f3f3f3f3f3f3f;int n; ll tot;struct Hash &#123; int a[N], cnt; void init() &#123; cnt = 0; &#125; void add(int x) &#123; a[++cnt] = x; &#125; void work() &#123; sort(a + 1, a + 1 + cnt); cnt = unique(a + 1, a + 1 + cnt) - a - 1; &#125; int get(int x) &#123; return lower_bound(a + 1, a + 1 + cnt, x) - a; &#125;&#125;hs;struct node &#123; int h, c, p; void scan() &#123; scanf(\"%d%d%d\", &amp;h, &amp;c, &amp;p); hs.add(h); tot += p; &#125;&#125;a[N];vector &lt;vector&lt;node&gt;&gt; vec;struct SEG &#123; struct node &#123; ll sum, num, base; node() &#123; sum = num = base = 0; &#125; void add(ll x) &#123; num += x; sum += base * x; &#125; node operator + (const node &amp;other) const &#123; node res = node(); res.sum = sum + other.sum; res.num = num + other.num; return res; &#125; &#125;t[10010]; void build(int id, int l, int r) &#123; t[id] = node(); if (l == r) &#123; t[id].base = l; return; &#125; int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); &#125; void update(int id, int l, int r, int pos, ll x) &#123; if (l == r) &#123; t[id].add(x); return; &#125; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) update(id &lt;&lt; 1, l, mid, pos, x); else update(id &lt;&lt; 1 | 1, mid + 1, r, pos, x); t[id] = t[id &lt;&lt; 1] + t[id &lt;&lt; 1 | 1]; &#125; ll query(int id, int l, int r, ll k) &#123; if (k &lt;= 0) return 0; if (l == r) &#123; return k * t[id].base; &#125; int mid = (l + r) &gt;&gt; 1; if (t[id &lt;&lt; 1].num &gt;= k) &#123; return query(id &lt;&lt; 1, l, mid, k); &#125; else &#123; return t[id &lt;&lt; 1].sum + query(id &lt;&lt; 1 | 1, mid + 1, r, k - t[id &lt;&lt; 1].num); &#125; &#125;&#125;seg;int main() &#123; while (scanf(\"%d\", &amp;n) != EOF) &#123; tot = 0; hs.init(); for (int i = 1; i &lt;= n; ++i) a[i].scan(); hs.work(); vec.clear(); vec.resize(n + 1); for (int i = 1; i &lt;= n; ++i) &#123; vec[hs.get(a[i].h)].push_back(a[i]); &#125; int m = 200; seg.build(1, 1, m); ll fee = 0, res = INF; for (int i = 1; i &lt;= n; ++i) &#123; seg.update(1, 1, m, a[i].c, a[i].p); &#125; for (int i = hs.cnt; i &gt;= 1; --i) &#123; ll tmp = 0, now = 0; for (auto it : vec[i]) &#123; now += it.p; tmp += 1ll * it.c * it.p; seg.update(1, 1, m, it.c, -it.p); &#125; tot -= now; res = min(res, fee + seg.query(1, 1, m, tot - now + 1)); fee += tmp; &#125; printf(\"%lld\\n\", res); &#125; return 0;&#125; D. Number签到 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;int n, p;int f(int x) &#123; int res = 0; while (x) &#123; ++res; x /= 10; &#125; return res;&#125;int main() &#123; while (scanf(\"%d%d\", &amp;n, &amp;p) != EOF) &#123; if (f(p) &gt; n) &#123; puts(\"T_T\"); &#125; else &#123; int need = n - f(p); printf(\"%d\", p); for (int i = 1; i &lt;= need; ++i) putchar('0'); puts(\"\"); &#125; &#125; return 0;&#125; E. Find the median题意：每次插入一个$[L_i, R_i]$范围内的所有数，问中位数 思路：线段树维护区间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define N 400010struct Hash &#123; int a[N &lt;&lt; 1], cnt; void init() &#123; cnt = 0; &#125; void add(int x) &#123; a[++cnt] = x; &#125; void work() &#123; sort(a + 1, a + 1 + cnt); cnt = unique(a + 1, a + 1 + cnt) - a - 1; &#125; int get(int x) &#123; return lower_bound(a + 1, a + 1 + cnt, x) - a; &#125;&#125;hs;int n, m;ll A[2], B[2], C[2], M[2];ll L[N], R[N], X[N], Y[N];struct SEG &#123; struct node &#123; int base; //0表示左端点 1表示右端点 int num[2]; ll sum[2]; node() &#123; num[0] = num[1] = 0; sum[0] = sum[1] = 0; &#125; void add(ll x, int f) &#123; num[f] += x; sum[f] += 1ll * x * base; &#125; node operator + (const node &amp;other) const &#123; node res = node(); for (int i = 0; i &lt; 2; ++i) &#123; res.num[i] = num[i] + other.num[i]; res.sum[i] = sum[i] + other.sum[i]; &#125; return res; &#125; &#125;t[N &lt;&lt; 3], base; void build(int id, int l, int r) &#123; t[id] = node(); if (l == r) &#123; t[id].base = hs.a[l] - 1; return; &#125; int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); &#125; void update(int id, int l, int r, int pos, ll x, int f) &#123; if (l == r) &#123; t[id].add(x, f); return; &#125; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) update(id &lt;&lt; 1, l, mid, pos, x, f); else update(id &lt;&lt; 1 | 1, mid + 1, r, pos, x, f); t[id] = t[id &lt;&lt; 1] + t[id &lt;&lt; 1 | 1]; &#125; int query(int id, int l, int r, ll k, node left) &#123;// printf(\"## %d %d %lld\\n\", l, r, k) ; if (l == r) return hs.a[l]; node tmp = left + t[id &lt;&lt; 1]; int mid = (l + r) &gt;&gt; 1; ll pl = hs.a[mid]; ll pr = hs.a[mid + 1] - 1; ll resl = 1ll * pl * tmp.num[0] - tmp.sum[0] - (1ll * pl * tmp.num[1] - tmp.sum[1] - tmp.num[1]); ll resr = 1ll * pr * tmp.num[0] - tmp.sum[0] - (1ll * pr * tmp.num[1] - tmp.sum[1] - tmp.num[1]); if (resl &gt;= k) &#123; return query(id &lt;&lt; 1, l, mid, k, left); &#125; else if (resr &lt; k) &#123; return query(id &lt;&lt; 1 | 1, mid + 1, r, k, tmp); &#125; else &#123; int ql = pl, qr = pr, res = pr; while (qr - ql &gt;= 0) &#123; int mid = (ql + qr) &gt;&gt; 1; ll tot = 1ll * mid * tmp.num[0] - tmp.sum[0] - (1ll * mid * tmp.num[1] - tmp.sum[1] - tmp.num[1]); if (tot &gt;= k) &#123; res = mid; qr = mid - 1; &#125; else &#123; ql = mid + 1; &#125; &#125; return res; &#125; &#125;&#125;seg; int main() &#123; while (scanf(\"%d\", &amp;n) != EOF) &#123; scanf(\"%lld%lld%lld%lld%lld%lld\", X + 1, X + 2, A, B, C, M); scanf(\"%lld%lld%lld%lld%lld%lld\", Y + 1, Y + 2, A + 1, B + 1, C + 1, M + 1); hs.init(); L[1] = X[1] + 1; R[1] = Y[1] + 1; if (L[1] &gt; R[1]) swap(L[1], R[1]); hs.add(L[1]); hs.add(R[1]); L[2] = X[2] + 1; R[2] = Y[2] + 1; if (L[2] &gt; R[2]) swap(L[2], R[2]); hs.add(L[2]); hs.add(R[2]); for (int i = 3; i &lt;= n; ++i) &#123; X[i] = (A[0] * X[i - 1] % M[0] + B[0] * X[i - 2] % M[0] + C[0] + M[0]) % M[0]; Y[i] = (A[1] * Y[i - 1] % M[1] + B[1] * Y[i - 2] % M[1] + C[1] + M[1]) % M[1]; L[i] = X[i] + 1; R[i] = Y[i] + 1; if (L[i] &gt; R[i]) swap(L[i], R[i]); hs.add(L[i]); hs.add(R[i]); &#125; // for (int i = 1; i &lt;= n; ++i) printf(\"%lld %lld\\n\", L[i], R[i]); hs.work(); m = hs.cnt; seg.build(1, 1, m); ll tot = 0; for (int i = 1; i &lt;= n; ++i) &#123; seg.update(1, 1, m, hs.get(L[i]), 1, 0); seg.update(1, 1, m, hs.get(R[i]), 1, 1); tot += R[i] - L[i] + 1; seg.base = SEG::node(); printf(\"%d\\n\", seg.query(1, 1, m, (tot + 1) / 2, seg.base)); &#125; &#125; return 0;&#125; F. Energy stones题意：有$n$堆能量石，每个能量石具有$E_i，L_i,C_i$，其中$E_i$表示能量石初始能量，$L_i$表示能量增长速度，$C_i$表示能量上限，CNZ有$m$次进食，每次在$t_i$吃掉区间$[S_i, T_i]$范围内的能量石，问最后吃了多少能量。 思路：用$set$维护时间线表示当前石头$i$被吃的时间节点，然后用一颗线段树动态维护时间长度的数量，对于时间长度大于$\\lceil \\frac{C_i}{L_i}\\rceil$的时间收益为$C_i$，剩下的就是长度乘上$L_i$，然后动态维护时间线即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define N 200010int n, q;struct node &#123; int e, l, c; void scan() &#123; scanf(\"%d%d%d\", &amp;e, &amp;l, &amp;c); &#125;&#125; a[N];vector&lt;vector&lt;int&gt;&gt; add, del;struct SEG &#123; struct node &#123; ll sum, num; int base; node() &#123; sum = num = 0; &#125; void add(ll x) &#123; sum += x * base; num += x; &#125; node operator+(const node &amp;other) const &#123; node res = node(); res.sum = sum + other.sum; res.num = num + other.num; return res; &#125; &#125; t[N &lt;&lt; 2], res; void build(int id, int l, int r) &#123; t[id] = node(); if (l == r) &#123; t[id].base = l; return; &#125; int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); &#125; void update(int id, int l, int r, int pos, int x) &#123; if (l == r) &#123; t[id].add(x); return; &#125; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) update(id &lt;&lt; 1, l, mid, pos, x); else update(id &lt;&lt; 1 | 1, mid + 1, r, pos, x); t[id] = t[id &lt;&lt; 1] + t[id &lt;&lt; 1 | 1]; &#125; void query(int id, int l, int r, int ql, int qr) &#123; if (ql &gt; qr) return; if (l &gt;= ql &amp;&amp; r &lt;= qr) &#123; res = res + t[id]; return; &#125; int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) query(id &lt;&lt; 1, l, mid, ql, qr); if (qr &gt; mid) query(id &lt;&lt; 1 | 1, mid + 1, r, ql, qr); &#125;&#125; seg;int main() &#123; int T; scanf(\"%d\", &amp;T); for (int kase = 1; kase &lt;= T; ++kase) &#123; printf(\"Case #%d: \", kase); scanf(\"%d\", &amp;n); add.clear(); del.clear(); add.resize(n + 10); del.resize(n + 10); for (int i = 1; i &lt;= n; ++i) a[i].scan(); scanf(\"%d\", &amp;q); for (int i = 1, S, T1, t; i &lt;= q; ++i) &#123; scanf(\"%d%d%d\", &amp;t, &amp;S, &amp;T1); add[S].push_back(t); del[T1 + 1].push_back(t); &#125; int m = 200000; ll res = 0; seg.build(1, 1, m); set&lt;int&gt; se; int Fi = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (auto it : add[i]) &#123; if (se.empty()) &#123; se.insert(it); Fi = it; &#125; else &#123; auto pos = se.lower_bound(it); if (pos == se.begin()) &#123; Fi = it; seg.update(1, 1, m, *se.begin() - it, 1); se.insert(it); &#125; else if (pos == se.end()) &#123; --pos; seg.update(1, 1, m, it - *pos, 1); se.insert(it); &#125; else &#123; auto pos2 = pos; --pos2; seg.update(1, 1, m, it - *pos2, 1); seg.update(1, 1, m, *pos - it, 1); seg.update(1, 1, m, *pos - *pos2, -1); se.insert(it); &#125; &#125; &#125; for (auto it : del[i]) &#123; auto pos = se.lower_bound(it); auto nx = pos; ++nx; if (pos == se.begin()) &#123; if (nx == se.end()) &#123; Fi = 0; &#125; else &#123; Fi = *nx; seg.update(1, 1, m, *nx - *pos, -1); &#125; se.erase(pos); &#125; else if (nx == se.end()) &#123; auto pre = pos; --pre; seg.update(1, 1, m, *pos - *pre, -1); se.erase(pos); &#125; else &#123; auto pre = pos; --pre; seg.update(1, 1, m, *pos - *pre, -1); seg.update(1, 1, m, *nx - *pos, -1); seg.update(1, 1, m, *nx - *pre, 1); se.erase(pos); &#125; &#125; if (Fi == 0) continue; res += min(1ll * a[i].e + 1ll * a[i].l * Fi, 1ll * a[i].c); if (a[i].l == 0) continue; int t = ((a[i].c + a[i].l - 1) / a[i].l); seg.res = SEG::node(); //大于等于t的 seg.query(1, 1, m, t, m); res += 1ll * a[i].c * seg.res.num; //小于t的 seg.res = SEG::node(); seg.query(1, 1, m, 1, t - 1); res += 1ll * seg.res.sum * a[i].l; &#125; printf(\"%lld\\n\", res); &#125; return 0;&#125; H. Pair题意：问有多少对$$其中满足$1\\leq x \\leq A, 1\\leq y \\leq B$，满足以下任意条件 $x \\&amp; y&gt; C $ $x \\oplus y &lt; C$ 思路：经典的数位$dp$, $dp[pos][f1][f2][l1][l2][one1][one2]$,其中$pos$表示枚举到哪一位，$f1$表示$x\\&amp; y$和$C$的关系，$f2$表示$x\\oplus y$和$C$的关系,，$l1,l2$表示是否达到上届，$one1, one2$表示是否有$1$，所以跑得飞快 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 100ll A, B, C;int a[N], b[N], c[N];ll dp[N][3][3][2][2][2][2];//位置 x&amp;y x^y (=0 &lt;1 &gt;2)ll DFS(int pos, int flag1, int flag2, int limit1, int limit2, int one1, int one2) &#123; if (pos == -1 &amp;&amp; (flag1 == 2 || flag2 == 1) &amp;&amp; one1 == 1 &amp;&amp; one2 == 1) &#123; return 1ll; &#125; else if (pos == -1) &#123; return 0ll; &#125; ll &amp;res = dp[pos][flag1][flag2][limit1][limit2][one1][one2]; if (res != -1) &#123; return res; &#125; res = 0; if (flag1 == 1 &amp;&amp; flag2 == 2) &#123;//x&amp;y&lt;C x^y&gt;C 不合法 return 0ll; &#125; int l1 = limit1 ? a[pos] : 1; int l2 = limit2 ? b[pos] : 1; for (int i = 0; i &lt;= l1; ++i) &#123; for (int j = 0; j &lt;= l2; ++j) &#123; int x = i &amp; j; int y = i ^j; int f1 = flag1; if (f1 == 0) &#123; if (x &gt; c[pos]) &#123; f1 = 2; &#125; else if (x == c[pos]) &#123; f1 = 0; &#125; else &#123; f1 = 1; &#125; &#125; int f2 = flag2; if (f2 == 0) &#123; if (y &gt; c[pos]) &#123; f2 = 2; &#125; else if (y == c[pos]) &#123; f2 = 0; &#125; else &#123; f2 = 1; &#125; &#125; res += DFS(pos - 1, f1, f2, limit1 &amp;&amp; (i == a[pos]), limit2 &amp;&amp; (j == b[pos]), one1 | i, one2 | j); &#125; &#125; return res;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%lld %lld %lld\", &amp;A, &amp;B, &amp;C); for (int i = 30; i &gt;= 0; --i) &#123; if (A &amp; (1ll &lt;&lt; i)) &#123; a[i] = 1; &#125; else &#123; a[i] = 0; &#125; if (B &amp; (1ll &lt;&lt; i)) &#123; b[i] = 1; &#125; else &#123; b[i] = 0; &#125; if (C &amp; (1ll &lt;&lt; i)) &#123; c[i] = 1; &#125; else &#123; c[i] = 0; &#125; &#125; memset(dp, -1, sizeof dp); printf(\"%lld\\n\", DFS(30, 0, 0, 1, 1, 0, 0)); &#125; return 0;&#125; J. A+B problem签到 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longll A, B;ll f(ll x) &#123; vector &lt;int&gt; vec; while (x) &#123; vec.push_back(x % 10); x /= 10; &#125; ll res = 0; for (auto it : vec) res = res * 10 + it; return res;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%lld%lld\", &amp;A, &amp;B); printf(\"%lld\\n\", f(f(A) + f(B))); &#125; return 0;&#125; 后记：最近咋回事？本队任督二脉打开了(x","categories":[],"tags":[{"name":"2019牛客多校","slug":"2019牛客多校","permalink":"https://hsueh37.gitee.io/blog/tags/2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"}]},{"title":"Multi-University-Training-Contest-6","slug":"Multi-University-Training-Contest-6","date":"2019-08-08T03:40:00.000Z","updated":"2020-04-28T09:02:42.269Z","comments":true,"path":"2019/08/08/Multi-University-Training-Contest-6/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/08/08/Multi-University-Training-Contest-6/","excerpt":"","text":"B. Nonsense Time题意：给定一个序列，刚开始都是冻结状态，每次加入一个数后问$LIS$长度，数据随机 思路：由于数据随机，所以$LIS$长度的期望是$\\sqrt{n}$，那么倒过来做，如果删除的数在$LIS$中，则暴力重构$LIS$，最多进行$\\sqrt{n}$次，复杂度为$O(\\sqrt{n} \\cdot n \\cdot log_2n)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;using namespace std;#define N 500010#define INF 0x3f3f3f3fint n, a[N], b[N], ans[N], pre[N], nxt[N], used[N], bit[N], f[N], g[N];void solve() &#123; for (int i = nxt[0]; i &lt;= n + 1; i = nxt[i]) &#123; used[i] = 0; int Max = 0; for (int j = a[i]; j; j -= j &amp; -j) &#123; if (f[Max] &lt; f[bit[j]]) &#123; Max = bit[j]; &#125; &#125; f[i] = f[Max] + 1; g[i] = Max; for (int j = a[i]; j &lt;= n + 2; j += j &amp; -j) &#123; if (f[bit[j]] &lt; f[i]) &#123; bit[j] = i; &#125; &#125; &#125; for (int i = nxt[0]; i &lt;= n + 1; i = nxt[i]) &#123; for (int j = a[i]; j &lt;= n + 2; j += j &amp; -j) &#123; bit[j] = 0; &#125; &#125; for (int i = n + 1; i; i = g[i]) &#123; used[i] = 1; &#125;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); a[i]++; &#125; a[0] = 1, a[n + 1] = n + 2; for (int i = 0; i &lt;= n + 1; ++i) &#123; pre[i] = i - 1; nxt[i] = i + 1; bit[i] = used[i] = 0; &#125; bit[n + 2] = 0; solve(); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", b + i); &#125; for (int i = n; i &gt;= 1; --i) &#123; ans[i] = f[n + 1] - 1; int p = b[i]; pre[nxt[p]] = pre[p]; nxt[pre[p]] = nxt[p]; if (used[p]) &#123; solve(); &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; printf(\"%d%c\", ans[i], \" \\n\"[i == n]); &#125; &#125; E. Snowy Smile题意：给出$n$个点的坐标和权值，问最大子矩阵和。 思路：离散化后为$n\\cdot n$的矩形，由于只有$2000$个点，所以枚举上边界，拓展下边界，用线段树维护最大子段和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define pii pair &lt;int, int&gt;#define fi first#define se second#define N 2010int n;vector&lt;vector&lt;pii&gt;&gt; vec;struct Hash &#123; int a[N], cnt; void init() &#123; cnt = 0; &#125; void add(int x) &#123; a[++cnt] = x; &#125; void work() &#123; sort(a + 1, a + 1 + cnt); cnt = unique(a + 1, a + 1 + cnt) - a - 1; &#125; int get(int x) &#123; return lower_bound(a + 1, a + 1 + cnt, x) - a; &#125;&#125; hx, hy;struct node &#123; int x, y, w; node() &#123;&#125; void scan() &#123; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;w); hx.add(x); hy.add(y); &#125;&#125; a[N];struct SEG &#123; struct node &#123; //0表示前缀最大 1表示后缀最大 2表示区间最大和 sum表示区间和 ll Max[3], sum; node() &#123; Max[0] = Max[1] = Max[2] = sum = 0; &#125; void add(ll w) &#123; sum += w; Max[0] = Max[1] = Max[2] = max(0ll, sum); &#125; node operator+(const node &amp;other) const &#123; node res = node(); res.Max[0] = max(Max[0], sum + other.Max[0]); res.Max[1] = max(other.Max[1], Max[1] + other.sum); res.Max[2] = max(Max[2], other.Max[2]); res.Max[2] = max(res.Max[2], Max[1] + other.Max[0]); res.sum = sum + other.sum; return res; &#125; &#125; t[N &lt;&lt; 2]; void build(int id, int l, int r) &#123; t[id] = node(); if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); &#125; void update(int id, int l, int r, int pos, ll w) &#123; if (l == r) &#123; t[id].add(w); return; &#125; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) update(id &lt;&lt; 1, l, mid, pos, w); else update(id &lt;&lt; 1 | 1, mid + 1, r, pos, w); t[id] = t[id &lt;&lt; 1] + t[id &lt;&lt; 1 | 1]; &#125;&#125; seg;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; hx.init(); hy.init(); scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) a[i].scan(); hx.work(); hy.work(); vec.clear(); vec.resize(hx.cnt + 10); for (int i = 1; i &lt;= n; ++i) &#123; vec[hx.get(a[i].x)].push_back(pii(hy.get(a[i].y), a[i].w)); &#125; ll res = 0; for (int i = 1; i &lt;= hx.cnt; ++i) &#123; seg.build(1, 1, hy.cnt); for (int j = i; j &lt;= hx.cnt; ++j) &#123; for (auto it : vec[j]) &#123; seg.update(1, 1, hy.cnt, it.fi, it.se); &#125; res = max(res, seg.t[1].Max[2]); &#125; &#125; printf(\"%lld\\n\", res); &#125; F. Faraway题意：有$n$个士兵以及一个$target$，$target$对于每个士兵满足$(\\vert x_i-x_e\\vert + \\vert y_i- y_e\\vert) mod \\; k_i=t_i$，问方案数。 思路：对于每个士兵，合法的$target$是以菱形扩散的，每个士兵可以将图划分为四个部分，每个部分都是不断循环的。那么$n$个士兵将图划分为$(n+1)\\cdot (n+1)$个部分，对于每个部分都是一个以$lcm\\cdot lcm$的小矩阵不断填充的大矩阵，分别做即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 256int LCM(int a, int b) &#123; return a * b / __gcd(a, b);&#125;struct node &#123; int x, y, k, t; node() &#123;&#125; node(int _x, int _y, int _k, int _t) &#123; x = _x; y = _y; k = _k; t = _t; &#125; void input() &#123; scanf(\"%d %d %d %d\", &amp;x, &amp;y, &amp;k, &amp;t); &#125; bool clac(int _x, int _y) &#123; return (abs(x - _x) + abs(y - _y)) % k == t; &#125;&#125; a[N];int n, m;int lcm;int mp[N][N];int X[N], Y[N];ll solve(int sx, int sy, int ex, int ey, int up = 0, int right = 0) &#123; for (int i = 0; i &lt; lcm; ++i) &#123; for (int j = 0; j &lt; lcm; ++j) &#123; int cnt = 0; for (int o = 1; o &lt;= n; ++o) &#123; cnt += a[o].clac(sx + i, sy + j); &#125; mp[i][j] = (cnt == n); if (i &gt; 0) &#123; mp[i][j] += mp[i - 1][j]; &#125; if (j &gt; 0) &#123; mp[i][j] += mp[i][j - 1]; &#125; if (i &gt; 0 &amp;&amp; j &gt; 0) &#123; mp[i][j] -= mp[i - 1][j - 1]; &#125; &#125; &#125; ll dx = ex - sx + right, dy = ey - sy + up; ll t1 = (dx - 1) / lcm, t2 = (dy - 1) / lcm; ll res = 0; res += t1 * t2 * mp[lcm - 1][lcm - 1]; int eey = dy - t2 * lcm; res += mp[lcm - 1][eey - 1] * t1; int eex = dx - t1 * lcm; res += mp[eex - 1][lcm - 1] * t2; res += mp[eex - 1][eey - 1]; return res;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d %d\", &amp;n, &amp;m); X[0] = 0, Y[0] = 0; X[++X[0]] = 0, X[++X[0]] = m; Y[++Y[0]] = 0, Y[++Y[0]] = m; for (int i = 1; i &lt;= n; ++i) &#123; a[i].input(); X[++X[0]] = a[i].x; Y[++Y[0]] = a[i].y; &#125; lcm = a[1].k; for (int i = 1; i &lt;= n; ++i) &#123; lcm = LCM(lcm, a[i].k); &#125; sort(X + 1, X + 1 + X[0]); sort(Y + 1, Y + 1 + Y[0]); X[0] = unique(X + 1, X + 1 + X[0]) - X - 1; Y[0] = unique(Y + 1, Y + 1 + Y[0]) - Y - 1; ll ans = 0; for (int i = 1; i &lt; X[0]; ++i) &#123; for (int j = 1; j &lt; Y[0]; ++j) &#123; ans += solve(X[i], Y[j], X[i + 1], Y[j + 1], j == Y[0] - 1, i == X[0] - 1); &#125; &#125; printf(\"%lld\\n\", ans); &#125; H. TDL题意：$f(n, m)$表示第$m$个和$n$互质的数$x(x&gt;n)$，现在给定$m, k$，问最小的$n$满足$(f(n, m) - n)\\oplus n=k$ 思路：$f(n-m)-n$表示的是第$m$个与$n$互质的数，那么枚举$f(n-m)-n$，可以通过$f(n, m)-n=n\\oplus k$得到$n$，暴力$check$即可。 #include &lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define INFLL 0x3f3f3f3f3f3f3f3f ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; } ll k; int m; int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) { scanf(&quot;%lld%d&quot;, &amp;k, &amp;m); ll res = INFLL; for (int i = 1; i &lt;= 800; ++i) { ll n = k ^i; if (__gcd(1ll * i, n) != 1) continue; int cur = 0; for (int j = 1; j &lt;= i; ++j) { cur += (__gcd(j + n, n) == 1); if (cur &gt; m) break; } if (cur == m) { res = min(res, n); } } if (res == INFLL) res = -1; printf(&quot;%lld\\n&quot;, res); } L. Stay Real题意：给出一个小根堆，两个人轮流取，只能取没有儿子节点的点，两人都想最大化收益，问最终收益。 思路：由于是小根堆，所以儿子节点权值大于父亲节点，贪心即可。 #include &lt;bits/stdc++.h&gt; using namespace std; #define ll long long #define N 200100 #define pii pair &lt;int, int&gt; #define fi first #define se second int n, a[N]; int vis[N]; int main() { int T; scanf(&quot;%d&quot;, &amp;T); while (T--) { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n * 2 + 10; ++i) vis[i] = 0; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, a + i), vis[i] = 1; ll res[2] = {0, 0}; priority_queue&lt;pii &gt; pq; for (int i = n; i &gt;= 1; --i) { if (vis[n * 2] == 0 &amp;&amp; vis[n * 2 + 1] == 0) { pq.emplace(a[i], i); } } int turn = 0; while (!pq.empty()) { pii it = pq.top(); pq.pop(); if (vis[it.se] == 0) continue; res[turn] += it.fi; turn ^= 1; vis[it.se] = 0; int fa = it.se / 2; if (fa &amp;&amp; vis[fa * 2] == 0 &amp;&amp; vis[fa * 2 + 1] == 0) { pq.push(pii(a[fa], fa)); } } printf(&quot;%lld %lld\\n&quot;, res[0], res[1]); }","categories":[],"tags":[{"name":"HDU多校","slug":"HDU多校","permalink":"https://hsueh37.gitee.io/blog/tags/HDU%E5%A4%9A%E6%A0%A1/"}]},{"title":"支配树","slug":"支配树","date":"2019-08-07T03:40:00.000Z","updated":"2020-04-28T09:02:42.275Z","comments":true,"path":"2019/08/07/支配树/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/08/07/%E6%94%AF%E9%85%8D%E6%A0%91/","excerpt":"","text":"1. 定义1.1 DAG上的支配树作用：给定一个$DAG$，询问从起点到终点必经的点，即去掉这个点以及与这个点相连的边，无法到达终点(无向图概念中的割点)，可以建立支配树来求解 结构：树形结构，将图的起点作为根节点，每个节点都是到达根节点的必经点。 建图： 点$u$的在支配树上的父亲是所有能走到点$u$在支配树上的$LCA$，于是可以通过$O(nlogn)$复杂度通过倍增实现。 具体来说，通过拓扑排序得到拓扑序，对于每个点根据反向边的$LCA$得到该点的父亲，从而建立$DAG$上的支配树 2. 例题2.1 BZOJ-2815-[ZJOI2012]灾难模板题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010#define DEG 20struct Graph &#123; struct Edge &#123; int to, nxt; Edge() &#123;&#125; Edge(int _to, int _nxt) &#123; to = _to; nxt = _nxt; &#125; &#125; edge[N]; int head[N], tot; void Init() &#123; memset(head, -1, sizeof head); tot = 0; &#125; void addedge(int u, int v) &#123; edge[tot] = Edge(v, head[u]); head[u] = tot++; &#125;&#125; G[2], zp;int n;int fa[N][DEG], dep[N], du[N], sze[N];struct Tree &#123; int LCA(int u, int v) &#123; if (u == -1) &#123; return v; &#125; if (v == -1) &#123; return u; &#125; if (dep[u] &gt; dep[v]) &#123; swap(u, v); &#125; for (int det = dep[v] - dep[u], i = 0; det; det &gt;&gt;= 1, ++i) &#123; if (det &amp; 1) &#123; v = fa[v][i]; &#125; &#125; if (u == v) return u; for (int i = DEG - 1; i &gt;= 0; --i) &#123; if (fa[u][i] == fa[v][i]) &#123; continue; &#125; u = fa[u][i]; v = fa[v][i]; &#125; return fa[u][0]; &#125; void DFS(int u) &#123; sze[u] = 1; for (int i = zp.head[u]; ~i; i = zp.edge[i].nxt) &#123; int v = zp.edge[i].to; if (sze[v] == 0) &#123; DFS(v); &#125; sze[u] += sze[v]; &#125; &#125; void solve() &#123; queue&lt;int&gt; que; vector&lt;int&gt; Q; for (int i = 1; i &lt;= n; ++i) &#123; if (du[i] == 0) &#123; que.push(i); &#125; &#125; while (!que.empty()) &#123; int u = que.front(); que.pop(); Q.push_back(u); for (int i = G[0].head[u]; ~i; i = G[0].edge[i].nxt) &#123; int v = G[0].edge[i].to; --du[v]; if (du[v] == 0) &#123; que.push(v); &#125; &#125; &#125; for (int i = 0, len = Q.size(); i &lt; len; ++i) &#123; int u = Q[i]; int root = -1; for (int j = G[1].head[u]; ~j; j = G[1].edge[j].nxt) &#123; int v = G[1].edge[j].to; root = LCA(root, v); &#125; if (root == -1) &#123; root = 0; &#125; zp.addedge(root, u); fa[u][0] = root; dep[u] = dep[root] + 1; for (int j = 1; j &lt; DEG; ++j) &#123; if (fa[u][j - 1]) &#123; fa[u][j] = fa[fa[u][j - 1]][j - 1]; &#125; &#125; &#125; DFS(0); &#125;&#125; tree;int main() &#123; scanf(\"%d\", &amp;n); G[0].Init(), G[1].Init(), zp.Init(); for (int i = 1, x; i &lt;= n; ++i) &#123; while (~scanf(\"%d\", &amp;x) &amp;&amp; x) &#123; G[0].addedge(x, i); G[1].addedge(i, x); du[i]++; &#125; &#125; tree.solve(); for (int i = 1; i &lt;= n; ++i) &#123; printf(\"%d\\n\", sze[i] - 1); &#125; return 0;&#125;","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"https://hsueh37.gitee.io/blog/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"ACM-计算几何(基础)","slug":"ACM-计算几何(基础)","date":"2019-08-06T07:40:00.000Z","updated":"2020-04-28T09:02:42.264Z","comments":true,"path":"2019/08/06/ACM-计算几何(基础)/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/08/06/ACM-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95(%E5%9F%BA%E7%A1%80)/","excerpt":"","text":"1.准备知识1.1 起手式123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef double db;const db eps = 1e-8;const db PI = acos(-1.0);int sgn(db x) &#123; if (fabs(x) &lt; eps) &#123; return 0; &#125; else &#123; return x &gt; 0 ? 1 : -1; &#125;&#125;int main() &#123; db x = 0.4999; int fx = floor(x);//向下取整 int cx = ceil(x);//向上取整 int rx = round(x);//四舍五入 printf(\"%f %d %d %d\\n\", x, fx, cx, rx); //0.499900 0 1 0 return 0;&#125; 2. 点和向量2.1 点和向量的定义1234567891011struct Point &#123; db x, y; Point() &#123;&#125; Point(db _x, db _y) &#123; x = _x; y = _y; &#125;&#125;; 2.2 相关运算2.2.1 加法 点和向量相加得到另一个点 向量和向量相加得到另一个向量 1234Point operator+(const Point &amp;other) const &#123; return &#123;x + other.x, y + other.y&#125;;&#125; 2.2.2 减法 两点差得到一个向量 $A-B$得到向量$\\vec{BA}$ 1234Point operator-(const Point &amp;other) const &#123; return &#123;x - other.x, y - other.y&#125;;&#125; 2.2.3 乘法 缩放 1234Point operator*(const db &amp;other) const &#123; return &#123;x * other, y * other&#125;;&#125; 2.2.4 除法 缩放 1234Point operator/(const db &amp;other) const &#123; return &#123;x / other, y / other&#125;;&#125; 2.2.5 点积$\\alpha \\cdot \\beta = \\vert \\alpha \\vert \\cdot \\vert \\beta\\vert \\cdot cos\\theta$ 几何意义 若$\\alpha$与$\\beta$的夹角为锐角，则其点积为正 若$\\alpha$与$\\beta$的夹角为钝角，则其点积为负 若$\\alpha$与$\\beta$的夹角为支教，则其点积为0 向量$\\alpha$在$\\beta$上的投影长度和$\\beta$的长度乘积 1234db operator*(const Point &amp;other) const &#123; return x * other.x + y * other.y;&#125; 2.2.6 叉积$\\alpha \\cdot \\beta = \\vert \\alpha\\vert \\cdot \\vert \\beta\\vert \\cdot sin\\theta$ 几何意义： 若$\\beta$在$\\alpha$的逆时针方向，叉积为正 若$\\beta$在$\\alpha$的顺时针方向，叉积为负 若$\\beta$在$\\alpha$平行，叉积为0 向量$\\alpha$和向量$\\beta$形成的平行四边形的有向面积 1234db operator^(const Point &amp;other) const &#123; return x * other.y - y * other.x;&#125; 2.3 常用函数（成员函数）2.3.1 两点距离1234db distance(Point p) &#123; return hypot(x - p.x, y - p.y);&#125; 2.3.2 逆时针旋转90度1234Point rotleft() &#123; return &#123;-y, x&#125;;&#125; 2.3.3 顺时针旋转90度1234Point roright() &#123; return &#123;y, -x&#125;;&#125; 2.3.4 绕着点P逆时针旋转angle123456Point rotate(Point p, db angle) &#123; Point v = (*this) - p; db c = cos(angle), s = sin(angle); return &#123;p.x + v.x * c - v.y * s, p.y + v.x * s + v.y * c&#125;;&#125; 2.3.5 ToLeftTest 函数判断$\\vec{bc}$是不是想两$\\vec{ab}$的逆时针方向旋转 凸包 1234bool ToLeftTest(Point a, Point b, Point c) &#123; return ((b - a) ^ (c - b)) &gt; 0;&#125; 3. 点和线3.1 定义3.1.1直线定义直线定义一般由三种形式 $ax+by+c=0$一般式 $x_0+y_0+v_xt+v_yt=0$点向式 $y=kx+b$斜截式 3.1.2 点向式 P = P_o+vt用一个点加一个线段表示 3.1.2 构造方法1234567891011121314151617181920212223242526272829303132333435struct Line &#123; Point s, e; Line() &#123;&#125; Line(Point _s, Point _e) &#123; s = _s; e = _e; &#125; Line(Point p, db angle) &#123; s = p; if (sgn(angle - PI / 2) == 0) &#123; e = (s + Point(0, 1)); &#125; else &#123; e = (s + Point(1, tan(angle))); &#125; &#125; //ax + by + c = 0 Line(db a, db b, db c) &#123; if (sgn(a) == 0) &#123; s = Point(0, -c / b); e = Point(1, -c / b); &#125; else if (sgn(b) == 0) &#123; s = Point(-c / a, 0); e = Point(-c / a, 1); &#125; else &#123; s = Point(0, -c / b); e = Point(1, (-c - a) / b); &#125; &#125;&#125;; 3.1.2 常用函数3.1.2.1 点和直线的关系1234567891011//点和直线关系//1 在左侧//2 在右侧//3 在直线上int relation(Point p) &#123; int c = sgn((p - s) ^ (e - s)); if (c &lt; 0) return 1; else if (c &gt; 0) return 2; else return 3;&#125; 3.1.2.2 点在线段上的判断1234bool pointonseg(Point p) &#123; return sgn(((p - s) ^ (e - s))) == 0 &amp;&amp; sgn((p - s) * (p - e)) &lt;= 0;&#125; 3.1.2.2 向量平行判断1234bool parallel(Line v) &#123; return sgn((e - s) ^ (v.e - v.s)) == 0;&#125; 3.1.2.3 两线段相交判断123456789101112131415//2 规范相交//1 非规范相交//0 不相交int segcrossseg(Line v) &#123; int d1 = sgn((e - s) ^ (v.s - s)); int d2 = sgn((e - s) ^ (v.e - s)); int d3 = sgn((v.e - v.s) ^ (s - v.s)); int d4 = sgn((v.e - v.s) ^ (e - v.s)); if ((d1 ^ d2) == -2 &amp;&amp; (d3 ^ d4) == -2) return 2; return ((d1 == 0 &amp;&amp; sgn((v.s - s) * (v.s - e)) &lt;= 0) || (d2 == 0 &amp;&amp; sgn((v.e - s) * (v.e - e)) &lt;= 0) || (d3 == 0 &amp;&amp; sgn((s - v.s) * (s - v.e)) &lt;= 0) || (d4 == 0 &amp;&amp; sgn((e - v.s) * (e - v.e))) &lt;= 0);&#125; 3.1.2.4 直线和线段相交判断1234567891011//-*this line -v seg//2 规范相交//1 非规范相交//0 不相交int linecrossseg(Line v) &#123; int d1 = sgn((e - s) ^ (v.s - s)); int d2 = sgn((e - s) ^ (v.e - s)); if ((d1 ^ d2) == -2) return 2; return (d1 == 0 || d2 == 0);&#125; 3.1.2.5 两直线关系1234567891011//0 平行//1 重合//2 相交int linecrossline(Line v) &#123; if ((*this).parallel(v)) &#123; return v.relation(s) == 3; &#125; else &#123; return 2; &#125;&#125; 3.1.2.6 两直线交点123456Point crosspoint(Line v) &#123; db a1 = (v.e - v.s) ^(s - v.s); db a2 = (v.e - v.s) ^(e - v.s); return &#123;(s.x * a2 - e.x * a1) / (a1 - a1), (s.y * a2 - e.y * a1) / (a2 - a1)&#125;;&#125; 3.1.2.7 点到直线的距离1234db dispointtoline(Point p) &#123; return fabs((p - s) ^ (e - s)) / length();&#125; 3.1.2.8 点到线段的距离12345678db dispointtoseg(Point p) &#123; if (sgn((p - s) * (e - s)) &lt; 0 || sgn((p - e) * (s - e)) &lt; 0) &#123; return min(p.distance(e), p.distance(s)); &#125; else &#123; return dispointtoline(p); &#125;&#125; 3.1.2.9 线段到线段距离1234db dissegtoseg(Line v) &#123; return min(min(dispointtoseg(v.s), dispointtoseg(v.e)), min(v.dispointtoseg(s), v.dispointtoseg(e)));&#125; 3.1.2.10 点在直线上的投影1234Point lineprog(Point p) &#123; return s + (((e - s) * ((e - s) * (p - s))) / ((e - s).len2()));&#125; 3.1.2.11 点关于直线的对称点12345Point symmetrypoint(Point p) &#123; Point q = lineprog(p); return &#123;2 * q.x - p.x, 2 * q.y - p.y&#125;;&#125; 4. 多边形4.1 三角形4.1.1 三角形面积 利用两条边叉积 海伦公式 S = \\sqrt{p(p-a)(p-b)(p-c)}, p=\\frac{a+b+c}{2} $S = \\frac{absinC}{2}$ 4.2 其他多边形4.2.1 常用函数4.2.1.1 点和多边形的关系123456789101112131415161718192021222324252627// 3 点上// 2 边上// 1 内部// 0 外部int relationpoint(Point q) &#123; for (int i = 0; i &lt; n; ++i) &#123; if (p[i] == q) return 3; &#125; getline(); for (int i = 0; i &lt; n; ++i) &#123; if (l[i].pointonseg(q)) &#123; return 2; &#125; &#125; int cnt = 0; for (int i = 0; i &lt; n; ++i) &#123; int j = (i + 1) % n; int k = sgn((q - p[j]) ^ (p[i] - p[j])); int u = sgn(p[i].y - q.y); int v = sgn(p[j].y - q.y); if (k &gt; 0 &amp;&amp; u &lt; 0 &amp;&amp; v &gt;= 0) cnt++; if (k &lt; 0 &amp;&amp; v &lt; 0 &amp;&amp; u &gt;= 0) cnt++; &#125; return cnt != 0;&#125; 4.2.1.2 获取周长12345678db getcircumferenct() &#123; db sum = 0; for (int i = 0; i &lt; n; ++i) &#123; sum += p[i].distance(p[(i + 1) % n]); &#125; return sum;&#125; 4.2.1.3 获取面积12345678db getarea() &#123; db sum = 0; for (int i = 0; i &lt; n; ++i) &#123; sum += (p[i] ^ (p[(i + 1) % n])); &#125; return fabs(sum / 2);&#125; 4.2.1.4 获取重心1234567891011121314Point getbarycentre() &#123; Point ret = &#123;0, 0&#125;; db area = 0; for (int i = 1; i &lt; n - 1; ++i) &#123; db tmp = (p[i] - p[0]) ^(p[i + 1] - p[0]); if (sgn(tmp) == 0) continue; area += tmp; ret.x += (p[0].x + p[i].x + p[i + 1].x) / 3 * tmp; ret.y = (p[0].y + p[i].y + p[i + 1].y) / 3 * tmp; &#125; if (sgn(area)) ret = ret / area; return ret;&#125; 4.3 Pick定理4.3.1 内容皮克定理是指一个计算点阵中顶点在格点上的多边形面积公式该公式可以表示为 2S = 2a+b-2其中$a$表示多边形内部点数，$b$表示多边形边界上点数，$S$表示多边形面积","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"https://hsueh37.gitee.io/blog/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"Multi-University-Training-Contest-5","slug":"Multi-University-Training-Contest-5","date":"2019-08-06T03:40:00.000Z","updated":"2020-04-28T09:02:42.269Z","comments":true,"path":"2019/08/06/Multi-University-Training-Contest-5/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/08/06/Multi-University-Training-Contest-5/","excerpt":"","text":"B. three arrays题意：给出两个序列$a, b$,生成序列$c$,其中$c_i=a_i\\oplus b_i$，要求重新排列$a, b$，使得$c$字典序最小 思路：建立两颗$Trie$树，两指针分别在两颗$Trie$树上走，尽可能保证异或后为$0$，走$n$边后排序。对于$(0,0),(1,1)$谁先走，两对数只可能是不相同的两个数，所以顺序无所谓。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define N 200010 #define pii pair &lt;int, int&gt;#define fi first#define se secondint n, a[N], b[N], res[N];struct Trie &#123; struct node &#123; int son[2]; int tot; node() &#123; memset(son, -1, sizeof son); tot = 0; &#125; &#125;t[N * 32]; int cnt; void init() &#123; cnt = 1; t[1] = node(); &#125; void insert(int x, int y) &#123; int root = 1; for (int i = 30; i &gt;= 0; --i) &#123; int &amp;nx = t[root].son[(x &gt;&gt; i) &amp; 1]; if (nx == -1) &#123; nx = ++cnt; t[nx] = node(); &#125; root = nx; t[root].tot += y; &#125; &#125; void del(int x, int y) &#123; int root = 1; for (int i = 30; i &gt;= 0; --i) &#123; int nx = t[root].son[(x &gt;&gt; i) &amp; 1]; if (nx == -1) &#123; return; &#125; t[nx].tot -= y; root = nx; &#125; &#125; int query(int x) &#123; int root = 1; ll res = 0; for (int i = 30; i &gt;= 0; --i) &#123; int f = (x &gt;&gt; i) &amp; 1; int nx = t[root].son[f]; if (nx == -1 || t[nx].tot == 0) &#123; res |= (1 &lt;&lt; i); nx = t[root].son[!f]; &#125; root = nx; &#125; return res; &#125;&#125;trie[2];int Move[4][2] = &#123; 0, 0, 1, 1, 0, 1, 1, 0&#125;;int query() &#123; int num[2] = &#123;0, 0&#125;; int it[2] = &#123;1, 1&#125;; int nx[2]; for (int i = 30; i &gt;= 0; --i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; nx[0] = trie[0].t[it[0]].son[Move[j][0]]; nx[1] = trie[1].t[it[1]].son[Move[j][1]]; if (nx[0] != -1 &amp;&amp; nx[1] != -1 &amp;&amp; trie[0].t[nx[0]].tot &gt; 0 &amp;&amp; trie[1].t[nx[1]].tot &gt; 0) &#123; if (Move[j][0]) num[0] |= (1 &lt;&lt; i); if (Move[j][1]) num[1] |= (1 &lt;&lt; i); it[0] = nx[0]; it[1] = nx[1]; break; &#125; &#125; &#125; trie[0].del(num[0], 1); trie[1].del(num[1], 1); return num[0] ^ num[1];&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); trie[0].init(); trie[1].init(); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); trie[0].insert(a[i], 1); &#125; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", b + i); trie[1].insert(b[i], 1); &#125; for (int i = 1; i &lt;= n; ++i) &#123; res[i] = query(); &#125; sort(res + 1, res + 1 + n); for (int i = 1; i &lt;= n; ++i) printf(\"%d%c\", res[i], \" \\n\"[i == n]); &#125; return 0;&#125; D. equation题意：给出序列$a, b$以及整数$C$，求所有实数$x$使得$\\sum_{i=1}^n\\vert a_i\\cdot x+b_i\\vert=C$ 思路：根据每个绝对值取值为$0$可以将$x$划分为$n+1$个区间，在每个区间里都是一个线性方程，直接求解判断即可，注意无穷解的时候 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longll gcd(ll a, ll b) &#123; return b ? gcd(b, a % b) : a; &#125;struct frac&#123; ll x,y; void sim() &#123; ll g = gcd(abs(x), abs(y)); x /= g; y /= g; if (x * y == 0) &#123; x = 0; y = 1; &#125; if (x * y &lt; 0) &#123; x = -abs(x); y = abs(y); &#125; else &#123; x = abs(x); y = abs(y); &#125; &#125; frac() &#123;&#125; frac(ll x, ll y) : x(x), y(y) &#123;sim();&#125; frac operator+(const frac &amp;u)&#123; ll p, q; p = x * u.y + y * u.x; q = u.y * y; ll d = gcd(p, q); p /= d; q /= d; return (frac)&#123;p, q&#125;; &#125; frac operator-(const frac &amp;u)&#123; ll p, q; p = x * u.y - y * u.x; q = u.y * y; ll d = gcd(p, q); p /= d; q /= d; return (frac)&#123;p, q&#125;; &#125; frac operator*(const frac &amp;u)&#123; ll p, q; p = u.x * x; q = u.y * y; ll d = gcd(p, q); p /= d; q /= d; return (frac)&#123;p, q&#125;; &#125; frac operator/(const frac &amp;u)&#123; ll p, q; p = u.y * x; q = u.x * y; ll d = gcd(p,q); p /= d; q /= d; return (frac)&#123;p,q&#125;; &#125; bool operator &lt; (const frac &amp;other) const &#123; return x * other.y &lt; y * other.x; &#125; bool operator != (const frac &amp;other) const &#123; return x * other.y != y * other.x; &#125; bool operator &lt;= (const frac &amp;other) const &#123; return x * other.y &lt;= y * other.x; &#125; bool operator &gt;= (const frac &amp;other) const &#123; return x * other.y &gt;= y * other.x; &#125; bool operator == (const frac &amp;other) const &#123; return x * other.y == y * other.x; &#125; void sqr() &#123; *this = (*this) * (*this); &#125; void print()&#123; sim(); if (x * y &lt; 0) putchar('-'); printf(\"%lld/%lld\", abs(x), abs(y)); &#125;&#125;;const int N = 2e5 + 10;int n;ll C;struct node &#123; int a, b; frac x; void scan() &#123; scanf(\"%d%d\", &amp;a, &amp;b); x = frac(-b, a); &#125; bool operator &lt; (const node &amp;other) const &#123; return x &lt; other.x; &#125;&#125;a[N];frac res[N &lt;&lt; 1]; int cnt = 0; void solve() &#123; cnt = 0; ll suma[2] = &#123;0, 0&#125;, sumb[2] = &#123;0, 0&#125;; for (int i = 1; i &lt;= n; ++i) &#123; suma[1] += a[i].a; sumb[1] += a[i].b; &#125; for (int i = 1, j; i &lt; n; i = j + 1) &#123; for (j = i; j &lt; n; ++j) &#123; if (a[i].x != a[j + 1].x) break; &#125; j = min(j, n - 1); for (int k = i; k &lt;= j; ++k) &#123; suma[1] -= a[k].a; sumb[1] -= a[k].b; suma[0] += a[k].a; sumb[0] += a[k].b; &#125; if (suma[0] - suma[1] == 0 &amp;&amp; sumb[0] - sumb[1] == C) &#123; puts(\"-1\"); return; &#125; if (suma[1] == suma[0]) continue; frac x = frac(C - sumb[0] + sumb[1], suma[0] - suma[1]); if (x &gt;= a[i].x) &#123; if (j + 1 &lt; n) &#123; if (x &lt; a[j + 1].x) &#123; res[++cnt] = x; &#125; &#125; else &#123; res[++cnt] = x; &#125; &#125; &#125; sort(res + 1, res + 1 + cnt); cnt = unique(res + 1, res + 1 + cnt) - res - 1; printf(\"%d\", cnt); for (int i = 1; i &lt;= cnt; ++i) &#123; putchar(' '); res[i].print(); &#125; puts(\"\");&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%lld\", &amp;n, &amp;C); for (int i = 1; i &lt;= n; ++i) a[i].scan(); ++n; a[n].a = a[n].b = 0; a[n].x = frac(-2e9, 1); sort(a + 1, a + 1 + n); ++n; a[n].a = a[n].b = 0; a[n].x = frac(2e9, 1); solve(); &#125; return 0; &#125;// E. permutation 1题意：构造一个长度为$n$的排列，使得差分排列是第$k$小 思路：枚举每一位放什么，并且记录后续有多少个值，贪心构造 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;#define N 50#define ll long longint n, k, a[N], vis[N];ll fac[N];bool check(int x, int now) &#123; for (int i = 1; i &lt;= n; ++i) vis[i] = 0; vis[now] = 1; for (int i = 1; i &lt;= x; ++i) &#123; int nx = now + a[i]; if (nx &lt; 1 || nx &gt; n) return 0; if (vis[nx]) return 0; vis[nx] = 1; now = nx; &#125; return 1;&#125;ll work(int x) &#123; ll res = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (check(x, i)) &#123; res += fac[n - x - 1]; &#125; &#125; return res;&#125;void out() &#123; for (int i = 1; i &lt;= n; ++i) &#123; if (check(n - 1, i)) &#123; vector &lt;int&gt; vec; int now = i; vec.push_back(now); for (int j = 1; j &lt; n; ++j) &#123; now += a[j]; vec.push_back(now); &#125; for (int j = 0; j &lt; n; ++j) printf(\"%d%c\", vec[j], \" \\n\"[j == n - 1]); return; &#125; &#125;&#125;int main() &#123; fac[0] = 1; for (int i = 1; i &lt;= 20; ++i) fac[i] = fac[i - 1] * i; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt; n; ++i) &#123; ll tot = 0, now = 0; for (int j = -n + 1; j &lt; n; ++j) &#123; a[i] = j; now = work(i); if (tot + now &gt;= k) &#123; k -= tot; break; &#125; else &#123; tot += now; &#125; &#125; &#125; out(); &#125; return 0;&#125; F. string matching题意：询问$\\forall i \\in [0, len - 1]$中$s[i \\cdots len - 1]$与$s[0 \\cdots len - 1]$的暴力求$lcp$过程需要比较多少次。 思路：$ExKmp$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define N 1000010char s[N], t[N];struct ExKMP &#123; int Next[N]; int extend[N]; //下标从1开始 void get_Next(char *s) &#123; int lens = strlen(s + 1), p = 1, pos; //Next[1]要特殊考虑 Next[1] = lens; while (p + 1 &lt;= lens &amp;&amp; s[p] == s[p + 1]) ++p; //Next[2]初始化 Next[pos = 2] = p - 1; for (int i = 3; i &lt;= lens; ++i) &#123; int len = Next[i - pos + 1]; //第一种情况 if (len + i &lt; p + 1) Next[i] = len; //第二种情况 else &#123; //找到对于子串最靠后已经匹配的位置 int j = max(p - i + 1, 0); //暴力匹配 while (i + j &lt;= lens &amp;&amp; s[j + 1] == s[i + j]) ++j; p = i + (Next[pos = i] = j) - 1; &#125; &#125; &#125; void work(char *s, char *t) &#123; get_Next(t); int lens = strlen(s + 1), lent = strlen(t + 1), p = 1, pos; while (p &lt;= lent &amp;&amp; s[p] == t[p]) ++p; p = extend[pos = 1] = p - 1; for (int i = 2; i &lt;= lens; ++i) &#123; int len = Next[i - pos + 1]; if (len + i &lt; p + 1) extend[i] = len; else &#123; int j = max(p - i + 1, 0); while (i + j &lt;= lens &amp;&amp; j &lt;= lent &amp;&amp; t[j + 1] == s[i + j]) ++j; p = i + (extend[pos = i] = j) - 1; &#125; &#125; &#125;&#125;exkmp;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%s\", s + 1); int len = strlen(s + 1); for (int i = 1; i &lt;= len; ++i) t[i] = s[i]; t[len + 1] = 0; exkmp.work(s, t); ll res = 0; for (int i = 2; i &lt;= len; ++i) &#123; ll t = exkmp.extend[i]; if (len - i + 1 &gt; t) ++t; res += t; &#125; printf(\"%lld\\n\", res); &#125; return 0;&#125;// G. permutation 2题意：问有多少$n$个数的排列满足下列要求： $p_1 = x$ $p_n = y$ $\\forall i \\in [1, n - 1]$都满足$|p_i - p_{i + 1}| \\leq 2$ 思路:最终序列必定是$x,x-2\\cdots x-1,x+1 \\cdots y-1,y+1\\cdots y+2,y $我们假设$x-2\\cdots x-1$的排列有$p1$种，$y+1\\cdots y+2$有$p_2$种，$x+1\\cdots y-1$有$p_3$种，很显然，$p_1,p_2$均只有$1$种，对于$p_3$通过暴力打表发现满足序列$f[n]=f[n-1]+f[n-3]$其中$n$为长度，然后特判即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll p = 998244353;#define N 100010int n, x, y;ll a[N];void Init() &#123; a[0] = a[1] = a[2] = 1; for (int i = 3; i &lt; N; ++i) &#123; a[i] = (a[i - 1] + a[i - 3]) % p; &#125;&#125;int main() &#123; Init(); int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d %d %d\", &amp;n, &amp;x, &amp;y); if (x == 1 &amp;&amp; y == n) &#123; printf(\"%lld\\n\", a[y - x]); continue; &#125; if (x == 1 || y == n) &#123; printf(\"%lld\\n\", a[y - x - 1]); continue; &#125; if (y - x != 1) &#123; printf(\"%lld\\n\", a[y - x - 2]); &#125; else &#123; if (x == 1) &#123; puts(\"1\"); &#125; else &#123; puts(\"0\"); &#125; &#125; &#125; return 0;&#125; H. line symmetric题意：给出一个简单多边形，问至多修改一个点，满足整个简单多边形是边对称简单多边形 思路：暴力枚举每对相邻，间隔一个的点对的中垂线最为对称点，$O(n)$的去$check$. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 2010int n;int sgn(ll x) &#123; if (x == 0) return 0; else return x &gt; 0 ? 1 : -1;&#125;struct Point &#123; ll x, y; Point() &#123;&#125; Point(ll _x, ll _y) &#123; x = _x; y = _y; &#125; void input() &#123; scanf(\"%lld %lld\", &amp;x, &amp;y); x &lt;&lt;= 1; y &lt;&lt;= 1; &#125; Point operator+(const Point &amp;other) const &#123; return &#123;x + other.x, y + other.y&#125;; &#125; Point operator-(const Point &amp;other) const &#123; return &#123;x - other.x, y - other.y&#125;; &#125; ll operator*(const Point &amp;other) const &#123; return x * other.x + y * other.y; &#125; Point operator/(const ll &amp;other) const &#123; return &#123;x / other, y / other&#125;; &#125; ll operator^(const Point &amp;other) const &#123; return x * other.y - y * other.x; &#125;&#125; P[N];bool Add(Point p[2], Point V[2], int num[2], int pos[2], int &amp;now, Point p1, Point p2, int i) &#123; if (now == 0) &#123; p[now] = (p1 + p2) / 2; V[now++] = &#123;p2.y - p1.y, p1.x - p2.x&#125;; num[0] = 1; pos[0] = i; &#125; else &#123; if (((((p1 + p2) / 2) - p[0]) ^ V[0]) != 0 || ((p1 - p2) * V[0]) || (Point(p2.y - p1.y, p1.x - p2.x) * V[0]) &lt; 0) &#123; if (now == 1) &#123; p[now] = (p1 + p2) / 2; V[now++] = &#123;p2.y - p1.y, p1.x - p2.x&#125;; num[1] = 1; pos[1] = i; &#125; else &#123; if (((((p1 + p2) / 2) - p[1]) ^ V[1]) != 0 || ((p1 - p2) * V[1]) || (Point(p2.y - p1.y, p1.x - p2.x) * V[1]) &lt; 0) &#123; return false; &#125; else &#123; num[1]++; &#125; &#125; &#125; else &#123; num[0]++; &#125; &#125; return true;&#125;bool check1(Point p[]) &#123; Point X[2], V[2]; int num[2] = &#123;0, 0&#125;, pos[2] = &#123;0, 0&#125;, now = 0, i; for (i = 1; i &lt; n - i; ++i) &#123; if (!Add(X, V, num, pos, now, p[i], p[n - i], i)) &#123; return false; &#125; &#125; if (now == 1) &#123; int cnt = 0; if ((p[0] - X[0]) ^ V[0]) &#123; ++cnt; &#125; if (i == n - i) &#123; if ((p[i] - X[0]) ^ V[0]) &#123; ++cnt; &#125; &#125; return cnt &lt; 2; &#125; int cnt = 0; for (int o = 0; o &lt; 2; ++o) &#123; if (num[o] != 1) continue; cnt = 0; if ((p[0] - X[o ^ 1]) ^ V[o ^ 1]) &#123; cnt++; &#125; if (i == n - i) &#123; if ((p[i] - X[o ^ 1]) ^ V[o ^ 1]) &#123; ++cnt; &#125; &#125; if (cnt == 0) &#123; int j = (pos[o] == 1) ? 2 : 1; if ((sgn((p[j] - X[o ^ 1]) ^ V[o ^ 1]) == sgn((p[pos[o]] - X[o ^ 1]) ^ V[o ^ 1])) || sgn((p[n - j] - X[o ^ 1]) ^ V[o ^ 1]) == sgn((p[n - pos[o]] - X[o ^ 1]) ^ V[o ^ 1])) &#123; return true; &#125; &#125; &#125; return false;&#125;bool check2(Point p[]) &#123; Point X[2], V[2]; int num[2] = &#123;0, 0&#125;, pos[2] = &#123;0, 0&#125;, now = 0, i; for (i = 0; i &lt; n - 1 - i; ++i) &#123; if (!Add(X, V, num, pos, now, p[i], p[n - 1 - i], i)) &#123; return false; &#125; &#125; if (now == 1) &#123; return true; &#125; for (int o = 0; o &lt; 2; ++o) &#123; if (num[o] == 1) &#123; int j = (pos[o] == 0) ? 1 : 0; if (sgn((p[j] - X[o]) ^ V[o]) == sgn((p[pos[o ^ 1]] - X[o]) ^ V[o]) || sgn((p[n - 1 - j] - X[o]) ^ V[o]) == sgn((p[n - 1 - pos[o ^ 1]] - X[o]) ^ V[o])) &#123; return true; &#125; &#125; &#125; return false;&#125;bool solve() &#123; for (int i = 0; i &lt; n; ++i) &#123; if (check1(P + i)) &#123; return true; &#125; &#125; if (n % 2 == 0) &#123; for (int i = 0; i &lt; n; ++i) &#123; if (check2(P + i)) &#123; return true; &#125; &#125; &#125; return false;&#125;int main() &#123;// freopen(\"input.txt\", \"r\", stdin) int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; ++i) &#123; P[i].input(); P[i + n] = P[i]; &#125; if (n &lt; 5) &#123; puts(\"Y\"); continue; &#125; puts(solve() ? \"Y\" : \"N\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"HDU多校","slug":"HDU多校","permalink":"https://hsueh37.gitee.io/blog/tags/HDU%E5%A4%9A%E6%A0%A1/"}]},{"title":"2019牛客暑期多校训练营（第六场）","slug":"2019牛客暑期多校训练营（第六场）","date":"2019-08-03T13:30:00.000Z","updated":"2020-04-28T09:02:42.263Z","comments":true,"path":"2019/08/03/2019牛客暑期多校训练营（第六场）/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/08/03/2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E5%85%AD%E5%9C%BA%EF%BC%89/","excerpt":"","text":"A. Garbage Classification签到 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;#define N 2010char s[N], t[N], mp[N];int main() &#123; int T; scanf(\"%d\", &amp;T); for (int kase = 1; kase &lt;= T; ++kase) &#123; printf(\"Case #%d: \", kase); scanf(\"%s%s\", s + 1, t); for (int i = 0; i &lt; 26; ++i) &#123; mp['a' + i] = t[i]; &#125; int d = 0, w = 0, h = 0; int len = strlen(s + 1); for (int i = 1; i &lt;= len; ++i) &#123; int c = mp[s[i]]; if (c == 'w') ++w; else if (c == 'd') ++d; else ++h; &#125; if (h * 4 &gt;= len) &#123; puts(\"Harmful\"); &#125; else if (h * 10 &lt;= len) &#123; puts(\"Recyclable\"); &#125; else if (d &gt;= w * 2) &#123; puts(\"Dry\"); &#125; else &#123; puts(\"Wet\"); &#125; &#125; return 0;&#125; B. Shorten IPv6 Address模拟 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define N 1010char s[N];int a[8];vector &lt;string&gt; res;string f(int x) &#123; string res = \"\"; if (!x) return \"0\"; while (x) &#123; int y = x % 16; if (y &lt; 10) res += y + '0'; else if (y == 10) res += 'a'; else if (y == 11) res += 'b'; else if (y == 12) res += 'c'; else if (y == 13) res += 'd'; else if (y == 14) res += 'e'; else res += 'f'; x /= 16; &#125; reverse(res.begin(), res.end()); return res;&#125;int main() &#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int T; cin &gt;&gt; T; for (int kase = 1; kase &lt;= T; ++kase) &#123; cout &lt;&lt; \"Case #\" &lt;&lt; kase &lt;&lt; \": \"; cin &gt;&gt; (s + 1); int len = 128; for (int i = 1; i &lt;= len; i += 16) &#123; int num = 0; for (int j = i; j &lt; i + 16; ++j) &#123; num = num * 2 + s[j] - '0'; &#125; a[i / 16] = num; &#125; res.clear(); string str = f(a[0]); for (int i = 1; i &lt; 8; ++i) &#123; str += \":\"; str += f(a[i]); &#125; res.push_back(str); string tmp = \"\"; for (int i = 0; i &lt; 8; ++i) &#123; string now = tmp; now += \":\"; int j = i; for (; j &lt; 8; ++j) &#123; if (a[j]) break; &#125; for (int k = j; k &lt; 8; ++k) &#123; now += \":\"; now += f(a[k]); &#125; if (j &gt;= 8) now += \":\"; if (j &gt; i + 1) res.push_back(now); if (i) tmp += \":\"; tmp += f(a[i]); &#125; sort(res.begin(), res.end(), [](string x, string y)&#123; if (x.length() != y.length()) return x.length() &lt; y.length(); return x &lt; y; &#125;); cout &lt;&lt; res[0] &lt;&lt; \"\\n\"; &#125; return 0;&#125; C. Palindrome Mouse题意：询问有多少对不同的$(a,b)$满足$a,b$都是回文串且$a$是$b$的子串 思路：回文树 12 D. Move题意：有$n$个物品，每个物品体积为$V_i$，有$K$个体积相同的盒子，要求满足规则下的盒子体积最大值 一个盒子装不下了才能装另一个 每次选取能装进去的最大的物品，直到装不下 思路：枚举 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1010#define INF 0x3f3f3f3fint n, k, a[N];int check(int x) &#123; int sum = 0; int box = 0; multiset &lt;int&gt; se; for (int i = 1; i &lt;= n; ++i) &#123; se.insert(a[i]); sum += a[i]; &#125; for (int i = 1; i &lt;= k; ++i) &#123; int remind = x; while (!se.empty()) &#123; auto pos = se.upper_bound(remind); if (pos != se.begin()) &#123; --pos; remind -= (*pos); sum -= (*pos); se.erase(pos); &#125; else &#123; break; &#125; &#125; box += remind; if (se.empty()) return -INF; &#125; return sum - box;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); for (int kase = 1; kase &lt;= T; ++kase) &#123; printf(\"Case #%d: \", kase); scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); for (int i = 1; ; ) &#123; int x = check(i); if (x == -INF) &#123; printf(\"%d\\n\", i); break; &#125; else &#123; i += max(1, x / k + (x % k != 0)); &#125; &#125; &#125; return 0;&#125; E. Androgynos题意：构造$n$阶自补图，如果没有则输出$NO$，否则输出邻接矩阵 思路： $n$阶自补图存在当且仅当$n=4\\cdot k $或者$n=4\\cdot k+1$ 对于一个长度为四的的自补图，可以通过构造一条链$X-Y-Z-W$，他的补图为$Y-W-X-Z$ 考虑两个自补图合并，只需要$X,W$与其余点相连，就可以形成新的自补图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;#define N 2010int n;int G[N][N];int ans[N];int main() &#123;// freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); for (int cas = 1; cas &lt;= T; ++cas) &#123; printf(\"Case #%d: \", cas); scanf(\"%d\", &amp;n); if (n % 4 == 2 || n % 4 == 3) &#123; puts(\"No\"); continue; &#125; memset(G, 0, sizeof G); puts(\"Yes\"); if (n % 4 == 0) &#123; for (int i = 1; i &lt;= n; i += 4) &#123; int x = i, y = i + 1, z = i + 2, w = i + 3; ans[x] = y; ans[y] = w; ans[z] = x; ans[w] = z; G[x][y] = G[y][x] = 1; G[y][z] = G[z][y] = 1; G[z][w] = G[w][z] = 1; for (int j = 1; j &lt; i; ++j) &#123; G[x][j] = G[j][x] = 1; G[w][j] = G[j][w] = 1; &#125; &#125; &#125; else if (n % 4 == 1) &#123; ans[1] = 1; for (int i = 2; i &lt;= n; i += 4) &#123; int x = i, y = i + 1, z = i + 2, w = i + 3; ans[x] = y; ans[y] = w; ans[z] = x; ans[w] = z; G[x][y] = G[y][x] = 1; G[y][z] = G[z][y] = 1; G[z][w] = G[w][z] = 1; for (int j = 1; j &lt; i; ++j) &#123; G[x][j] = G[j][x] = 1; G[w][j] = G[j][w] = 1; &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; printf(\"%d\", G[i][j]); &#125; puts(\"\"); &#125; for (int i = 1; i &lt;= n; ++i) &#123; printf(\"%d%c\", ans[i], \" \\n\"[i == n]); &#125; &#125; return 0;&#125; G. Is Today Friday?题意：用字母代替数字，输出最小的方案，要求每个日期都合法且每个日期都是周五 思路：暴力 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;bits/stdc++.h&gt;#include &lt;random&gt;using namespace std;#define N 100010int days[] = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;bool isLeap(int year) &#123; return (year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0;&#125;int n;string s[N];int a[10];int getDay(int year, int month) &#123; if (month == 2) &#123; return days[2] + isLeap(year); &#125; else &#123; return days[month]; &#125;&#125;int week(int y, int m, int d) &#123; int ans; if (m == 1 || m == 2) m += 12, y--; if ((y &lt; 1752) || (y == 1752 &amp;&amp; m &lt; 9) || (y == 1752 &amp;&amp; m == 9 &amp;&amp; d &lt; 3)) &#123; ans = (d + 2 * m + 3 * (m + 1) / 5 + y + y / 4 + 5) % 7; &#125; else &#123; ans = (d + 2 * m + 3 * (m + 1) / 5 + y + y / 4 - y / 100 + y / 400) % 7; &#125; ans = (d + 2 * m + 3 * (m + 1) / 5 + y + y / 4 - y / 100 + y / 400) % 7; return ans + 1;&#125;bool check(int idx) &#123; int y = 0, m = 0, d = 0; for (int i = 0; i &lt; 4; i++) y = y * 10 + a[s[idx][i] - 'A']; for (int i = 5; i &lt; 7; i++) m = m * 10 + a[s[idx][i] - 'A']; for (int i = 8; i &lt; 10; i++) d = d * 10 + a[s[idx][i] - 'A']; if (y &lt; 1600) return false; if (m &lt; 1 || m &gt; 12) return false; if (d &lt; 1 || d &gt; getDay(y, m)) return false; return week(y, m, d) == 5;&#125;void solve() &#123; sort(s + 1, s + 1 + n); n = unique(s + 1, s + 1 + n) - s - 1; shuffle(s + 1, s + 1 + n, std::mt19937(std::random_device()())); for (int i = 0; i &lt; 10; ++i) &#123; a[i] = i; &#125; do &#123; bool flag = true; for (int i = 1; i &lt;= n; ++i) &#123; if (!check(i)) &#123; flag = false; break; &#125; &#125; if (flag) &#123; for (int i : a) &#123; cout &lt;&lt; i; &#125; cout &lt;&lt; \"\\n\"; return; &#125; &#125; while (next_permutation(a, a + 10)); cout &lt;&lt; \"Impossible\\n\";&#125;int main() &#123;// freopen(\"input.txt\", \"r\", stdin); ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); int T; cin &gt;&gt; T; for (int cas = 1; cas &lt;= T; ++cas) &#123; cout &lt;&lt; \"Case #\" &lt;&lt; cas &lt;&lt; \": \"; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; s[i]; &#125; solve(); &#125; return 0;&#125; J. Upgrading Technology题意：有$n$个技能，$m$个等级，每个技能从$j-1$升级到$j$需要消耗$C_{ij}$，如果所有技能到达了$j$，则可以获得$d_j$，求最大收益： 思路：求前缀和的后缀最大值，枚举$i$作为最低等级$j$的值，取$MAX$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 1010#define INFLL 0x3f3f3f3f3f3f3f3fint n, m;ll a[N][N], b[N];ll f[N][N], g[N], f2[N][N];int main() &#123;// freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); for (int cas = 1; cas &lt;= T; ++cas) &#123; printf(\"Case #%d: \", cas); scanf(\"%d %d\", &amp;n, &amp;m); memset(f, 0, sizeof f); memset(f2, 0, sizeof f2); memset(g, 0, sizeof g); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; scanf(\"%lld\", &amp;a[i][j]); &#125; &#125; for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%lld\", b + i); g[i] = g[i - 1] + b[i]; &#125; ll ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; f[i][j] = f[i][j - 1] - a[i][j]; f2[i][j] = f2[i][j - 1] - a[i][j]; &#125; for (int j = m; j &gt;= 0; --j) &#123; if (j + 1 &lt;= m) &#123; f[i][j] = max(f[i][j], f[i][j + 1]); &#125; &#125; &#125; for (int j = m; j &gt;= 0; --j) &#123; ll tmp = 0; for (int i = 1; i &lt;= n; ++i) &#123; tmp += f[i][j]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; ans = max(ans, tmp - f[i][j] + f2[i][j] + g[j]); &#125; &#125; printf(\"%lld\\n\", ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"2019牛客多校","slug":"2019牛客多校","permalink":"https://hsueh37.gitee.io/blog/tags/2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"}]},{"title":"2019牛客暑期多校训练营（第五场）","slug":"2019牛客暑期多校训练营（第五场）","date":"2019-08-01T13:30:00.000Z","updated":"2020-04-28T09:02:42.262Z","comments":true,"path":"2019/08/01/2019牛客暑期多校训练营（第五场）/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/08/01/2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%BA%94%E5%9C%BA%EF%BC%89/","excerpt":"","text":"A. digits 2题意：输出一个数，使得数位和整除$n$，整个数整除$n$ 思路：输出$n$个$n$。 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int n;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; printf(\"%d\", n); &#125; puts(\"\"); &#125; return 0;&#125; B. generator 1题意：$X_i=a\\cdot X_{i-1}+b\\cdot X_{i-2} \\% mod$，输出第$n$项 思路：十进制快速幂 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 1000010ll x0, x1, a, b, mod;char str[N];void add(ll &amp;x, ll y) &#123; x += y; if (x &gt;= mod) &#123; x -= mod; &#125;&#125;struct Matrix &#123; ll a[2][2]; Matrix() &#123; memset(a, 0, sizeof a); &#125; inline void set() &#123; a[0][0] = a[1][1] = 1; &#125; inline Matrix operator*(const Matrix &amp;other) const &#123; Matrix res = Matrix(); for (int i = 0; i &lt; 2; ++i) &#123; for (int j = 0; j &lt; 2; ++j) &#123; for (int k = 0; k &lt; 2; ++k) &#123; add(res.a[i][j], a[i][k] * other.a[k][j] % mod); &#125; &#125; &#125; return res; &#125;&#125; base, res;inline Matrix qpow(Matrix base, ll n) &#123; Matrix res = Matrix(); res.set(); while (n) &#123; if (n &amp; 1) &#123; res = res * base; &#125; base = base * base; n &gt;&gt;= 1; &#125; return res;&#125;void solve() &#123; base = Matrix(); res = Matrix(); res.set(); base.a[0][0] = a; base.a[1][0] = 1; base.a[0][1] = b; for (int i = strlen(str + 1); i &gt;= 1; --i) &#123; if (str[i] != '0') &#123; res = res * qpow(base, str[i] - '0'); &#125; base = qpow(base, 10); &#125; ll ans = res.a[1][0] * x1 % mod + res.a[1][1] * x0 % mod; ans %= mod; printf(\"%lld\\n\", ans);&#125;int main() &#123; scanf(\"%lld %lld %lld %lld\", &amp;x0, &amp;x1, &amp;a, &amp;b); scanf(\"%s %lld\", str + 1, &amp;mod); solve(); return 0; G. subsequence 1题意：给出两个串$S, T$，问$S$有多少个子序列在数值上大于$T$ 思路：通过简单$dp$转移得到长度相同时候的字符串数量，在通过组合数得到长度大于$T$串时的数量，相加即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define N 3010const ll p = 998244353;int n, m;char s[N], t[N];ll dp[N][2];void add(ll &amp;x, ll y) &#123; x += y; if (x &gt;= p) x -= p;&#125;ll qmod(ll base, ll n) &#123; ll res = 1; while (n) &#123; if (n &amp; 1) &#123; res = res * base % p; &#125; base = base * base % p; n &gt;&gt;= 1; &#125; return res;&#125;ll fac[N], inv[N];ll C(int n, int m) &#123; return fac[n] * inv[m] % p * inv[n - m] % p;&#125;int main() &#123; fac[0] = 1; for (int i = 1; i &lt; N; ++i) fac[i] = fac[i - 1] * i % p; inv[N - 1] = qmod(fac[N - 1], p - 2); for (int i = N - 1; i &gt;= 1; --i) inv[i - 1] = inv[i] * i % p; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d%d\", &amp;n, &amp;m); scanf(\"%s%s\", s + 1, t + 1); for (int i = 0; i &lt;= n; ++i) &#123; dp[i][0] = dp[i][1] = 0; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = m - 1; j &gt;= 1; --j) &#123; ll f; if (s[i] == t[j + 1]) &#123; f = dp[j][1]; add(dp[j + 1][1], f); &#125; else if (s[i] &gt; t[j + 1]) &#123; f = dp[j][1]; add(dp[j + 1][0], f); &#125; f = dp[j][0]; add(dp[j + 1][0], f); &#125; if (s[i] != '0') &#123; if (s[i] == t[1]) &#123; add(dp[1][1], 1); &#125; else if (s[i] &gt; t[1]) &#123; add(dp[1][0], 1); &#125; &#125; &#125; ll res = dp[m][0]; for (int i = 1; i &lt;= n; ++i) &#123; if (s[i] != '0') &#123; int tot = n - i; for (int j = m + 1; j &lt;= n - i + 1; ++j) &#123; add(res, C(tot, j - 1)); &#125; &#125; &#125; printf(\"%lld\\n\", res); &#125; return 0;&#125; H. subsequence 2题意：问是否存在一个串满足指定关系 思路：对于一个关系，每个字符都像后面字符连边，拓扑排序即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1000010int n, m, id;vector &lt;vector&lt;int&gt;&gt; G;int st[N], d[N];char mp[N], s[N];int num[N], x, y;int ord[N], cnt;void Toposort() &#123; cnt = 0; queue &lt;int&gt; q; for (int i = 1; i &lt;= id; ++i) &#123; if (d[i] == 0) q.push(i); &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); ord[++cnt] = u; for (auto v : G[u]) &#123; if (--d[v] == 0) &#123; q.push(v); &#125; &#125; &#125; if (cnt == id &amp;&amp; id == n) &#123; for (int i = 1; i &lt;= id; ++i) putchar(mp[ord[i]]); puts(\"\"); &#125; else &#123; puts(\"-1\"); &#125;&#125;int main() &#123; while (scanf(\"%d%d\", &amp;n, &amp;m) != EOF) &#123; id = 0; G.clear(); G.resize(N); memset(st, -1, sizeof st); memset(num, -1, sizeof num); memset(d, 0, sizeof d); int len, cntx, cnty; bool F = 1; for (int i = 1; i &lt;= (m * (m - 1)) / 2; ++i) &#123; scanf(\" %s %d \", s, &amp;len); x = s[0], y = s[1]; if (len) &#123; scanf(\"%s\", s + 1); &#125; cntx = cnty = 0; for (int i = 1; i &lt;= len; ++i) &#123; if (s[i] == x) &#123; ++cntx; &#125; else &#123; ++cnty; &#125; &#125; if (num[x] == -1) &#123; num[x] = cntx; &#125; else if (num[x] != cntx) &#123; F = 0; &#125; if (num[y] == -1) &#123; num[y] = cnty; &#125; else if (num[y] != cnty) &#123; F = 0; &#125; if (len == 0) continue; if (st[x] == -1) &#123; for (int i = 1; i &lt;= cntx; ++i) &#123; mp[++id] = x; if (i &gt; 1) &#123; G[id - 1].push_back(id); ++d[id]; &#125; else &#123; st[x] = id; &#125; &#125; &#125; if (st[y] == -1) &#123; for (int i = 1; i &lt;= cnty; ++i) &#123; mp[++id] = y; if (i &gt; 1) &#123; G[id - 1].push_back(id); ++d[id]; &#125; else &#123; st[y] = id; &#125; &#125; &#125; int posx = st[x], posy = st[y]; --posx, --posy; if (s[1] == x) ++posx; else if (s[1] == y) ++posy; else F = 0; for (int i = 2; i &lt;= len; ++i) &#123; if (s[i] != x &amp;&amp; s[i] != y) &#123; F = 0; break; &#125; if (s[i] == x) &#123; ++posx; if (posy &gt;= st[y]) &#123; G[posy].push_back(posx); ++d[posx]; &#125; &#125; else &#123; ++posy; if (posx &gt;= st[x]) &#123; G[posx].push_back(posy); ++d[posy]; &#125; &#125; &#125; &#125; if (F &amp;&amp; id == n) &#123; Toposort(); &#125; else &#123; puts(\"-1\"); &#125; &#125; return 0;&#125; I. three points 1题意：找三个点$X, Y, Z$，这三个点在矩形中并且$dis(X, Y)=a,dis(X, Z)=b, dis(Y, Z)=c $ 思路：如果是线段，则在对角线上即可。 考虑是三角形，必定可以通过平移导致一个点在矩形的四个角，一个点在矩形的线段上，枚举模拟即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595#include &lt;bits/stdc++.h&gt;using namespace std;typedef double db;const db eps = 1e-8;int sgn(db x) &#123; if (fabs(x) &lt; eps) &#123; return 0; &#125; else &#123; return x &gt; 0 ? 1 : -1; &#125;&#125;struct Point &#123; db x, y; Point() &#123;&#125; Point(db x, db y) : x(x), y(y) &#123;&#125; db distance(Point p) &#123; return hypot(x - p.x, y - p.y); &#125; db len() &#123; return hypot(x, y); &#125; Point operator+(const Point &amp;b) const &#123; return Point(x + b.x, y + b.y); &#125; Point operator-(const Point &amp;b) const &#123; return Point(x - b.x, y - b.y); &#125; Point trunc(db r) &#123; db l = len(); if (!sgn(l)) return *this; r /= l; return Point(x * r, y * r); &#125; Point rotleft() &#123; return Point(-y, x); &#125; Point rotright() &#123; return Point(y, -x); &#125;&#125; X, Y, Z, p[2];struct Circle &#123; Point p; db r; Circle() &#123;&#125; Circle(Point _p, db _r) &#123; p = _p; r = _r; &#125; int relationcircle(Circle v) &#123; db d = p.distance(v.p); if (sgn(d - r - v.r) &gt; 0) return 5; if (sgn(d - r - v.r) == 0) return 4; db l = fabs(r - v.r); if (sgn(d - r - v.r) &lt; 0 &amp;&amp; sgn(d - l) &gt; 0) return 3; if (sgn(d - l) == 0) return 2; if (sgn(d - l) &lt; 0) return 1; &#125; int pointcrosscircle(Circle v, Point &amp;p1, Point &amp;p2) &#123; int rel = relationcircle(v); if (rel == 1 || rel == 5) return 0; db d = p.distance(v.p); db l = (d * d + r * r - v.r * v.r) / (2 * d); db h = sqrt(r * r - l * l); Point tmp = p + (v.p - p).trunc(l); p1 = tmp + ((v.p - p).rotleft().trunc(h)); p2 = tmp + ((v.p - p).rotright().trunc(h)); if (rel == 2 || rel == 4) &#123; return 1; &#125; return 2; &#125;&#125; c1, c2;db w, h, a, b, c;int flag;bool judge(db x, db y) &#123; return sgn(x) &gt;= 0 &amp;&amp; sgn(w - x) &gt;= 0 &amp;&amp; sgn(y) &gt;= 0 &amp;&amp; sgn(h - y) &gt;= 0;&#125;void solve() &#123; //X在左下角 X = Point(0, 0); c1 = Circle(X, b); //Y //1 if (sgn(w - a) &gt;= 0) &#123; Y = Point(a, 0); c2 = Circle(Y, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Z = p[i]; flag = 1; return; &#125; &#125; &#125; //2 if (sgn(a - w) &gt;= 0) &#123; Y = Point(w, sqrt(a * a - w * w)); c2 = Circle(Y, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Z = p[i]; flag = 1; return; &#125; &#125; &#125; //3 if (sgn(a - h) &gt;= 0) &#123; Y = Point(sqrt(a * a - h * h), h); c2 = Circle(Y, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Z = p[i]; flag = 1; return; &#125; &#125; &#125; //4 if (sgn(h - a) &gt;= 0) &#123; Y = Point(0, a); c2 = Circle(Y, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Z = p[i]; flag = 1; return; &#125; &#125; &#125; //Z c1 = Circle(X, a); //1 if (sgn(w - b) &gt;= 0) &#123; Z = Point(b, 0); c2 = Circle(Z, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Y = p[i]; flag = 1; return; &#125; &#125; &#125; //2 if (sgn(b - w) &gt;= 0) &#123; Z = Point(w, sqrt(b * b - w * w)); c2 = Circle(Z, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Y = p[i]; flag = 1; return; &#125; &#125; &#125; //3 if (sgn(b - h) &gt;= 0) &#123; Z = Point(sqrt(b * b - h * h), h); c2 = Circle(Z, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Y = p[i]; flag = 1; return; &#125; &#125; &#125; //4 if (sgn(h - b) &gt;= 0) &#123; Z = Point(0, b); c2 = Circle(Z, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Y = p[i]; flag = 1; return; &#125; &#125; &#125; //X在右下角 X = Point(w, 0); c1 = Circle(X, b); //Y //1 if (sgn(w - a) &gt;= 0) &#123; Y = Point(w - a, 0); c2 = Circle(Y, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Z = p[i]; flag = 1; return; &#125; &#125; &#125; //2 if (sgn(h - a) &gt;= 0) &#123; Y = Point(w, a); c2 = Circle(Y, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Z = p[i]; flag = 1; return; &#125; &#125; &#125; //3 if (sgn(a - h) &gt;= 0) &#123; Y = Point(w - sqrt(a * a - h * h), h); c2 = Circle(Y, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Z = p[i]; flag = 1; return; &#125; &#125; &#125; //4 if (sgn(a - w) &gt;= 0) &#123; Y = Point(0, sqrt(a * a - w * w)); c2 = Circle(Y, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Z = p[i]; flag = 1; return; &#125; &#125; &#125; //Z c1 = Circle(X, a); //1 if (sgn(w - b) &gt;= 0) &#123; Z = Point(w - b, 0); c2 = Circle(Z, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Y = p[i]; flag = 1; return; &#125; &#125; &#125; //2 if (sgn(h - b) &gt;= 0) &#123; Z = Point(w, b); c2 = Circle(Z, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Y = p[i]; flag = 1; return; &#125; &#125; &#125; //3 if (sgn(b - h) &gt;= 0) &#123; Z = Point(w - sqrt(b * b - h * h), h); c2 = Circle(Z, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Y = p[i]; flag = 1; return; &#125; &#125; &#125; //4 if (sgn(b - w) &gt;= 0) &#123; Z = Point(0, sqrt(b * b - w * w)); c2 = Circle(Z, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Y = p[i]; flag = 1; return; &#125; &#125; &#125; //X在右上角 X = Point(w, h); //Y c1 = Circle(X, b); //1 if (sgn(a - h) &gt;= 0) &#123; Y = Point(w - sqrt(a * a - h * h), 0); c2 = Circle(Y, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Z = p[i]; flag = 1; return; &#125; &#125; &#125; //2 if (sgn(h - a) &gt;= 0) &#123; Y = Point(w, h - a); c2 = Circle(Y, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Z = p[i]; flag = 1; return; &#125; &#125; &#125; //3 if (sgn(w - a) &gt;= 0) &#123; Y = Point(w - a, h); c2 = Circle(Y, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Z = p[i]; flag = 1; return; &#125; &#125; &#125; //4 if (sgn(a - w) &gt;= 0) &#123; Y = Point(0, h - sqrt(a * a - w * w)); c2 = Circle(Y, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Z = p[i]; flag = 1; return; &#125; &#125; &#125; //Z c1 = Circle(X, a); //1 if (sgn(b - h) &gt;= 0) &#123; Z = Point(w - sqrt(b * b - h * h), 0); c2 = Circle(Z, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Y = p[i]; flag = 1; return; &#125; &#125; &#125; //2 if (sgn(h - b) &gt;= 0) &#123; Z = Point(w, h - b); c2 = Circle(Z, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Y = p[i]; flag = 1; return; &#125; &#125; &#125; //3 if (sgn(w - b) &gt;= 0) &#123; Z = Point(w - b, h); c2 = Circle(Z, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Y = p[i]; flag = 1; return; &#125; &#125; &#125; //4 if (sgn(b - w) &gt;= 0) &#123; Z = Point(0, h - sqrt(b * b - w * w)); c2 = Circle(Z, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Y = p[i]; flag = 1; return; &#125; &#125; &#125; //X在左上角 X = Point(0, h); //Y c1 = Circle(X, b); //1 if (sgn(a - h) &gt;= 0) &#123; Y = Point(sqrt(a * a - h * h), 0); c2 = Circle(Y, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Z = p[i]; flag = 1; return; &#125; &#125; &#125; //2 if (sgn(a - w) &gt;= 0) &#123; Y = Point(w, h - sqrt(a * a - w * w)); c2 = Circle(Y, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Z = p[i]; flag = 1; return; &#125; &#125; &#125; //3 if (sgn(w - a) &gt;= 0) &#123; Y = Point(a, h); c2 = Circle(Y, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Z = p[i]; flag = 1; return; &#125; &#125; &#125; //4 if (sgn(h - a) &gt;= 0) &#123; Y = Point(0, h - a); c2 = Circle(Y, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Z = p[i]; flag = 1; return; &#125; &#125; &#125; //Z c1 = Circle(X, a); //1 if (sgn(b - h) &gt;= 0) &#123; Z = Point(sqrt(b * b - h * h), 0); c2 = Circle(Z, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Y = p[i]; flag = 1; return; &#125; &#125; &#125; //2 if (sgn(b - w) &gt;= 0) &#123; Z = Point(w, h - sqrt(b * b - w * w)); c2 = Circle(Z, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Y = p[i]; flag = 1; return; &#125; &#125; &#125; //3 if (sgn(w - b) &gt;= 0) &#123; Z = Point(b, h); c2 = Circle(Z, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Y = p[i]; flag = 1; return; &#125; &#125; &#125; //4 if (sgn(h - b) &gt;= 0) &#123; Z = Point(0, h - b); c2 = Circle(Z, c); int res = c1.pointcrosscircle(c2, p[0], p[1]); for (int i = 0; i &lt; res; ++i) &#123; if (judge(p[i].x, p[i].y)) &#123; Y = p[i]; flag = 1; return; &#125; &#125; &#125;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; flag = 0; scanf(\"%lf %lf %lf %lf %lf\", &amp;w, &amp;h, &amp;a, &amp;b, &amp;c); db ta = a, tb = b, tc = c; if (sgn(a + b - c) &gt; 0 &amp;&amp; sgn(b + c - a) &gt; 0 &amp;&amp; sgn(a + c - b) &gt; 0) &#123; //x y z solve(); if (!flag) &#123; // y x z a = ta, b = tc, c = tb; solve(); if (!flag) &#123; //z y x a = tc, b = tb, c = ta; solve(); if (!flag) &#123; assert(0); &#125; else &#123; swap(X, Z); &#125; &#125; else &#123; swap(X, Y); &#125; &#125; &#125; else &#123; db k = h / w; if (sgn(a + b - c) == 0) &#123; Y = Point(0, 0); db x = sqrt((a * a * w * w) / (h * h + w * w)); X = Point(x, k * x); x = sqrt((c * c * w * w) / (h * h + w * w)); Z = Point(x, k * x); &#125; else if (sgn(b + c - a) == 0) &#123; X = Point(0, 0); db x = sqrt((a * a * w * w) / (h * h + w * w)); Y = Point(x, k * x); x = sqrt((b * b * w * w) / (h * h + w * w)); Z = Point(x, k * x); &#125; else if (sgn(a + c - b) == 0) &#123; X = Point(0, 0); db x = sqrt((a * a * w * w) / (h * h + w * w)); Y = Point(x, k * x); x = sqrt((b * b * w * w) / (h * h + w * w)); Z = Point(x, k * x); &#125; &#125; printf(\"%.10f %.10f %.10f %.10f %.10f %.10f\\n\", X.x, X.y, Y.x, Y.y, Z.x, Z.y); &#125; return 0;&#125;","categories":[],"tags":[{"name":"2019牛客多校","slug":"2019牛客多校","permalink":"https://hsueh37.gitee.io/blog/tags/2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"}]},{"title":"2019牛客暑期多校训练营（第四场）","slug":"2019牛客暑期多校训练营（第四场）","date":"2019-07-29T13:30:00.000Z","updated":"2020-04-28T09:02:42.263Z","comments":true,"path":"2019/07/29/2019牛客暑期多校训练营（第四场）/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/07/29/2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E5%9B%9B%E5%9C%BA%EF%BC%89/","excerpt":"","text":"A. meeting题意：在树上选取一个点使得$K$个点到达这个点的最大值最小 思路：答案为$K$个点的最远点对距离$\\lceil \\frac{d}{2}\\rceil$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3f#define N 100010int n, m;vector&lt;int&gt; G[N];int vis[N], dp[N];int ans;void DFS(int u, int fa) &#123; if (vis[u]) &#123; dp[u] = 0; &#125; for (auto v : G[u]) &#123; if (v == fa) &#123; continue; &#125; DFS(v, u); ans = max(ans, dp[u] + dp[v] + 1); dp[u] = max(dp[u], dp[v] + 1); &#125;&#125;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;m); for (int i = 1, u, v; i &lt; n; ++i) &#123; scanf(\"%d %d\", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; for (int i = 1, x; i &lt;= m; ++i) &#123; scanf(\"%d\", &amp;x); vis[x] = 1; &#125; memset(dp, -INF, sizeof dp); ans = 0; DFS(1, 0); printf(\"%d\\n\", (ans + 1) / 2); return 0;&#125; C. sequence题意：求$max_{1\\leq l \\leq r \\leq } \\{min(a_{l\\cdots r}) \\cdot sum(b_{l\\cdots r})\\}$ 思路：笛卡尔树维护最小值，线段树维护区间和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include &lt;bits/stdc++.h&gt;using namespace std;#define pii pair &lt;int, int&gt;#define fi first#define se second#define ll long long#define INFLL 0x3f3f3f3f3f3f3f3f#define N 3000010int n, a[N];ll b[N];struct Cartesian_Tree &#123; struct node &#123; int id, val, fa; int son[2]; node() &#123;&#125; node (int id, int val, int fa) : id(id), val(val), fa(fa) &#123; son[0] = son[1] = 0; &#125; &#125;t[N]; int root; pii b[N]; void init() &#123; t[0] = node(0, -1e9, 0); &#125; void build(int n, int *a) &#123; for (int i = 1; i &lt;= n; ++i) &#123; t[i] = node(i, a[i], 0); &#125; for (int i = 1; i &lt;= n; ++i) &#123; int k = i - 1; while (t[k].val &gt; t[i].val) &#123; k = t[k].fa; &#125; t[i].son[0] = t[k].son[1]; t[k].son[1] = i; t[i].fa = k; t[t[i].son[0]].fa = i; &#125; root = t[0].son[1]; &#125; int DFS(int u) &#123; if (!u) return 0; int lsze = DFS(t[u].son[0]); int rsze = DFS(t[u].son[1]); b[t[u].id] = pii(lsze, rsze); return lsze + rsze + 1; &#125;&#125;CT;struct SEG &#123; struct node &#123; ll Max, Min; node() &#123; Max = -INFLL; Min = INFLL; &#125; node operator + (const node &amp;other) const &#123; node res = node(); res.Max = max(Max, other.Max); res.Min = min(Min, other.Min); return res; &#125; &#125;t[N &lt;&lt; 2], resl, resr; void build(int id, int l, int r) &#123; if (l == r) &#123; t[id] = node(); t[id].Max = t[id].Min = b[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); t[id] = t[id &lt;&lt; 1] + t[id &lt;&lt; 1 | 1]; &#125; node query(int id, int l, int r, int ql, int qr) &#123; if (l &gt;= ql &amp;&amp; r &lt;= qr) &#123; return t[id]; &#125; int mid = (l + r) &gt;&gt; 1; node res = node(); if (ql &lt;= mid) res = res + query(id &lt;&lt; 1, l, mid, ql, qr); if (qr &gt; mid) res = res + query(id &lt;&lt; 1 | 1, mid + 1, r, ql, qr); return res; &#125;&#125;seg;namespace IO&#123; const int S=(1&lt;&lt;20)+5; //Input Correlation char buf[S],*H,*T; inline char Get() &#123; if(H==T) T=(H=buf)+fread(buf,1,S,stdin); if(H==T) return -1;return *H++; &#125; inline int read() &#123; int x=0,fg=1;char c=Get(); while(!isdigit(c)&amp;&amp;c!='-') c=Get(); if(c=='-') fg=-1,c=Get(); while(isdigit(c)) x=x*10+c-'0',c=Get(); return x*fg; &#125; inline void reads(char *s) &#123; char c=Get();int tot=0; while(c&lt;'a'||c&gt;'z') c=Get(); while(c&gt;='a'&amp;&amp;c&lt;='z') s[++tot]=c,c=Get(); s[++tot]='\\0'; &#125; //Output Correlation char obuf[S],*oS=obuf,*oT=oS+S-1,c,qu[55];int qr; inline void flush()&#123;fwrite(obuf,1,oS-obuf,stdout);oS=obuf;&#125; inline void putc(char x)&#123;*oS++ =x;if(oS==oT) flush();&#125; template &lt;class I&gt;inline void print(I x) &#123; if(!x) putc('0'); if(x&lt;0) putc('-'),x=-x; while(x) qu[++qr]=x%10+'0',x/=10; while(qr) putc(qu[qr--]); putc('\\n'); &#125; inline void prints(const char *s) &#123; int len=strlen(s); for(int i=0;i&lt;len;i++) putc(s[i]); putc('\\n'); &#125; inline void printd(int d,double x) &#123; long long t=(long long)floor(x); print(t);putc('.');x-=t; while(d--) &#123; double y=x*10;x*=10; int c=(int)floor(y); putc(c+'0');x-=floor(y); &#125; &#125;&#125;using namespace IO;int main() &#123; n = read(); for (int i = 1; i &lt;= n; ++i) a[i] = read(); b[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; b[i] = read(); b[i] += b[i - 1]; &#125; CT.init(); CT.build(n, a); CT.DFS(CT.root); ll res = -INFLL; seg.build(1, 0, n); for (int i = 1; i &lt;= n; ++i) &#123; int l = i - CT.b[i].fi, r = i + CT.b[i].se; seg.resl = seg.query(1, 0, n, l - 1, i - 1); seg.resr = seg.query(1, 0, n, i, r); res = max(res, 1ll * a[i] * (seg.resr.Max - seg.resl.Min)); res = max(res, 1ll * a[i] * (seg.resr.Min - seg.resl.Max)); &#125; printf(\"%lld\\n\", res); return 0;&#125; J. free题意：可以免费$k$条边的最短路 思路：$dis[i][j]$表示到达$i$，免费了$j$条边的代价，跑最短路 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define INFLL 0x3f3f3f3f3f3f3f3f#define N 1010#define M 100010struct Edge &#123; int to, nxt, w; Edge() &#123;&#125; Edge(int to, int nxt, int w) : to(to), nxt(nxt), w(w) &#123;&#125;&#125; edge[M &lt;&lt; 1];int n, m, S, T, K;int head[N], tot;void Init() &#123; memset(head, -1, sizeof head); tot = 0;&#125;void addedge(int u, int v, int w) &#123; edge[++tot] = Edge(v, head[u], w); head[u] = tot++; edge[++tot] = Edge(u, head[v], w); head[v] = tot++;&#125;struct qnode &#123; int u, k; ll w; qnode() &#123;&#125;; qnode(int u, ll w, int k) : u(u), w(w), k(k) &#123;&#125; bool operator&lt;(const qnode &amp;other) const &#123; return w &gt; other.w; &#125;&#125;;ll dis[N][N];void Dijkstra(int s) &#123; memset(dis, INFLL, sizeof dis); priority_queue&lt;qnode&gt; q; dis[s][0] = 0; q.push(qnode(s, 0, 0)); while (!q.empty()) &#123; int u = q.top().u; int k = q.top().k; q.pop(); if (u == T) &#123; return; &#125; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to; ll w = edge[i].w; if (dis[u][k] + w &lt; dis[v][k]) &#123; dis[v][k] = dis[u][k] + w; q.push(qnode(v, dis[v][k], k)); &#125; if (k &lt; K &amp;&amp; dis[u][k] &lt; dis[v][k + 1]) &#123; dis[v][k + 1] = dis[u][k]; q.push(qnode(v, dis[v][k + 1], k + 1)); &#125; &#125; &#125;&#125;int main() &#123; scanf(\"%d %d %d %d %d\", &amp;n, &amp;m, &amp;S, &amp;T, &amp;K); Init(); for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); addedge(u, v, w); &#125; Dijkstra(S); ll ans = INFLL; for (int i = 0; i &lt;= K; ++i) &#123; ans = min(ans, dis[T][i]); &#125; printf(\"%lld\\n\", ans); return 0;&#125; K. number题意：给定一个数字串，问多少个子串可以被$300$，整除 思路：$dp[i][j]$表示$i$结尾，余数为$j$，$dp$转移即可。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 100010char str[N];ll dp[N][301];int main() &#123; scanf(\"%s\", str + 1); ll ans = 0; for (int i = 1, len = strlen(str + 1); i &lt;= len; ++i) &#123; int now = str[i] - '0'; dp[i][now]++; for (int j = 0; j &lt; 300; ++j) &#123; int nxt = (j * 10 + now) % 300; dp[i][nxt] += dp[i - 1][j]; &#125; ans += dp[i][0]; &#125; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[],"tags":[{"name":"2019牛客多校","slug":"2019牛客多校","permalink":"https://hsueh37.gitee.io/blog/tags/2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"}]},{"title":"2019 Multi-University Training Contest 3","slug":"2019-Multi-University-Training-Contest-3","date":"2019-07-29T13:15:00.000Z","updated":"2020-04-28T09:02:42.260Z","comments":true,"path":"2019/07/29/2019-Multi-University-Training-Contest-3/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/07/29/2019-Multi-University-Training-Contest-3/","excerpt":"","text":"B. Blow up the city题意：给出一个$DAG$，问删除一个点使得$a,b$其中一个点不能到达所有的出度为$0$的点的方案 思路：根据$DAG$维护支配树，那么方案数为$deep[a]+deep[b]-deep[LCA_{a, b}]-1$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;bits/stdc++.h&gt;using namespace std;#define N 200010#define DEG 20struct Graph &#123; struct Edge &#123; int to, nxt; Edge() &#123;&#125; Edge(int _to, int _nxt) &#123; to = _to; nxt = _nxt; &#125; &#125; edge[N &lt;&lt; 1]; int head[N], tot; void Init() &#123; memset(head, -1, sizeof head); tot = 0; &#125; void addedge(int u, int v) &#123; edge[tot] = Edge(v, head[u]); head[u] = tot++; &#125;&#125; G[2];int n, m, q;int fa[N][DEG], dep[N], d[N], sze[N];struct Tree &#123; void add(int u, int v) &#123; fa[v][0] = u; dep[v] = dep[u] + 1; for (int i = 1; i &lt; DEG; ++i) &#123; fa[v][i] = fa[fa[v][i - 1]][i - 1]; &#125; &#125; int LCA(int u, int v) &#123; if (!u) return v; if (!v) return u; if (dep[u] &gt; dep[v]) &#123; swap(u, v); &#125; for (int det = dep[v] - dep[u], i = 0; det; det &gt;&gt;= 1, ++i) &#123; if (det &amp; 1) &#123; v = fa[v][i]; &#125; &#125; if (u == v) return u; for (int i = DEG - 1; i &gt;= 0; --i) &#123; if (fa[u][i] == fa[v][i]) &#123; continue; &#125; u = fa[u][i]; v = fa[v][i]; &#125; return fa[u][0]; &#125; int GET(int u) &#123; int lca = 0; for (int i = G[1].head[u]; ~i; i = G[1].edge[i].nxt) &#123; lca = LCA(lca, G[1].edge[i].to); &#125; return lca; &#125; void solve() &#123; int S = n + 1; add(S, S); queue&lt;int&gt; que; for (int i = 1; i &lt;= n; ++i) &#123; if (d[i] == 0) &#123; que.push(i); add(S, i); &#125; &#125; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = G[0].head[u]; ~i; i = G[0].edge[i].nxt) &#123; int v = G[0].edge[i].to; --d[v]; if (d[v] == 0) &#123; que.push(v); add(GET(v), v); &#125; &#125; &#125; &#125;&#125; tree;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"input.txt\", \"r\", stdin);#endif int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d %d\", &amp;n, &amp;m); G[0].Init(), G[1].Init(); for (int i = 0; i &lt; n + 2; ++i) &#123; dep[i] = 0; d[i] = 0; sze[i] = 0; fa[i][0] = 0; &#125; for (int i = 1, u, v; i &lt;= m; ++i) &#123; scanf(\"%d %d\", &amp;u, &amp;v); G[0].addedge(v, u); G[1].addedge(u, v); ++d[u]; &#125; tree.solve(); scanf(\"%d\", &amp;q); while (q--) &#123; int a, b; scanf(\"%d %d\", &amp;a, &amp;b); printf(\"%d\\n\", dep[a] + dep[b] - dep[tree.LCA(a, b)] - 1); &#125; &#125; return 0;&#125; D. Distribution of books题意：将$n$个数分为$k$段，每段起码一个值，$k$段以后可以丢弃，求最小的最大值。 思路：二分答案$x$，$f[i]$表示$i$元素末尾的最大段数，显然$j \\rightarrow i$的条件是$sum[i] - sum[j] &lt;= x$，线段树统计这样的$j$的最大$f[j]$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;bits/stdc++.h&gt;using namespace std;namespace IO&#123; const int S=(1&lt;&lt;20)+5; //Input Correlation char buf[S],*H,*T; inline char Get() &#123; if(H==T) T=(H=buf)+fread(buf,1,S,stdin); if(H==T) return -1;return *H++; &#125; inline int read() &#123; int x=0,fg=1;char c=Get(); while(!isdigit(c)&amp;&amp;c!='-') c=Get(); if(c=='-') fg=-1,c=Get(); while(isdigit(c)) x=x*10+c-'0',c=Get(); return x*fg; &#125; inline void reads(char *s) &#123; char c=Get();int tot=0; while(c&lt;'a'||c&gt;'z') c=Get(); while(c&gt;='a'&amp;&amp;c&lt;='z') s[++tot]=c,c=Get(); s[++tot]='\\0'; &#125; //Output Correlation char obuf[S],*oS=obuf,*oT=oS+S-1,c,qu[55];int qr; inline void flush()&#123;fwrite(obuf,1,oS-obuf,stdout);oS=obuf;&#125; inline void putc(char x)&#123;*oS++ =x;if(oS==oT) flush();&#125; template &lt;class I&gt;inline void print(I x) &#123; if(!x) putc('0'); if(x&lt;0) putc('-'),x=-x; while(x) qu[++qr]=x%10+'0',x/=10; while(qr) putc(qu[qr--]); &#125; inline void prints(const char *s) &#123; int len=strlen(s); for(int i=0;i&lt;len;i++) putc(s[i]); putc('\\n'); &#125; inline void printd(int d,double x) &#123; long long t=(long long)floor(x); print(t);putc('.');x-=t; while(d--) &#123; double y=x*10;x*=10; int c=(int)floor(y); putc(c+'0');x-=floor(y); &#125; &#125;&#125;using namespace IO;#define ll long long#define INF 0x3f3f3f3f#define N 400010int n, k;ll a[N], b[N]; void Hash(ll *b) &#123; sort(b + 1, b + 1 + b[0]); b[0] = unique(b + 1, b + 1 + b[0]) - b - 1;&#125;int get(ll x) &#123; return lower_bound(b + 1, b + 1 + b[0], x) - b; &#125;struct SEG &#123; struct node &#123; int Max; node() &#123; Max = -INF; &#125; node operator + (const node &amp;other) const &#123; node res = node(); res.Max = max(Max, other.Max); return res; &#125; &#125;t[N &lt;&lt; 2]; void build(int id, int l, int r) &#123; t[id] = node(); if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); &#125; void update(int id, int l, int r, int pos, int x) &#123; if (l == r) &#123; t[id].Max = max(t[id].Max, x); return; &#125; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) update(id &lt;&lt; 1, l, mid, pos, x); else update(id &lt;&lt; 1 | 1, mid + 1, r, pos, x); t[id] = t[id &lt;&lt; 1] + t[id &lt;&lt; 1 | 1]; &#125; int query(int id, int l, int r, int ql, int qr) &#123; if (ql &gt; qr) return -INF; if (l &gt;= ql &amp;&amp; r &lt;= qr) &#123; return t[id].Max; &#125; int mid = (l + r) &gt;&gt; 1; int res = -INF; if (ql &lt;= mid) res = max(res, query(id &lt;&lt; 1, l, mid, ql, qr)); if (qr &gt; mid) res = max(res, query(id &lt;&lt; 1 | 1, mid + 1, r, ql, qr)); return res; &#125;&#125;seg;bool check(ll x) &#123; b[0] = 0; b[++b[0]] = 0; for (int i = 1; i &lt;= n; ++i) &#123; b[++b[0]] = a[i]; b[++b[0]] = a[i] - x; &#125; Hash(b); seg.build(1, 1, b[0]); seg.update(1, 1, b[0], get(0), 0); for (int i = 1; i &lt;= n; ++i) &#123; int f = seg.query(1, 1, b[0], get(a[i] - x), b[0]) + 1; if (f &gt;= k) return 1; seg.update(1, 1, b[0], get(a[i]), f); &#125; return 0;&#125;int main() &#123; int T; T = read(); while (T--) &#123; n = read(); k = read(); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); a[i] += a[i - 1]; &#125; ll l = -2e15, r = 1e9, res = -1; while (r - l &gt;= 0) &#123; ll mid = (l + r) &gt;&gt; 1; if (check(mid)) &#123; r = mid - 1; res = mid; &#125; else &#123; l = mid + 1; &#125; &#125; printf(\"%lld\\n\", res); &#125; return 0;&#125; F. Fansblog题意：找一个最大的素数$Q(Q &lt; P)$，问$Q!\\%P$ 思路：已知$(P-1)! \\%P=P-1$，暴力找到$Q$，通过逆元得到$Q!\\%P$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longll p;const int C = 2307;const int S = 10;mt19937_64 rd(time(0));ll gcd(ll a, ll b) &#123; return b ? gcd(b, a % b) : a;&#125;ll mul(ll a, ll b, ll p) &#123; return (a * b - (ll)(a / (long double)p * b + 1e-3) * p + p) % p;&#125;ll qmod(ll base, ll n, ll p) &#123; ll res = 1; base %= p; while (n) &#123; if (n &amp; 1) &#123; res = mul(res, base, p); &#125; base = mul(base, base, p); n &gt;&gt;= 1; &#125; return res;&#125;bool check(ll a, ll n) &#123; ll m = n - 1, x, y; int j = 0; while (!(m &amp; 1)) &#123; m &gt;&gt;= 1; ++j; &#125; x = qmod(a, m, n); for (int i = 1; i &lt;= j; x = y, ++i) &#123; y = mul(x, x, n); if (y == 1 &amp;&amp; x != 1 &amp;&amp; x != n - 1) &#123; return 1; &#125; &#125; return y != 1;&#125;bool miller_rabin(ll n) &#123; if (n &lt; 2) &#123; return 0; &#125; else if (n == 2) &#123; return 1; &#125; else if (! (n &amp; 1)) &#123; return 0; &#125; for (int i = 0; i &lt; S; ++i) &#123; if (check(rd() % (n - 1) + 1, n)) &#123; return 0; &#125; &#125; return 1;&#125;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%lld\", &amp;p); ll n; for (ll i = p - 1; ; --i) &#123; if (miller_rabin(i)) &#123; n = i; break; &#125; &#125; ll res = p - 1; for (ll i = p - 1; i &gt; n; --i) &#123; res = mul(res, qmod(i, p - 2, p), p); &#125; printf(\"%lld\\n\", res); &#125; return 0;&#125; G. Find the answer题意：对于每个$i$，可以修改$W_k(1\\leq k &lt; i)=0$，问最小的修改数满足$\\sum_{j=1}^iW_j\\leq m$ 思路：权值线段树上二分即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;using namespace std;namespace IO&#123; const int S=(1&lt;&lt;20)+5; //Input Correlation char buf[S],*H,*T; inline char Get() &#123; if(H==T) T=(H=buf)+fread(buf,1,S,stdin); if(H==T) return -1;return *H++; &#125; inline int read() &#123; int x=0,fg=1;char c=Get(); while(!isdigit(c)&amp;&amp;c!='-') c=Get(); if(c=='-') fg=-1,c=Get(); while(isdigit(c)) x=x*10+c-'0',c=Get(); return x*fg; &#125; inline void reads(char *s) &#123; char c=Get();int tot=0; while(c&lt;'a'||c&gt;'z') c=Get(); while(c&gt;='a'&amp;&amp;c&lt;='z') s[++tot]=c,c=Get(); s[++tot]='\\0'; &#125; //Output Correlation char obuf[S],*oS=obuf,*oT=oS+S-1,c,qu[55];int qr; inline void flush()&#123;fwrite(obuf,1,oS-obuf,stdout);oS=obuf;&#125; inline void putc(char x)&#123;*oS++ =x;if(oS==oT) flush();&#125; template &lt;class I&gt;inline void print(I x) &#123; if(!x) putc('0'); if(x&lt;0) putc('-'),x=-x; while(x) qu[++qr]=x%10+'0',x/=10; while(qr) putc(qu[qr--]); &#125; inline void prints(const char *s) &#123; int len=strlen(s); for(int i=0;i&lt;len;i++) putc(s[i]); putc('\\n'); &#125; inline void printd(int d,double x) &#123; long long t=(long long)floor(x); print(t);putc('.');x-=t; while(d--) &#123; double y=x*10;x*=10; int c=(int)floor(y); putc(c+'0');x-=floor(y); &#125; &#125;&#125;using namespace IO;#define ll long long#define N 200010int n, m, a[N], b[N]; struct SEG &#123; struct node &#123; ll sum; int cnt; node() &#123; sum = cnt = 0; &#125; node (ll sum, int cnt) : sum(sum), cnt(cnt) &#123;&#125; node operator + (const node &amp;other) const &#123; node res = node(); res.sum = sum + other.sum; res.cnt = cnt + other.cnt; return res; &#125; &#125;t[N &lt;&lt; 2]; void build(int id, int l, int r) &#123; t[id] = node(); if (l == r) return; int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); &#125; void update(int id, int l, int r, int x) &#123; if (l == r) &#123; t[id].sum += b[l]; ++t[id].cnt; return; &#125; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update(id &lt;&lt; 1, l, mid, x); else update(id &lt;&lt; 1 | 1, mid + 1, r, x); t[id] = t[id &lt;&lt; 1] + t[id &lt;&lt; 1 | 1]; &#125; int query(int id, int l, int r, ll need) &#123; if (need &lt;= 0) return 0; if (l == r) &#123; return need / b[l] + (need % b[l] != 0); &#125; int mid = (l + r) &gt;&gt; 1; if (t[id &lt;&lt; 1 | 1].sum &gt;= need) return query(id &lt;&lt; 1 | 1, mid + 1, r, need); else return t[id &lt;&lt; 1 | 1].cnt + query(id &lt;&lt; 1, l, mid, need - t[id &lt;&lt; 1 | 1].sum); &#125;&#125;seg;void Hash(int *b) &#123; sort(b + 1, b + 1 + b[0]); b[0] = unique(b + 1, b + 1 + b[0]) - b - 1;&#125;int get(int x) &#123; return lower_bound(b + 1, b + 1 + b[0], x) - b;&#125;int main() &#123; int T; T = read(); while (T--) &#123; n = read(); m = read(); b[0] = 0; for (int i = 1; i &lt;= n; ++i) a[i] = read(), b[++b[0]] = a[i]; Hash(b); seg.build(1, 1, b[0]); ll sum = 0; for (int i = 1; i &lt;= n; ++i) &#123; sum += a[i]; print(seg.query(1, 1, b[0], sum - m)); putc(' '); seg.update(1, 1, b[0], get(a[i])); &#125; putc('\\n'); &#125; flush(); return 0;&#125;// I. K Subsequence题意：选择$k$段不相交的上升序列，使得权值和最大 思路：$Dijkstra$优化费用流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;bits/stdc++.h&gt;using namespace std;#define INF 0x3f3f3f3f#define N 4010namespace IO &#123; const int S = (1 &lt;&lt; 20) + 5; //Input Correlation char buf[S], *H, *T; inline char Get() &#123; if (H == T) T = (H = buf) + fread(buf, 1, S, stdin); if (H == T) return -1; return *H++; &#125; inline int read() &#123; int x = 0, fg = 1; char c = Get(); while (!isdigit(c) &amp;&amp; c != '-') c = Get(); if (c == '-') fg = -1, c = Get(); while (isdigit(c)) x = x * 10 + c - '0', c = Get(); return x * fg; &#125; inline void reads(char *s) &#123; char c = Get(); int tot = 0; while (c &lt; 'a' || c &gt; 'z') c = Get(); while (c &gt;= 'a' &amp;&amp; c &lt;= 'z') s[++tot] = c, c = Get(); s[++tot] = '\\0'; &#125; //Output Correlation char obuf[S], *oS = obuf, *oT = oS + S - 1, c, qu[55]; int qr; inline void flush() &#123; fwrite(obuf, 1, oS - obuf, stdout); oS = obuf; &#125; inline void putc(char x) &#123; *oS++ = x; if (oS == oT) flush(); &#125; template&lt;class I&gt; inline void print(I x) &#123; if (!x) putc('0'); if (x &lt; 0) putc('-'), x = -x; while (x) qu[++qr] = x % 10 + '0', x /= 10; while (qr) putc(qu[qr--]); &#125; inline void prints(const char *s) &#123; int len = strlen(s); for (int i = 0; i &lt; len; i++) putc(s[i]); putc('\\n'); &#125; inline void printd(int d, double x) &#123; long long t = (long long) floor(x); print(t); putc('.'); x -= t; while (d--) &#123; double y = x * 10; x *= 10; int c = (int) floor(y); putc(c + '0'); x -= floor(y); &#125; &#125;&#125;using namespace IO;struct edge &#123; int to, capacity, cost, rev; edge() &#123;&#125; edge(int to, int _capacity, int _cost, int _rev) : to(to), capacity(_capacity), cost(_cost), rev(_rev) &#123;&#125;&#125;;struct Min_Cost_Max_Flow &#123; int V, H[N + 5], dis[N + 5], PreV[N + 5], PreE[N + 5]; vector&lt;edge&gt; G[N + 5]; //调用前初始化 void Init(int n) &#123; V = n; for (int i = 0; i &lt;= V; ++i)G[i].clear(); &#125; //加边 void Add_Edge(int from, int to, int cap, int cost) &#123; G[from].push_back(edge(to, cap, cost, G[to].size())); G[to].push_back(edge(from, 0, -cost, G[from].size() - 1)); &#125; //flow是自己传进去的变量，就是最后的最大流，返回的是最小费用 int Min_cost_max_flow(int s, int t, int f, int &amp;flow) &#123; int res = 0; fill(H, H + 1 + V, 0); while (f) &#123; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; q; fill(dis, dis + 1 + V, INF); dis[s] = 0; q.push(pair&lt;int, int&gt;(0, s)); while (!q.empty()) &#123; pair&lt;int, int&gt; now = q.top(); q.pop(); int v = now.second; if (dis[v] &lt; now.first)continue; for (int i = 0; i &lt; G[v].size(); ++i) &#123; edge &amp;e = G[v][i]; if (e.capacity &gt; 0 &amp;&amp; dis[e.to] &gt; dis[v] + e.cost + H[v] - H[e.to]) &#123; dis[e.to] = dis[v] + e.cost + H[v] - H[e.to]; PreV[e.to] = v; PreE[e.to] = i; q.push(pair&lt;int, int&gt;(dis[e.to], e.to)); &#125; &#125; &#125; if (dis[t] == INF)break; for (int i = 0; i &lt;= V; ++i)H[i] += dis[i]; int d = f; for (int v = t; v != s; v = PreV[v])d = min(d, G[PreV[v]][PreE[v]].capacity); f -= d; flow += d; res += d * H[t]; for (int v = t; v != s; v = PreV[v]) &#123; edge &amp;e = G[PreV[v]][PreE[v]]; e.capacity -= d; G[v][e.rev].capacity += d; &#125; &#125; return res; &#125; int Max_cost_max_flow(int s, int t, int f, int &amp;flow) &#123; int res = 0; fill(H, H + 1 + V, 0); while (f) &#123; priority_queue&lt;pair&lt;int, int&gt;&gt; q; fill(dis, dis + 1 + V, -INF); dis[s] = 0; q.push(pair&lt;int, int&gt;(0, s)); while (!q.empty()) &#123; pair&lt;int, int&gt; now = q.top(); q.pop(); int v = now.second; if (dis[v] &gt; now.first)continue; for (int i = 0; i &lt; G[v].size(); ++i) &#123; edge &amp;e = G[v][i]; if (e.capacity &gt; 0 &amp;&amp; dis[e.to] &lt; dis[v] + e.cost + H[v] - H[e.to]) &#123; dis[e.to] = dis[v] + e.cost + H[v] - H[e.to]; PreV[e.to] = v; PreE[e.to] = i; q.push(pair&lt;int, int&gt;(dis[e.to], e.to)); &#125; &#125; &#125; if (dis[t] == -INF)break; for (int i = 0; i &lt;= V; ++i)H[i] += dis[i]; int d = f; for (int v = t; v != s; v = PreV[v])d = min(d, G[PreV[v]][PreE[v]].capacity); f -= d; flow += d; res += d * H[t]; for (int v = t; v != s; v = PreV[v]) &#123; edge &amp;e = G[PreV[v]][PreE[v]]; e.capacity -= d; G[v][e.rev].capacity += d; &#125; &#125; return res; &#125;&#125; MCMF;int n, k, s1, s2, t, a[N], flow;int main() &#123;// freopen(\"input.txt\", \"r\", stdin); int cas = read(); while (cas--) &#123; n = read(), k = read(); s1 = 0, s2 = 1, t = 2 * n + 2; MCMF.Init(t); MCMF.Add_Edge(s1, s2, k, 0); for (int i = 1; i &lt;= n; ++i) &#123; a[i] = read(); MCMF.Add_Edge(s2, i &lt;&lt; 1, 1, 0); MCMF.Add_Edge(i &lt;&lt; 1 | 1, t, 1, 0); MCMF.Add_Edge(i &lt;&lt; 1, i &lt;&lt; 1 | 1, 1, -a[i]); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i; ++j) &#123; if (a[i] &gt;= a[j]) &#123; MCMF.Add_Edge(j &lt;&lt; 1 | 1, i &lt;&lt; 1, 1, 0); &#125; &#125; &#125; print(-MCMF.Min_cost_max_flow(s1, t, INF, flow)); putc('\\n'); &#125; flush(); return 0;&#125;","categories":[],"tags":[{"name":"HUD多校","slug":"HUD多校","permalink":"https://hsueh37.gitee.io/blog/tags/HUD%E5%A4%9A%E6%A0%A1/"}]},{"title":"2019 Multi-University Training Contest 2","slug":"2019-Multi-University-Training-Contest-2","date":"2019-07-24T12:15:00.000Z","updated":"2020-11-30T05:04:39.160Z","comments":true,"path":"2019/07/24/2019-Multi-University-Training-Contest-2/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/07/24/2019-Multi-University-Training-Contest-2/","excerpt":"","text":"B. Beauty Of Unimodal SequenceE. Everything Is Generated In Equal Probability题意：给定一个$N$，等概率从$N$中选取一个$n$，等概率生成一个$n$的序列，然后执行伪代码，求逆序对期望 思路：打表得$\\frac{n^ 2-1}{9}$ 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll p = 998244353;ll qpow(ll x, ll n) &#123; ll res = 1; while (n) &#123; if (n &amp; 1) &#123; res = res * x % p; &#125; x = x * x % p; n &gt;&gt;= 1; &#125; return res;&#125;ll n;int main() &#123; ll inv = qpow(9, p - 2); while (scanf(\"%lld\", &amp;n) != EOF) &#123; ll ans = (n * n - 1) % p * inv % p; printf(\"%lld\\n\", ans); &#125; return 0;&#125; H. Harmonious Army题意：有$n$个士兵，每个士兵两种身份$Mage\\;or\\;Warrior$，有$m$对关系，如果是两个$Warriors$，则属性增加$a$，如果是两个$Mages$，属性增加$c$，否则增加$b(b=\\frac{a}{4}+\\frac{c}{2})$，问最大属性值。 思路：将问题转换成，有$m$对关系，如果是两个$Warriors$，则属性较少$b+c$，如果是两个$Mages$，属性增加$a+b$，否则增加$a+c$，问最大属性值。 那么建立如下网络流，可以得到 $ a = b =（A + B）/ 2， c = d = (C + B) / 2, e = -B + (A + C) / 2$ 答案为总的$a+b+c$减去最小割 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef double db;#define INFLL 0x3f3f3f3f3f3f3f3f#define N 510#define M 100010struct Dicnic &#123; struct Edge &#123; int to, nxt; db flow; Edge() &#123;&#125; Edge(int to, int nxt, db flow) : to(to), nxt(nxt), flow(flow) &#123;&#125; &#125; edge[M &lt;&lt; 1]; int head[N], dep[N]; int S, T, tot; void Init() &#123; memset(head, -1, sizeof head); tot = 0; &#125; void addedge(int u, int v, db w, db rw = 0) &#123; edge[tot] = Edge(v, head[u], w); head[u] = tot++; edge[tot] = Edge(u, head[v], rw); head[v] = tot++; &#125; bool BFS() &#123; memset(dep, -1, sizeof dep); queue&lt;int&gt; q; q.push(S); dep[S] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = edge[i].nxt) &#123; if (edge[i].flow &amp;&amp; dep[edge[i].to] == -1) &#123; dep[edge[i].to] = dep[u] + 1; q.push(edge[i].to); &#125; &#125; &#125; return dep[T] &gt;= 0; &#125; db DFS(int u, db f) &#123; if (u == T || f == 0) return f; db w, used = 0; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; if (edge[i].flow &gt; 0 &amp;&amp; dep[edge[i].to] == dep[u] + 1) &#123; w = DFS(edge[i].to, min(f - used, edge[i].flow)); edge[i].flow -= w; edge[i ^ 1].flow += w; used += w; if (used == f) return f; &#125; &#125; if (!used) dep[u] = -1; return used; &#125; db solve() &#123; db ans = 0; while (BFS()) &#123; ans += DFS(S, INFLL); &#125; return ans; &#125;&#125; dicnic;int n, m;int u, v, a, b, c;ll w1[N], w2[N];int main() &#123; while (scanf(\"%d %d\", &amp;n, &amp;m) != EOF) &#123; memset(w1, 0, sizeof w1); memset(w2, 0, sizeof w2); dicnic.Init(); dicnic.S = 0, dicnic.T = n + 1; ll ans = 0; for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%d %d %d %d %d\", &amp;u, &amp;v, &amp;a, &amp;b, &amp;c); w1[u] += a + b; w1[v] += a + b; w2[u] += b + c; w2[v] += b + c; dicnic.addedge(u, v, -b * 1.0 + a / 2.0 + c / 2.0); dicnic.addedge(v, u, -b * 1.0 + a / 2.0 + c / 2.0); ans += a + b + c; &#125; for (int i = 1; i &lt;= n; ++i) &#123; dicnic.addedge(dicnic.S, i, w1[i] / 2.0); dicnic.addedge(i, dicnic.T, w2[i] / 2.0); &#125; ans = (ll) round(ans - dicnic.solve()); printf(\"%lld\\n\", ans); &#125; return 0;&#125; J. Just Skip The Problem签到 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll p = (ll) 1e6 + 3;#define N 1000010int n;ll f[N];void Init() &#123; f[0] = 1; for (int i = 1; i &lt; N; ++i) &#123; f[i] = f[i - 1] * i % p; &#125;&#125;int main() &#123; Init(); while (scanf(\"%d\", &amp;n) != EOF) &#123; printf(\"%lld\\n\", f[min(1ll * n, p)]); &#125; return 0;&#125; K. Keen On Everything But Triangle题意：问区间$[L,R]$内能组成的三角形最大周长 思路：线段树维护区间内最大的$50$个数，求三角形周长。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define N 100010 #define INF 0x3f3f3f3fint n, q, a[N];struct SEG &#123; struct node &#123; int a[55]; node() &#123; a[0] = 0; &#125; void add(int x) &#123; a[++a[0]] = x; &#125; node operator + (const node &amp;other) const &#123; node res = node(); int it = 1, it2 = 1; while (res.a[0] &lt;= 50 &amp;&amp; (it &lt;= a[0] || it2 &lt;= other.a[0])) &#123; if (it &gt; a[0]) &#123; res.add(other.a[it2]); ++it2; &#125; else if (it2 &gt; other.a[0]) &#123; res.add(a[it]); ++it; &#125; else &#123; if (a[it] &gt; other.a[it2]) &#123; res.add(a[it]); ++it; &#125; else &#123; res.add(other.a[it2]); ++it2; &#125; &#125; &#125; return res; &#125; &#125;t[N &lt;&lt; 2], res; void build(int id, int l, int r) &#123; if (l == r) &#123; t[id] = node(); t[id].add(a[l]); return; &#125; int mid = (l + r) &gt;&gt; 1; build(id &lt;&lt; 1, l, mid); build(id &lt;&lt; 1 | 1, mid + 1, r); t[id] = t[id &lt;&lt; 1] + t[id &lt;&lt; 1 | 1]; &#125; void query(int id, int l, int r, int ql, int qr) &#123; if (l &gt;= ql &amp;&amp; r &lt;= qr) &#123; res = res + t[id]; return; &#125; int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) query(id &lt;&lt; 1, l, mid, ql, qr); if (qr &gt; mid) query(id &lt;&lt; 1 | 1, mid + 1, r, ql, qr); &#125;&#125;seg;int main() &#123; while (scanf(\"%d%d\", &amp;n, &amp;q) != EOF) &#123; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); seg.build(1, 1, n); int l, r; while (q--) &#123; scanf(\"%d%d\", &amp;l, &amp;r); ll res = -1; seg.res = SEG::node(); seg.query(1, 1, n, l, r); int sze = seg.res.a[0]; for (int i = 1; i &lt;= sze - 2; ++i) &#123; ll A = seg.res.a[i], B = seg.res.a[i + 1], C = seg.res.a[i + 2]; if (A &lt; B + C) &#123; res = A + B + C; break; &#125; &#125; printf(\"%lld\\n\", res); &#125; &#125; return 0;&#125; L. Longest Subarray12","categories":[],"tags":[{"name":"HDU多校","slug":"HDU多校","permalink":"https://hsueh37.gitee.io/blog/tags/HDU%E5%A4%9A%E6%A0%A1/"}]},{"title":"Educational Codeforces Round 69 (Rated for Div. 2)","slug":"Educational-Codeforces-Round-69-(Rated-for-Div.-2)","date":"2019-07-23T06:20:00.000Z","updated":"2020-04-28T09:02:42.266Z","comments":true,"path":"2019/07/23/Educational-Codeforces-Round-69-(Rated-for-Div.-2)/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/07/23/Educational-Codeforces-Round-69-(Rated-for-Div.-2)/","excerpt":"","text":"A. DIY Wooden Ladder签到。 123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010int n;int a[N];int main() &#123;// freopen(\"input.txt\", \"r\", stdin); int t; scanf(\"%d\", &amp;t); while (t--) &#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); &#125; sort(a + 1, a + 1 + n); int ans = n - 2; ans = min(ans, a[n] - 1); ans = min(ans, a[n - 1] - 1); printf(\"%d\\n\", ans); &#125; return 0;&#125; B.Pillars题意：有$n$根柱子，每根柱子上有一个磁盘，每个磁盘都有自己的半径，第$i$根柱子上的磁盘能移动到第$j$根柱子上的前提是： $i$和$j$相邻 第$i$根柱子上只有一个磁盘 第$j$根柱子没有磁盘或者顶部磁盘半径大于第$i$根柱子 问能否将所有磁盘移动到一根柱子上。 思路：很显然只能先递增后递减的形式。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;#define N 200010int n;int a[N];bool solve() &#123; int Max = 0, pos = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (a[i] &gt; Max) &#123; Max = a[i]; pos = i; &#125; &#125; for (int i = 2; i &lt;= pos; ++i) &#123; if (a[i] &lt; a[i - 1]) &#123; return false; &#125; &#125; for (int i = pos; i &lt; n; ++i) &#123; if (a[i + 1] &gt; a[i]) &#123; return false; &#125; &#125; return true;&#125;int main() &#123;// freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;n) != EOF) &#123; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); &#125; puts(solve() ? \"YES\" : \"NO\"); &#125; return 0;&#125; C.Array Splitting题意：有一个长度为$n$的序列$a$，将序列分成$k$段，使得$\\sum_{i=1}^{k}(max(i)-min(i))$最小，其中$max(i)$表示第$i$段最大值，$min(i)$表示第$i$段最小值，且保证$a_i$非降序。 思路：$\\sum_{i=1}^k (max(i)-min(i))=a_n-a_1+\\sum_{i=1}^{k-1} a_{b_i}-a_{b_i+1} $其中$b_i$表示第$i$段末尾下标，很显然贪心选取$k-1$个即可。 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define INF 0x3f3f3f#define N 300010int n, k;ll a[N];vector&lt;ll&gt; vec;int main() &#123;// freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d %d\", &amp;n, &amp;k) != EOF) &#123; vec.clear(); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%lld\", a + i); if (i != 1) &#123; vec.push_back(a[i] - a[i - 1]); &#125; &#125; sort(vec.begin(), vec.end()); ll ans = a[n] - a[1]; for (int len = vec.size(), i = len - 1; i &gt;= len - k + 1; --i) &#123; ans -= vec[i]; &#125; printf(\"%lld\\n\", ans); &#125; return 0;&#125; D.Yet Another Subarray Problem题意：给出一个长度为$n$的序列$a$，以及$m,k$，求$\\sum_{i=l}^{r}a_i-k\\lceil \\frac{r-l+1}{m}\\rceil$的最大值 思路：$dp[i]$表示到$i$节点作为末尾的最大值，对于每个节点$i$很显然只能选取$i$前面不到$m$个数，或者选满$m$个数后再加上$dp[i-m]$，由此转移下去去中间值最大值即可。 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define INF 0x3f3f3f#define N 300010int n, m, k;ll a[N];ll dp[N];ll ans;int main() &#123;// freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k) != EOF) &#123; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%lld\", a + i); &#125; memset(dp, 0, sizeof dp); ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; ll Max = a[i], sum = 0; for (int j = i; j &gt;= 1 &amp;&amp; j &gt;= i - m + 1; --j) &#123; sum += a[j]; Max = max(Max, sum); &#125; dp[i] = max(dp[i], max(Max - k, sum - k + dp[max(i - m, 0)])); ans = max(ans, dp[i]); &#125; printf(\"%lld\\n\", ans); &#125; return 0;&#125; E.Culture Code题意：有$n$个俄罗斯套娃，每个套娃有两个属性$in,out(out&gt;in)$，套娃$i$能放在$j$对的前提是$out_i&lt;=in_j$。 定义一组套娃的额外空间为$in_{i_1}+(in_{i_2}-out_{i_1})+(in_{i_3}-out_{i_2})+\\cdots+(in_{i_k}-out_{i_{k-1}})$，其中$i_1,i_2,\\cdots,i_k$为这组套娃的下标。 定义一组套娃是个极大套娃组：当且仅当不能再有另外一个套娃套在他们身上了。 询问有多少种极大套娃组的额外空间最小 思路：$f[i]$表示使用$i$的最小额外空间，$g[i]$为使用$i$的方案数。对于每个套娃，比它大的最小的俄罗斯套娃。如果和$i+1$套娃的额外空间相同，则加上$i+1$的方案数，如果比$i+1$套娃的额外空间大，则舍弃当前套娃的方案数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;ll, ll&gt; pll;#define INFLL 0x3f3f3f3f3f3f3f#define N 400010const ll p = (ll) 1e9 + 7;int n;pll a[N];ll f[N], g[N];void add(ll &amp;x, ll y) &#123; x += y; if (x &gt;= p) &#123; x -= p; &#125;&#125;int main() &#123;// freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%d\", &amp;n) != EOF) &#123; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%lld %lld\", &amp;a[i].second, &amp;a[i].first); &#125; sort(a + 1, a + 1 + n); f[n + 1] = INFLL; for (int i = n; i &gt;= 1; --i) &#123; int pos = lower_bound(a + i, a + 1 + n, pll(a[i].second, -1)) - a; if (pos == n + 1) &#123; f[i] = a[i].first; g[i] = 1ll; &#125; else &#123; f[i] = a[i].first - a[i].second + f[pos]; g[i] = g[pos]; &#125; if (f[i] == f[i + 1]) &#123; add(g[i], g[i + 1]); &#125; else if (f[i] &gt; f[i + 1]) &#123; f[i] = f[i + 1]; g[i] = g[i + 1]; &#125; &#125; printf(\"%lld\\n\", g[1]); &#125; return 0;&#125;","categories":[],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://hsueh37.gitee.io/blog/tags/Codeforces/"}]},{"title":"2019 Multi-University Training Contest 1","slug":"2019-Multi-University-Training-Contest-1","date":"2019-07-22T11:40:20.000Z","updated":"2020-04-28T09:02:42.259Z","comments":true,"path":"2019/07/22/2019-Multi-University-Training-Contest-1/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/07/22/2019-Multi-University-Training-Contest-1/","excerpt":"","text":"D. Vacation题意：有$n+1$辆车，每辆车有自己的长度，距离终点时间，速度。求第$0$辆车到达终点时间。其中不能超车，且车过终点后依旧向前行驶 思路：枚举每个车作为某个连续段的队头，然后取$Max$ 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef double db;#define N 100010int n;struct node &#123; db l, s, v;&#125; a[N];db sum;int main() &#123; while (scanf(\"%d\", &amp;n) != EOF) &#123; sum = 0; for (int i = n; i &gt;= 0; --i) &#123; scanf(\"%lf\", &amp;a[i].l); sum += a[i].l; &#125; for (int i = n; i &gt;= 0; --i) &#123; scanf(\"%lf\", &amp;a[i].s); &#125; for (int i = n; i &gt;= 0; --i) &#123; scanf(\"%lf\", &amp;a[i].v); &#125; sum -= a[n].l; db ans = 0; for (int i = 0; i &lt;= n; ++i) &#123; ans = max(ans, (sum + a[i].s) / a[i].v); sum -= a[i].l; &#125; printf(\"%.10f\\n\", ans); &#125; return 0;&#125; E. Path题意：破坏一条路径的代价为路径长度，求破坏所有最短路的最小代价 思路：跑一边最短路后重建图跑最大流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef pair&lt;int, int&gt; pii;#define INFLL 0x3f3f3f3f3f3f3f3f#define N 20010int n, m;struct Dicnic &#123; struct Edge &#123; int to, nxt; ll flow; Edge() &#123;&#125; Edge(int to, int nxt, ll flow) : to(to), nxt(nxt), flow(flow) &#123;&#125; &#125; edge[N &lt;&lt; 1]; int head[N], tot; int dep[N]; void Init() &#123; memset(head, -1, sizeof head); tot = 0; &#125; void addedge(int u, int v, int w, int rw = 0) &#123; edge[tot] = Edge(v, head[u], w); head[u] = tot++; edge[tot] = Edge(u, head[v], rw); head[v] = tot++; &#125; bool BFS() &#123; memset(dep, -1, sizeof dep); queue&lt;int&gt; q; q.push(1); dep[1] = 1; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int i = head[u]; ~i; i = edge[i].nxt) &#123; if (edge[i].flow &amp;&amp; dep[edge[i].to] == -1) &#123; dep[edge[i].to] = dep[u] + 1; q.push(edge[i].to); &#125; &#125; &#125; return dep[n] &gt;= 0; &#125; ll DFS(int u, ll f) &#123; if (u == n || f == 0) return f; ll w, used = 0; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; if (edge[i].flow &amp;&amp; dep[edge[i].to] == dep[u] + 1) &#123; w = DFS(edge[i].to, min(f - used, edge[i].flow)); edge[i].flow -= w; edge[i ^ 1].flow += w; used += w; if (used == f) return f; &#125; &#125; if (!used) dep[u] = -1; return used; &#125; ll solve() &#123; ll ans = 0; while (BFS()) &#123; ans += DFS(1, INFLL); &#125; return ans; &#125;&#125; dicnic;struct Edge &#123; int u, to, nxt, w; Edge() &#123;&#125; Edge(int u, int to, int nxt, int w) : u(u), to(to), nxt(nxt), w(w) &#123;&#125;&#125; edge[N &lt;&lt; 1];struct qnode &#123; int u; ll w; qnode() &#123;&#125; qnode(int u, ll w) : u(u), w(w) &#123;&#125; bool operator&lt;(const qnode &amp;other) const &#123; return w &gt; other.w; &#125;&#125;;int head[N], tot;ll dis[N];void Init() &#123; memset(dis, 0x3f, sizeof dis); memset(head, -1, sizeof head); tot = 0;&#125;void addedge(int u, int v, ll w) &#123; edge[tot] = Edge(u, v, head[u], w); head[u] = tot++;&#125;void Dijkstra() &#123; priority_queue&lt;qnode&gt; q; q.push(qnode(1, 0)); dis[1] = 0ll; while (!q.empty()) &#123; int u = q.top().u; q.pop(); for (int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to; ll w = edge[i].w; if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; q.push(qnode(v, dis[v])); &#125; &#125; &#125;&#125;int main() &#123;// freopen(\"input.txt\", \"r\", stdin); int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%d %d\", &amp;n, &amp;m); Init(); for (int i = 1, u, v, w; i &lt;= m; ++i) &#123; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); addedge(u, v, w); &#125; Dijkstra(); dicnic.Init(); for (int i = 0; i &lt; tot; ++i) &#123; int u = edge[i].u; int v = edge[i].to; ll w = edge[i].w; if (dis[v] == dis[u] + w) &#123; dicnic.addedge(u, v, w); &#125; &#125; printf(\"%lld\\n\", dicnic.solve()); &#125; return 0;&#125; I. String题意：构造一个子序列，长度为$k$，且各个字母$i$，出现次数在$l_i-r_i$之间 思路：贪心从小到大枚举每一位能否放在答案中，检查放入后剩余后缀串能否满足限制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010int n, k;char s[N], ans[N];int cnt[N][26], used[N], l[N], r[N];vector&lt;int&gt; G[26];void solve() &#123; for (int i = n; i &gt;= 1; --i) &#123; for (int j = 0; j &lt; 26; ++j) &#123; cnt[i][j] = cnt[i + 1][j]; &#125; cnt[i][s[i] - 'a']++; &#125; for (int i = 1; i &lt;= n; ++i) &#123; G[s[i] - 'a'].push_back(i); &#125; vector&lt;int&gt;::iterator head[26]; for (int i = 0; i &lt; 26; ++i) &#123; head[i] = G[i].begin(); &#125; int lst = 0; for (int i = 1; i &lt;= k; ++i) &#123; int flag = 0; for (int j = 0; j &lt; 26; ++j) &#123; if (used[j] == r[j]) continue; if (head[j] == G[j].end()) continue; while (head[j] != G[j].end() &amp;&amp; *head[j] &lt;= lst) head[j]++; if (head[j] == G[j].end()) continue; used[j]++; int f = 1; int now = *head[j], need = 0; for (int o = 0; o &lt; 26; ++o) &#123; if (cnt[now + 1][o] + used[o] &lt; l[o]) &#123; f = 0; break; &#125; need += max(l[o] - used[o], 0); &#125; if (need &gt; k - i) &#123; f = 0; &#125; if (f == 0) &#123; used[j]--; &#125; else &#123; ans[i] = j + 'a'; flag = 1; lst = now; break; &#125; &#125; if (flag == 0) &#123; puts(\"-1\"); return; &#125; &#125; ans[k + 1] = 0; printf(\"%s\\n\", ans + 1);&#125;int main() &#123;// freopen(\"input.txt\", \"r\", stdin); while (scanf(\"%s %d\", s + 1, &amp;k) != EOF) &#123; n = strlen(s + 1); for (int i = 0; i &lt; 26; ++i) &#123; scanf(\"%d %d\", l + i, r + i); G[i].clear(); &#125; memset(used, 0, sizeof used); memset(cnt, 0, sizeof cnt); solve(); &#125; return 0;&#125;","categories":[],"tags":[{"name":"HUD多校","slug":"HUD多校","permalink":"https://hsueh37.gitee.io/blog/tags/HUD%E5%A4%9A%E6%A0%A1/"}]},{"title":"黑科技","slug":"黑科技","date":"2019-07-20T15:00:20.000Z","updated":"2020-04-28T09:02:42.279Z","comments":true,"path":"2019/07/20/黑科技/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/07/20/%E9%BB%91%E7%A7%91%E6%8A%80/","excerpt":"","text":"BM线性递推123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//O(n^2) n是传入的数//输入的n是第几个数 #include&lt;bits/stdc++.h&gt;using namespace std;#define rep(i,a,n) for (int i=a;i&lt;n;i++)#define per(i,a,n) for (int i=n-1;i&gt;=a;i--)#define pb push_back#define mp make_pair#define all(x) (x).begin(),(x).end()#define fi first#define se second#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef long long ll;typedef pair&lt;int,int&gt; PII;const ll mod=1000000007;ll powmod(ll a,ll b) &#123;ll res=1;a%=mod; assert(b&gt;=0); for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125;ll _,n;namespace linear_seq&#123; const int N=10010; ll res[N],base[N],_c[N],_md[N]; vector&lt;ll&gt; Md; void mul(ll *a,ll *b,int k) &#123; rep(i,0,k+k) _c[i]=0; rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod; for (int i=k+k-1;i&gt;=k;i--) if (_c[i]) rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod; rep(i,0,k) a[i]=_c[i]; &#125; int solve(ll n,VI a,VI b) &#123; ll ans=0,pnt=0; int k=SZ(a); assert(SZ(a)==SZ(b)); rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1; Md.clear(); rep(i,0,k) if (_md[i]!=0) Md.push_back(i); rep(i,0,k) res[i]=base[i]=0; res[0]=1; while ((1ll&lt;&lt;pnt)&lt;=n) pnt++; for (int p=pnt;p&gt;=0;p--) &#123; mul(res,res,k); if ((n&gt;&gt;p)&amp;1) &#123; for (int i=k-1;i&gt;=0;i--) res[i+1]=res[i];res[0]=0; rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod; &#125; &#125; rep(i,0,k) ans=(ans+res[i]*b[i])%mod; if (ans&lt;0) ans+=mod; return ans; &#125; VI BM(VI s) &#123; VI C(1,1),B(1,1); int L=0,m=1,b=1; rep(n,0,SZ(s)) &#123; ll d=0; rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod; if (d==0) ++m; else if (2*L&lt;=n) &#123; VI T=C; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; L=n+1-L; B=T; b=d; m=1; &#125; else &#123; ll c=mod-d*powmod(b,mod-2)%mod; while (SZ(C)&lt;SZ(B)+m) C.pb(0); rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod; ++m; &#125; &#125; return C; &#125; int gao(VI a,ll n)&#123; VI c=BM(a); c.erase(c.begin()); rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod; return solve(n,c,VI(a.begin(),a.begin()+SZ(c))); &#125;&#125;;int main()&#123; int t; scanf(\"%d\",&amp;t); while(t--) &#123; scanf(\"%lld\",&amp;n); vector&lt;int&gt;v &#123;2,3,4,5,7,9,12,15,19,24,31,40,52,67,86,110,141,181,233,300,386,496,637&#125;; // n = v.size(); // v.push_back(&#123;2,3,4,5,7,9,12,15,19,24,31,40,52,67,86,110,141,181,233,300,386,496,637&#125;); //至少8项，越多越好。 printf(\"%lld\\n\",linear_seq::gao(v,n-1)%mod); &#125;&#125; 自适应辛普森积分1234567891011121314151617181920double F(double x)&#123; //Simpson公式用到的函数&#125;double simpson(double a, double b)//三点Simpson法，这里要求F是一个全局函数&#123; double c = a + (b - a) / 2; return (F(a) + 4 * F(c) + F(b))*(b - a) / 6;&#125;double asr(double a, double b, double eps, double A)//自适应Simpson公式（递归过程）。已知整个区间[a,b]上的三点Simpson值A&#123; double c = a + (b - a) / 2; double L = simpson(a, c), R = simpson(c, b); if (fabs(L + R - A) &lt;= 15 * eps)return L + R + (L + R - A) / 15.0; return asr(a, c, eps / 2, L) + asr(c, b, eps / 2, R);&#125;double asr(double a, double b, double eps)//自适应Simpson公式（主过程）&#123; return asr(a, b, eps, simpson(a, b));&#125; 拉格朗日插指// 适用范围，求n次多项式第x项的值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667namespace polysum &#123; #define rep(i,a,n) for (int i=a;i&lt;n;i++) #define per(i,a,n) for (int i=n-1;i&gt;=a;i--) const int D=1e6+10; ll a[D],f[D],g[D],p[D],p1[D],p2[D],b[D],h[D][2],C[D]; ll powmod(ll a,ll b)&#123;ll res=1;a%=mod;assert(b&gt;=0);for(;b;b&gt;&gt;=1)&#123;if(b&amp;1)res=res*a%mod;a=a*a%mod;&#125;return res;&#125; //.......................... // 已知a_i 的d次多项式，求第n项 ll calcn(int d,ll *a,ll n) &#123; // a[0].. a[d] a[n] if (n&lt;=d) return a[n]; p1[0]=p2[0]=1; rep(i,0,d+1) &#123; ll t=(n-i+mod)%mod; p1[i+1]=p1[i]*t%mod; &#125; rep(i,0,d+1) &#123; ll t=(n-d+i+mod)%mod; p2[i+1]=p2[i]*t%mod; &#125; ll ans=0; rep(i,0,d+1) &#123; ll t=g[i]*g[d-i]%mod*p1[i]%mod*p2[d-i]%mod*a[i]%mod; if ((d-i)&amp;1) ans=(ans-t+mod)%mod; else ans=(ans+t)%mod; &#125; return ans; &#125; // 初始化，初始化的时候记得将D的值 void init(int M) &#123; f[0]=f[1]=g[0]=g[1]=1; rep(i,2,M+5) f[i]=f[i-1]*i%mod; g[M+4]=powmod(f[M+4],mod-2); per(i,1,M+4) g[i]=g[i+1]*(i+1)%mod; &#125;// 已知a_i，并且知道a_i是m次多项式 ll polysum(ll m,ll *a,ll n) &#123; // a[0].. a[m] \\sum_&#123;i=0&#125;^&#123;n&#125; a[i] ll b[D]; ll b[D]; for(int i=0;i&lt;=m;i++) b[i]=a[i]; b[m+1]=calcn(m,b,m+1); rep(i,1,m+2) b[i]=(b[i-1]+b[i])%mod; return calcn(m+1,b,n);// m次多项式的和是m+1 次多项式 &#125; ll qpolysum(ll R,ll n,ll *a,ll m) &#123; // a[0].. a[m] \\sum_&#123;i=0&#125;^&#123;n-1&#125; a[i]*R^i if (R==1) return polysum(n,a,m); a[m+1]=calcn(m,a,m+1); ll r=powmod(R,mod-2),p3=0,p4=0,c,ans; h[0][0]=0;h[0][1]=1; rep(i,1,m+2) &#123; h[i][0]=(h[i-1][0]+a[i-1])*r%mod; h[i][1]=h[i-1][1]*r%mod; &#125; rep(i,0,m+2) &#123; ll t=g[i]*g[m+1-i]%mod; if (i&amp;1) p3=((p3-h[i][0]*t)%mod+mod)%mod,p4=((p4-h[i][1]*t)%mod+mod)%mod; else p3=(p3+h[i][0]*t)%mod,p4=(p4+h[i][1]*t)%mod; &#125; c=powmod(p4,mod-2)*(mod-p3)%mod; rep(i,0,m+2) h[i][0]=(h[i][0]+h[i][1]*c)%mod; rep(i,0,m+2) C[i]=h[i][0]; ans=(calcn(m,C,n)*powmod(R,n)-c)%mod; if (ans&lt;0) ans+=mod; return ans; &#125;&#125; // polysum::init();","categories":[],"tags":[{"name":"知识点","slug":"知识点","permalink":"https://hsueh37.gitee.io/blog/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"}]},{"title":"2019牛客暑期多校训练营（第二场）","slug":"2019牛客暑期多校训练营（第二场）","date":"2019-07-20T12:00:20.000Z","updated":"2020-04-28T09:02:42.262Z","comments":true,"path":"2019/07/20/2019牛客暑期多校训练营（第二场）/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/07/20/2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%9C%BA%EF%BC%89/","excerpt":"","text":"A. Eddy Walker题意：有$n$个点，刚开始在$0$号点，每次等概率的往左右走，为最终停留在$m$点的概率 思路：打表后发现概率为$\\frac{1}{n - 1}$ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll p = (ll) 1e9 + 7;ll qpow(ll x, ll n) &#123; ll res = 1; while (n) &#123; if (n &amp; 1) &#123; res = res * x % p; &#125; x = x * x % p; n &gt;&gt;= 1; &#125; return res;&#125;int n, m;int main() &#123; int t; scanf(\"%d\", &amp;t); ll ans = 1; while (t--) &#123; scanf(\"%d %d\", &amp;n, &amp;m); if (n == 1) &#123; ans *= 1; &#125; else if (m == 0) &#123; ans = 0; &#125; else &#123; ans = ans * qpow(n - 1, p - 2) % p; &#125; printf(\"%lld\\n\", ans); &#125; return 0;&#125; B. Eddy Walker 2题意：从$0$开始，每次有$\\frac{1}{k}$的概率走$1,2,\\cdots.k$步，问最后停留在$n$的概率 思路：$f[i]$表示最后停留在$i$点的概率，那么$f[i]=\\frac{1}{k} \\cdot \\sum_{j=1}^{k} f[i - j]$，BM递推即可… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long long#define N 1000010const ll p = 1e9 + 7;ll n, m, k, inv2, invk;ll f[N], g[N], fac[N], inv[N];ll qmod(ll base, ll n) &#123; base %= p; ll res = 1; while (n) &#123; if (n &amp; 1) &#123; res = res * base % p; &#125; base = base * base % p; n &gt;&gt;= 1; &#125; return res;&#125;void add(ll &amp;x, ll y) &#123; x += y; if (x &gt;= p) x -= p;&#125;#define rep(i, a, n) for (int i=a;i&lt;n;i++)#define pb push_back#define SZ(x) ((int)(x).size())typedef vector&lt;int&gt; VI;typedef pair&lt;int, int&gt; PII;const ll mod = 1000000007;// headint _;namespace linear_seq &#123; ll res[N], base[N], _c[N], _md[N]; vector&lt;int&gt; Md; void mul(ll *a, ll *b, int k) &#123; rep(i, 0, k + k) _c[i] = 0; rep(i, 0, k) if (a[i]) rep(j, 0, k) _c[i + j] = (_c[i + j] + a[i] * b[j]) % mod; for (int i = k + k - 1; i &gt;= k; i--) if (_c[i]) rep(j, 0, SZ(Md)) _c[i - k + Md[j]] = (_c[i - k + Md[j]] - _c[i] * _md[Md[j]]) % mod; rep(i, 0, k) a[i] = _c[i]; &#125; int solve(ll n, VI a, VI b) &#123; // a 系数 b 初值 b[n+1]=a[0]*b[n]+... // printf(\"%d\\n\",SZ(b)); ll ans = 0, pnt = 0; int k = SZ(a); assert(SZ(a) == SZ(b)); rep(i, 0, k) _md[k - 1 - i] = -a[i]; _md[k] = 1; Md.clear(); rep(i, 0, k) if (_md[i] != 0) Md.push_back(i); rep(i, 0, k) res[i] = base[i] = 0; res[0] = 1; while ((1ll &lt;&lt; pnt) &lt;= n) pnt++; for (int p = pnt; p &gt;= 0; p--) &#123; mul(res, res, k); if ((n &gt;&gt; p) &amp; 1) &#123; for (int i = k - 1; i &gt;= 0; i--) res[i + 1] = res[i]; res[0] = 0; rep(j, 0, SZ(Md)) res[Md[j]] = (res[Md[j]] - res[k] * _md[Md[j]]) % mod; &#125; &#125; rep(i, 0, k) ans = (ans + res[i] * b[i]) % mod; if (ans &lt; 0) ans += mod; return ans; &#125; VI BM(VI s) &#123; VI C(1, 1), B(1, 1); int L = 0, m = 1, b = 1; rep(n, 0, SZ(s)) &#123; ll d = 0; rep(i, 0, L + 1) d = (d + (ll) C[i] * s[n - i]) % mod; if (d == 0) ++m; else if (2 * L &lt;= n) &#123; VI T = C; ll c = mod - d * qmod(b, mod - 2) % mod; while (SZ(C) &lt; SZ(B) + m) C.pb(0); rep(i, 0, SZ(B)) C[i + m] = (C[i + m] + c * B[i]) % mod; L = n + 1 - L; B = T; b = d; m = 1; &#125; else &#123; ll c = mod - d * qmod(b, mod - 2) % mod; while (SZ(C) &lt; SZ(B) + m) C.pb(0); rep(i, 0, SZ(B)) C[i + m] = (C[i + m] + c * B[i]) % mod; ++m; &#125; &#125; return C; &#125; int gao(VI a, ll n) &#123; VI c = BM(a); c.erase(c.begin()); rep(i, 0, SZ(c)) c[i] = (mod - c[i]) % mod; return solve(n, c, VI(a.begin(), a.begin() + SZ(c))); &#125;&#125;;int main() &#123; int T; scanf(\"%d\", &amp;T); while (T--) &#123; scanf(\"%lld%lld\", &amp;k, &amp;n); invk = qmod(k, p - 2); if (n == -1) &#123; printf(\"%lld\\n\", 2ll * qmod(k + 1, p - 2) % p); continue; &#125; for (int i = 1; i &lt;= m; ++i) f[i] = 0; f[0] = 1; g[0] = 1; for (int i = 1; i &lt;= 2 * k; ++i) &#123; if (i &gt; k) &#123; add(f[i], invk * (g[i - 1] - g[i - k - 1] + p) % p); &#125; else &#123; add(f[i], invk * g[i - 1] % p); &#125; g[i] = (g[i - 1] + f[i]) % p; &#125; vector&lt;int&gt; vec; for (int i = 0; i &lt;= 2 * k; ++i) vec.push_back(f[i]); printf(\"%d\\n\", linear_seq::gao(vec, n)); &#125; return 0;&#125; D.Kth Minimum Clique题意：输出第$k$个$Clique$ 思路：每次取最小权值的$Clique$，增加$Clique$的点，重新丢到优先队列中，重复$k$次。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;typedef bitset&lt;110&gt; bs;#define N 110struct node &#123; bs S; ll sum; node() &#123;&#125; node(bs S, ll sum) : S(S), sum(sum) &#123;&#125; bool operator&lt;(const node &amp;other) const &#123; return sum &gt; other.sum; &#125;&#125;;int n, K;ll v[N];bs e[N];priority_queue&lt;node&gt; pq;int main() &#123; scanf(\"%d %d\", &amp;n, &amp;K); for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%lld\", v + i); &#125; for (int i = 1, x; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; scanf(\"%1d\", &amp;x); if (x == 1) &#123; e[i].set(j); &#125; &#125; &#125; bs s; s.reset(); pq.push(node(s, 0)); while (!pq.empty()) &#123; node u = pq.top(); pq.pop(); K--; if (K == 0) &#123; printf(\"%lld\\n\", u.sum); return 0; &#125; s = u.S; int pos = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (s[i]) &#123; pos = i; &#125; &#125; for (int i = pos + 1; i &lt;= n; ++i) &#123; if (!s[i] &amp;&amp; ((s &amp; e[i]) == s)) &#123; s.set(i); pq.push(node(s, u.sum + v[i])); s.reset(i); &#125; &#125; &#125; puts(\"-1\"); return 0;&#125; F. Partition problem题意：有$2\\cdot N$个人，将这$2\\cdot N$个人分为两个集合，每个集合为$N$个人，总的贡献是每对属于两个集合的人的贡献 思路：爆搜$C_{2\\cdot N} ^ {N}$，所以总复杂度为$O(N \\cdot C_{2 \\cdot N} ^ {N})$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 40int n, m;int v[N][N];ll ans, tnow;int arr[N], brr[N];inline void calc() &#123; ll res = 0; for (register int i = 1; i &lt;= m; ++i) &#123; for (register int j = 1; j &lt;= m; ++j) &#123; res += v[arr[i]][brr[j]]; &#125; &#125; ans = max(ans, res);&#125;void DFS(int pos, int cnt, ll now) &#123; // 1 if (cnt == n - pos + 1) &#123; int tmp = arr[0]; tnow = now; for (register int i = pos; i &lt;= n; ++i) &#123; arr[++arr[0]] = i; for (int j = 1; j &lt;= m; ++j) &#123; tnow += v[i][brr[j]]; &#125; &#125; ans = max(ans, tnow); arr[0] = tmp; return; &#125; if (cnt) &#123; arr[++arr[0]] = pos; tnow = now; for (int j = 1; j &lt;= brr[0]; ++j) &#123; tnow += v[pos][brr[j]]; &#125; if (pos &lt; n) &#123; DFS(pos + 1, cnt - 1, tnow); &#125; else &#123; ans = max(ans, tnow); &#125; --arr[0]; &#125; //0 brr[++brr[0]] = pos; tnow = now; for (int i = 1; i &lt;= arr[0]; ++i) &#123; tnow += v[arr[i]][pos]; &#125; if (pos &lt; n) &#123; DFS(pos + 1, cnt, tnow); &#125; else &#123; ans = max(ans, tnow); &#125; --brr[0];&#125;int main() &#123; scanf(\"%d\", &amp;n); m = n; n &lt;&lt;= 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; scanf(\"%d\", &amp;v[i][j]); &#125; &#125; DFS(1, m, 0ll); printf(\"%lld\\n\", ans); return 0;&#125; H.Second Large Rectangle题意：找第二大的全为$1$的矩阵 思路：找出第一个最大的矩阵，然后将四个角分别赋值为$0$，然后找最大的矩阵，取$MAX$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#define N 1010int n, m;int G[N][N], T[N][N], l[N][N], r[N][N], up[N][N];void get(int G[][N], int &amp;x, int &amp;y, int &amp;row, int &amp;col) &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; l[i][j] = r[i][j] = j; up[i][j] = 1; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 2; j &lt;= m; ++j) &#123; if (G[i][j] == 1 &amp;&amp; G[i][j] == G[i][j - 1]) &#123; l[i][j] = l[i][j - 1]; &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = m - 1; j &gt;= 1; --j) &#123; if (G[i][j] == 1 &amp;&amp; G[i][j] == G[i][j + 1]) &#123; r[i][j] = r[i][j + 1]; &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (i &gt; 1 &amp;&amp; G[i][j] == 1 &amp;&amp; G[i][j] == G[i - 1][j]) &#123; l[i][j] = max(l[i][j], l[i - 1][j]); r[i][j] = min(r[i][j], r[i - 1][j]); up[i][j] = up[i - 1][j] + 1; &#125; if (G[i][j] == 1) &#123; int tcol = r[i][j] - l[i][j] + 1; int trow = up[i][j]; if (tcol * trow &gt; row * col) &#123; col = tcol; row = trow; x = i - up[i][j] + 1; y = l[i][j]; &#125; &#125; &#125; &#125;&#125;int main() &#123; while (scanf(\"%d%d\", &amp;n, &amp;m) != EOF) &#123; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; scanf(\"%1d\", G[i] + j); T[i][j] = G[i][j]; &#125; &#125; int x, y, tx, ty, row = 0, col = 0, trow = 0, tcol = 0; get(G, x, y, row, col); // cout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \" \" &lt;&lt; row &lt;&lt; \" \" &lt;&lt; col &lt;&lt; endl; if (row == 0) &#123; printf(\"0\\n\"); &#125; else &#123; T[x][y] = 0; get(T, tx, ty, trow, tcol); T[x][y] = 1; T[x + row - 1][y] = 0; get(T, tx, ty, trow, tcol); T[x + row - 1][y] = 1; T[x][y + col - 1] = 0; get(T, tx, ty, trow, tcol); T[x][y + col - 1] = 1; T[x + row - 1][y + col - 1] = 0; get(T, tx, ty, trow, tcol); printf(\"%d\\n\", trow * tcol); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"2019牛客多校","slug":"2019牛客多校","permalink":"https://hsueh37.gitee.io/blog/tags/2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"}]},{"title":"2019牛客暑期多校训练营（第一场）","slug":"2019牛客暑期多校训练营（第一场）","date":"2019-07-18T05:32:20.000Z","updated":"2020-11-30T05:04:40.938Z","comments":true,"path":"2019/07/18/2019牛客暑期多校训练营（第一场）/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/07/18/2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%B8%80%E5%9C%BA%EF%BC%89/","excerpt":"","text":"A. Equivalent Prefixes题意：定义$RMQ(u, l, r)$表示$u_l,u_{l+1},\\cdots,u_r$中最小的数的下标，而两个数组相似指的是对于任意的$1\\leq l \\leq r \\leq m(m$表示数组长度$)$都相等，问$a, b$两个数组最长的相似前缀长度 思路：二分数组长度，通过建立笛卡尔树，比较两者的前缀笛卡尔树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;bits/stdc++.h&gt;using namespace std;#define N 100010int n, a[N], b[N];struct Cartesian_Tree &#123; struct node &#123; int id, val, fa; int son[2]; node() &#123;&#125; node (int id, int val, int fa) : id(id), val(val), fa(fa) &#123; son[0] = son[1] = 0; &#125; &#125;t[N]; int root, l[N], r[N]; void init() &#123; t[0] = node(0, 0, 0); &#125; void build(int n, int *a) &#123; for (int i = 1; i &lt;= n; ++i) &#123; t[i] = node(i, a[i], 0); &#125; for (int i = 1; i &lt;= n; ++i) &#123; int k = i - 1; while (t[k].val &gt; t[i].val) &#123; k = t[k].fa; &#125; t[i].son[0] = t[k].son[1]; t[k].son[1] = i; t[i].fa = k; t[t[i].son[0]].fa = i; &#125; root = t[0].son[1]; &#125; int DFS(int u) &#123; if (!u) return 0; l[t[u].id] = DFS(t[u].son[0]); r[t[u].id] = DFS(t[u].son[1]); return l[t[u].id] + r[t[u].id] + 1; &#125;&#125;t[2];bool check(int x) &#123; t[0].init(); t[1].init(); t[0].build(x, a); t[1].build(x, b); t[0].DFS(t[0].root); t[1].DFS(t[1].root); for (int i = 1; i &lt;= x; ++i) &#123; if (t[0].l[i] != t[1].l[i] || t[0].r[i] != t[1].r[i]) return 0; &#125; return 1;&#125;int main() &#123; while (scanf(\"%d\", &amp;n) != EOF) &#123; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", a + i); &#125; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%d\", b + i); &#125; int l = 1, r = n, res = -1; while (r - l &gt;= 0) &#123; int mid = (l + r) &gt;&gt; 1; if (check(mid)) &#123; res = mid; l = mid + 1; &#125; else &#123; r = mid - 1; &#125; &#125; printf(\"%d\\n\", res); &#125; return 0;&#125; B. Integration题意:求$\\frac{1}{\\pi} \\cdot \\int_{0}^{\\infty}\\frac{1}{\\prod_{i=1}^{n} (a_i^2+x^2)}\\mathrm{d}x$ 思路: $\\frac{1}{\\pi} \\cdot \\int_{0}^{\\infty} \\frac{1}{a^2+x^2} \\mathrm{d}x = \\frac{1}{2\\cdot a}$ 当$n=2$ \\frac{1}{\\pi} \\cdot \\int_{0}^{\\infty} \\frac{1}{(a_1^2+x^2) \\cdot (a_2^2+x^2)} \\mathrm{d}x = \\frac{1}{\\pi} \\cdot \\int_{0}^{\\infty} \\frac{A}{a_1^2+x^2}+\\frac{B}{a_2^2+x^2} \\mathrm{d}x 发现$A=\\frac{1}{a_2^2-a_1^2}, B = \\frac{1}{a_1^2-a_2^2}$ 当$n=3$ \\frac{1}{\\pi} \\cdot \\int_{0}^{\\infty} \\frac{1}{(a_1^2+x^2) \\cdot (a_2^2+x^2) \\cdot (a_3^2+x^2)} \\mathrm{d}x = \\frac{1}{\\pi} \\cdot \\int_{0}^{\\infty} \\frac{A}{a_1^2+x^2}+\\frac{B}{a_2^2+x^2} + \\frac{C}{a_3^2+x^2} \\mathrm{d}x 发现$A=\\frac{1}{(a_2^2-a_1^2)\\cdot(a_3^2-a_1^2)}, B = \\frac{1}{(a_1^2-a_2^2)\\cdot(a_3^2-a_2^2)}, C=\\frac{1}{(a_1^2-a_3^2)\\cdot(a_2^2-a_3^2)}$ 大胆推测 \\frac{1}{\\pi} \\cdot \\int_{0}^{\\infty}\\frac{1}{\\prod_{i=1}^{n} (a_i^2+x^2)} \\mathrm{d}x=\\frac{1}{\\pi}\\sum_{i=1}^n\\frac{1}{2\\cdot \\prod_{j\\neq i}(a_j^2-a_i^2)\\cdot a_i} 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll P = (ll) 1e9 + 7;#define N 1010ll qpow(ll x, ll n) &#123; ll res = 1; while (n) &#123; if (n &amp; 1) &#123; res = res * x % P; &#125; x = x * x % P; n &gt;&gt;= 1; &#125; return res;&#125;int n;ll arr[N];int main() &#123; while (scanf(\"%d\", &amp;n) != EOF) &#123; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%lld\", arr + i); &#125; ll ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; ll tmp = 2ll * arr[i]; for (int j = 1; j &lt;= n; ++j) &#123; if (i == j) &#123; continue; &#125; tmp = tmp * (arr[j] * arr[j] % P - arr[i] * arr[i] % P + P) % P; &#125; ans = (ans + qpow(tmp, P - 2)) % P; &#125; printf(\"%lld\\n\", ans); &#125; return 0;&#125; C. Euclidean Distance题意：求$\\sum _{i=1}^{n}(\\frac{a_i}{m} ^ 2- p_i^2)$，其中满足 $p_1,p_2,\\cdots, p_n\\geq0$ $p_1 + p_2 + \\cdots + p_n = 1$ 思路： 将条件改为$p_1+p_2+\\cdots +p_n=m$ 此时$\\sum_{i=1}^{n}(\\frac{a_i}{m}^2-p_i^2)=\\sum_{i=1}^{n} (\\frac{a_i}{m}^2+\\frac{p_i}{m}^2)=\\frac{1}{m^2}\\cdot \\sum_{i=1}^{n}(a_i^2-p_i^2)$ $\\sum_{i=1}^{n}(a_i^2-p_i^2)$即矩形的高度平方。显然优先降低高度高的矩形。当$A_1$和$A_2$高度相同时看做一个矩形同时降低二者高度，直到不能降低位置，然后计算最后答案。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 10010int n;ll m;ll arr[N];struct Frac &#123; ll x, y; Frac() &#123;&#125; Frac(ll x, ll y) : x(x), y(y) &#123;&#125; Frac operator+(const Frac &amp;other) const &#123; ll up = x * other.y + y * other.x; ll down = y * other.y; ll G = __gcd(up, down); return &#123;up / G, down / G&#125;; &#125; Frac operator-(const Frac &amp;other) const &#123; ll up = x * other.y - y * other.x; ll down = y * other.y; ll G = __gcd(up, down); return &#123;up / G, down / G&#125;; &#125; Frac operator*(const Frac &amp;other) const &#123; ll up = x * other.x; ll down = y * other.y; ll G = __gcd(up, down); return &#123;up / G, down / G&#125;; &#125; void out() &#123; if (y == 1) &#123; printf(\"%lld\\n\", x); &#125; else &#123; printf(\"%lld/%lld\\n\", x, y); &#125; &#125;&#125;;int main() &#123; while (~scanf(\"%d %lld\", &amp;n, &amp;m)) &#123; for (int i = 1; i &lt;= n; ++i) &#123; scanf(\"%lld\", arr + i); &#125; sort(arr + 1, arr + 1 + n, greater&lt;ll&gt;()); ll need = m; Frac ans = Frac(0, 1); for (int i = 1; i &lt;= n; ++i) &#123; if (i &lt; n &amp;&amp; (arr[i] - arr[i + 1]) * i &lt;= need) &#123; need -= (arr[i] - arr[i + 1]) * i; &#125; else &#123; ans = ans + Frac((i * arr[i] - need) * (i * arr[i] - need), 1ll * i * m * m); for (int j = i + 1; j &lt;= n; ++j) &#123; ans = ans + Frac(arr[j] * arr[j], m * m); &#125; ans.out(); break; &#125; &#125; &#125; return 0;&#125; F. ABBA题意：对于一个长度为$2\\cdot (n+m)$的$AB$串，有多少种方案可以构造出这个$AB$串中有$n$个$AB$子序列，$m$个$BA$子序列 思路：$f[i][j]$表示已经用了$i$个$A$，$j$个$B$ $f[0]][0]=1$ 考虑如果加了一个$A$，首先满足$i+1&lt;=n+m$那么优先给$AB$贡献，也就是说$i+1-n\\leq j$，意思是即使满足$AB$串后，剩余的$A$要小于$B$的数量，同样的$B$要优先给$BA$串贡献，需要满足$j-m\\leq i+1$ 考虑如果加了一个$B$，首先满足$j+1&lt;=n+m$那么优先给$BA$贡献，也就是说$j+1-m\\leq i$，意思是即使满足$BA$串后，剩余的$B$要小于$A$的数量，同样的$A$要优先给$AB$串贡献，需要满足$i-n\\leq j+1$ 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;#define N 2010const ll p = (ll) 1e9 + 7;int n, m;ll dp[N][N];int main() &#123; while (~scanf(\"%d %d\", &amp;n, &amp;m)) &#123; for (int i = 0; i &lt;= n + m; ++i) &#123; for (int j = 0; j &lt;= n + m; ++j) &#123; dp[i][j] = 0ll; &#125; &#125; dp[0][0] = 1ll; for (int i = 0; i &lt;= n + m; ++i) &#123; for (int j = 0; j &lt;= n + m; ++j) &#123; if (i + 1 - n &lt;= j &amp;&amp; j - m &lt;= i + 1) &#123; dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % p; &#125; if (j + 1 - m &lt;= i &amp;&amp; i - n &lt;= j + 1) &#123; dp[i][j + 1] = (dp[i][j + 1] + dp[i][j]) % p; &#125; &#125; &#125; printf(\"%lld\\n\", dp[n + m][n + m]); &#125; return 0;&#125; F. Random Point in Triangle题意：在$\\triangle ABC $内等概率分布点$P$,定义$E=max(S_{PAB}, S_{PBC},S_{PCA})$，求$E$的期望的$36$倍，保证为整数 思路：同时乱打表发现$36E=22\\cdot S_{ABC}$ 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;struct node &#123; ll x, y; void input() &#123; scanf(\"%lld %lld\", &amp;x, &amp;y); &#125; ll operator ^ (const node &amp;other) const &#123; return x * other.y - y * other.x; &#125; node operator - (const node &amp;other) const &#123; return &#123;x - other.x, y - other.y&#125;; &#125;&#125;p[5];int main() &#123; while (~scanf(\"%lld %lld\", &amp;p[1].x, &amp;p[1].y)) &#123; p[2].input(); p[3].input(); ll ans = abs((p[1] - p[2]) ^ (p[1] - p[3])); ans *= 11; printf(\"%lld\\n\", ans); &#125; return 0;&#125; J. Fraction Comparision题意：比较$\\frac{x}{a}$和$\\frac{y}{b}$的大小 思路：签到 12345678910111213while True : try : x, a, y, b = map(int, input().split()) A = x * b B = y * a if A == B : print('=') elif A &lt; B : print('&lt;') elif A &gt; B : print('&gt;') except EOFError : break","categories":[],"tags":[{"name":"2019牛客多校","slug":"2019牛客多校","permalink":"https://hsueh37.gitee.io/blog/tags/2019%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1/"}]},{"title":"Latex命令","slug":"Latex","date":"2019-07-18T05:32:20.000Z","updated":"2020-04-28T09:02:42.268Z","comments":true,"path":"2019/07/18/Latex/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/07/18/Latex/","excerpt":"","text":"希腊字母 latex命令 效果 \\alpha $\\alpha$ \\beta $\\beta$ \\gamma $\\gamma$ \\Delta, \\delta $\\Delta, \\delta$ \\epsilon, \\varepsilon $\\epsilon, \\varepsilon$ \\zeta $\\zeta$ \\eta $\\eta$ \\theta,\\vartheta $\\theta,\\vartheta$ \\iota $\\iota$ \\kappa $\\kappa$ \\lambda $\\lambda$ \\mu $\\mu$ \\nu $\\nu$ \\Xi,\\xi $\\Xi,\\xi$ \\pi, \\varpi $\\pi, \\varpi$ \\rho,\\varrho $\\rho,\\varrho$ \\sum,\\sigma,\\varsigma $\\sum,\\sigma,\\varsigma$ \\tau $\\tau$ \\upsilon $\\upsilon$ \\phi,\\varphi $\\phi,\\varphi$ \\psi $\\psi$ 二元关系符号 latex命令 效果 \\leq,\\le $\\leq,\\le$ \\in $\\in$ \\mid $\\mid$ \\geq,\\ge $\\geq,\\ge$ \\supset $\\supset$ \\parallel $\\parallel$ \\notin $\\notin$ \\equiv $\\equiv$ \\sim $\\sim$ \\approx $\\approx$ \\cong $\\cong$ \\bowtie $\\bowtie$ \\perp $\\perp$ \\neq,\\ne $\\neq,\\ne$ 二元运算 latex命令 效果 \\pm $\\pm$ \\cdot $\\cdot$ \\times $\\times$ \\cup $\\cup$ \\oplus $\\oplus$ \\odot $\\odot$ \\otimes $\\otimes$ \\wedge,\\land $\\wedge,\\land$ \\star $\\star$ \\ast $\\ast$ \\sum $\\sum $ \\prod $\\prod$ \\int $\\int$ \\bigcup $\\bigcup$ \\bigcap $\\bigcap$ \\oint $\\oint$ 箭头 latex命令 效果 \\leftarrow,\\gets $\\leftarrow,\\gets$ \\rightarrow,\\to $\\rightarrow,\\to$ \\leftrightarrow $\\leftrightarrow$ \\Leftarrow $\\Leftarrow$ \\Rightarrow $\\Rightarrow$ \\Leftrightarrow $\\Leftrightarrow$ \\rightleftharpoons $\\rightleftharpoons$ \\hookleftarrow, \\hookrightarrow $\\hookleftarrow, \\hookrightarrow$ \\Longleftarrow,\\Longrightarrow $\\Longleftarrow,\\Longrightarrow$ 微分 latex命令 效果 \\nabla $\\nabla$ \\partial x $\\partial x$ \\mathrm{d}x $\\mathrm{d}x$ \\dot x $\\dot x$ \\ddot y $\\ddot y$ 几何 latex命令 效果 \\Delta,\\triangle $\\Delta,\\triangle$ \\vec{c} $\\vec{c}$ 分数、矩阵和多行列式 latex命令 效果 \\frac{2}{4}=0.5 $\\frac{2}{4}=0.5$","categories":[],"tags":[{"name":"Latex","slug":"Latex","permalink":"https://hsueh37.gitee.io/blog/tags/Latex/"}]},{"title":"HZNU 2019 winter camp","slug":"HZNU-2019-winter-camp","date":"2019-02-15T08:10:00.000Z","updated":"2020-04-28T09:02:42.267Z","comments":true,"path":"2019/02/15/HZNU-2019-winter-camp/","link":"","permalink":"https://hsueh37.gitee.io/blog/2019/02/15/HZNU-2019-winter-camp/","excerpt":"","text":"POJ 1330 Nearest Common Ancestors题意： 给出一棵树，查询两个点$LCA$ 思路：$LCA$模板题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;const int maxn = 1e4 + 10;const int DEG = 20;struct Edge &#123; int to, nxt; inline Edge() &#123;&#125; inline Edge(int to, int nxt) :to(to), nxt(nxt) &#123;&#125;&#125;edge[maxn &lt;&lt; 1];int head[maxn], tot;void Init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;void addedge(int u, int v)&#123; edge[tot] = Edge(v, head[u]); head[u] = tot++; edge[tot] = Edge(u, head[v]); head[v] = tot++;&#125;int fa[maxn][DEG];int deg[maxn];void BFS(int root)&#123; queue&lt;int&gt;q; deg[root] = 0; fa[root][0] = root; q.push(root); while (!q.empty()) &#123; int tmp = q.front(); q.pop(); for (int i = 1; i &lt; DEG; ++i) &#123; fa[tmp][i] = fa[fa[tmp][i - 1]][i - 1]; &#125; for (int i = head[tmp]; i != -1; i = edge[i].nxt) &#123; int v = edge[i].to; if (v == fa[tmp][0]) continue; deg[v] = deg[tmp] + 1; fa[v][0] = tmp; q.push(v); &#125; &#125;&#125;int LCA(int u, int v)&#123; if (deg[u] &gt; deg[v]) swap(u, v); int hu = deg[u]; int hv = deg[v]; int tu = u, tv = v; for (int det = hv - hu, i = 0; det; det &gt;&gt;= 1, ++i) &#123; if (det &amp; 1) &#123; tv = fa[tv][i]; &#125; &#125; if (tu == tv) return tu; for (int i = DEG - 1; i &gt;= 0; --i) &#123; if (fa[tu][i] == fa[tv][i]) continue; tu = fa[tu][i]; tv = fa[tv][i]; &#125; return fa[tu][0];&#125;int n;bool flag[maxn];void RUN()&#123; int t; scanf(\"%d\", &amp;t); while (t--) &#123; scanf(\"%d\", &amp;n); Init(); memset(flag, false, sizeof flag); for (int i = 1; i &lt; n; ++i) &#123; int u, v; ll w; scanf(\"%d %d\", &amp;u, &amp;v); addedge(u, v); flag[v] = true; &#125; int root = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (!flag[i]) &#123; root = i; break; &#125; &#125; BFS(root); int u, v; scanf(\"%d %d\", &amp;u, &amp;v); printf(\"%d\\n\", LCA(u, v)); &#125;&#125;int main()&#123;#ifdef LOCAL_JUDGE freopen(\"Text.txt\", \"r\", stdin);#endif // LOCAL_JUDGE RUN();#ifdef LOCAL_JUDGE fclose(stdin);#endif // LOCAL_JUDGE return 0;&#125; POJ 1470 Closest Common Ancestors题意：给出一棵树，然后给出几组询问，记录每个点作为询问中的最近公共祖先的次数并输出，如果次数为0则不输出 思路：$LCA$模板题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 10;const int DEG = 20;struct Edge &#123; int to, nxt; Edge() &#123;&#125; Edge(int to, int nxt) :to(to), nxt(nxt) &#123;&#125;&#125;edge[maxn &lt;&lt; 1];int head[maxn], tot;int dis[maxn];void addedge(int u, int v)&#123; edge[tot] = Edge(v, head[u]); head[u] = tot++;&#125;void Init()&#123; tot = 0; memset(head, -1, sizeof head);&#125;int fa[maxn][DEG];int deg[maxn];void BFS(int root)&#123; queue&lt;int&gt;q; deg[root] = 0; fa[root][0] = root; q.push(root); while (!q.empty()) &#123; int tmp = q.front(); q.pop(); for (int i = 1; i &lt; DEG; ++i) &#123; fa[tmp][i] = fa[fa[tmp][i - 1]][i - 1]; &#125; for (int i = head[tmp]; i != -1; i = edge[i].nxt) &#123; int v = edge[i].to; if (v == fa[tmp][0]) continue; deg[v] = deg[tmp] + 1; fa[v][0] = tmp; q.push(v); &#125; &#125;&#125;int LCA(int u, int v)&#123; if (deg[u] &gt; deg[v]) swap(u, v); int hu = deg[u]; int hv = deg[v]; int tu = u, tv = v; for (int det = hv - hu, i = 0; det; det &gt;&gt;= 1, ++i) &#123; if (det &amp; 1) &#123; tv = fa[tv][i]; &#125; &#125; if (tu == tv) return tu; for (int i = DEG - 1; i &gt;= 0; --i) &#123; if (fa[tu][i] == fa[tv][i]) continue; tu = fa[tu][i]; tv = fa[tv][i]; &#125; return fa[tu][0];&#125;int n, m;char str[maxn];bool flag[maxn];int arr[maxn];void RUN()&#123; while (~scanf(\"%d\", &amp;n)) &#123; Init(); memset(flag, false, sizeof flag); memset(arr, 0, sizeof arr); for (int i = 1; i &lt;= n; ++i) &#123; int id, m; scanf(\"%d:(%d)\", &amp;id, &amp;m); for (int i = 0; i &lt; m; ++i) &#123; int id2; scanf(\"%d\", &amp;id2); addedge(id, id2); flag[id2] = true; &#125; &#125; int root = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (!flag[i]) &#123; root = i; break; &#125; &#125; BFS(root); int q; scanf(\"%d\", &amp;q); while (q--) &#123; int u, v; scanf(\" (%d %d)\", &amp;u, &amp;v); int root = LCA(u, v); arr[root]++; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (arr[i]) &#123; printf(\"%d:%d\\n\", i, arr[i]); &#125; &#125; &#125;&#125;int main()&#123;#ifdef LOCAL_JUDGE freopen(\"Text.txt\", \"r\", stdin);#endif // LOCAL_JUDGE RUN();#ifdef LOCAL_JUDGE fclose(stdin);#endif // LOCAL_JUDGE return 0;&#125; HDU 2586 How far away ？题意：给出一棵树，每条边有边权，然后给出几组询问，每组询问需要输出$u, v$之间的最短路径。 思路： 对于一棵树，两个点的路径唯一。 这两个点的路径长度为u到根的路径长度加上v到根的路径长度减去两倍LCA(u, v)到根的路径长度。 即$dis_u+dis_v-2 \\cdot dis_{LCA_{u, v}}$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e5 + 10;const int DEG = 20;int dis[maxn];struct Edge &#123; int to; int next; int w; Edge() &#123;&#125; Edge(int to, int next, int w) :to(to), next(next), w(w) &#123;&#125;&#125;edge[maxn &lt;&lt; 1];int head[maxn];int tot;void addedge(int u, int v, int w)&#123; edge[tot] = Edge(v, head[u], w); head[u] = tot++;&#125;void init()&#123; tot = 0; memset(head, -1, sizeof head); memset(dis, 0x3f, sizeof dis);&#125;int fa[maxn][DEG];int deg[maxn];void BFS(int root)&#123; queue&lt;int&gt;q; deg[root] = 0; fa[root][0] = root; q.push(root); dis[root] = 0; while (!q.empty()) &#123; int tmp = q.front(); q.pop(); for (int i = 1; i &lt; DEG; ++i) &#123; fa[tmp][i] = fa[fa[tmp][i - 1]][i - 1]; &#125; for (int i = head[tmp]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (v == fa[tmp][0]) continue; dis[v] = dis[tmp] + edge[i].w; deg[v] = deg[tmp] + 1; fa[v][0] = tmp; q.push(v); &#125; &#125;&#125;int LCA(int u, int v)&#123; if (deg[u] &gt; deg[v]) swap(u, v); int hu = deg[u], hv = deg[v]; int tu = u; int tv = v; for (int det = hv - hu, i = 0; det; det &gt;&gt;= 1, ++i) &#123; if (det &amp; 1) &#123; tv = fa[tv][i]; &#125; &#125; if (tu == tv) return tu; for (int i = DEG - 1; i &gt;= 0; --i) &#123; if (fa[tu][i] == fa[tv][i]) continue; tu = fa[tu][i]; tv = fa[tv][i]; &#125; return fa[tu][0];&#125;void RUN()&#123; int t; scanf(\"%d\", &amp;t); while (t--) &#123; init(); int n, q; scanf(\"%d %d\", &amp;n, &amp;q); for (int i = 1; i &lt; n; ++i) &#123; int u, v, w; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); addedge(u, v, w); addedge(v, u, w); &#125; BFS(1); while (q--) &#123; int u, v; scanf(\"%d %d\", &amp;u, &amp;v); int root = LCA(u, v); int ans = dis[u] + dis[v] - 2 * dis[root]; printf(\"%d\\n\", ans); &#125; &#125;&#125;int main()&#123;#ifdef LOCAL_JUDGE freopen(\"Text.txt\", \"r\", stdin);#endif // LOCAL_JUDGE RUN();#ifdef LOCAL_JUDGE fclose(stdin);#endif // LOCAL_JUDGE return 0;&#125; HDU 2874 Connections between cities题意：给出一张图，保证无环，但是不保证连通，求出两个点的最短距离，如果不连通就输出$”Not \\quad connected”$。 思路： 由于保证无环，那么给出的图就是一颗或者多颗树。 那么可以用并查集来维护两点是否在一个集合中，也就是一棵树中。 对于在一棵树上的$u,v$两点，距离就是$dis_u+dis_v-2 \\cdot dis_{LCA_{u, v}}$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 10;const int DEG = 20;int n, m, q;int Fa[maxn];int dis[maxn];int find(int x)&#123; return x == Fa[x] ? Fa[x] : Fa[x] = find(Fa[x]);&#125;void mix(int x, int y)&#123; x = find(x); y = find(y); if (x != y) &#123; Fa[x] = y; &#125;&#125;struct Edge &#123; int to; int next; int w; Edge() &#123;&#125; Edge(int to, int next, int w) :to(to), next(next), w(w) &#123;&#125;&#125;edge[maxn &lt;&lt; 1];int head[maxn];int tot;void addedge(int u, int v, int w)&#123; edge[tot] = Edge(v, head[u], w); head[u] = tot++;&#125;void init()&#123; tot = 0; memset(head, -1, sizeof head); memset(dis, 0, sizeof dis); for (int i = 1; i &lt;= n; ++i) &#123; Fa[i] = i; &#125;&#125;int fa[maxn][DEG];int deg[maxn];void BFS()&#123; queue&lt;int&gt;q; for (int i = 1; i &lt;= n; ++i) &#123; if (find(i) == i) &#123; deg[i] = 0; fa[i][0] = i; dis[i] = 0; q.push(i); &#125; &#125; while (!q.empty()) &#123; int tmp = q.front(); q.pop(); for (int i = 1; i &lt; DEG; ++i) &#123; fa[tmp][i] = fa[fa[tmp][i - 1]][i - 1]; &#125; for (int i = head[tmp]; i != -1; i = edge[i].next) &#123; int v = edge[i].to; if (v == fa[tmp][0]) continue; dis[v] = dis[tmp] + edge[i].w; deg[v] = deg[tmp] + 1; fa[v][0] = tmp; q.push(v); &#125; &#125;&#125;int LCA(int u, int v)&#123; if (deg[u] &gt; deg[v]) swap(u, v); int hu = deg[u], hv = deg[v]; int tu = u; int tv = v; for (int det = hv - hu, i = 0; det; det &gt;&gt;= 1, ++i) &#123; if (det &amp; 1) &#123; tv = fa[tv][i]; &#125; &#125; if (tu == tv) return tu; for (int i = DEG - 1; i &gt;= 0; --i) &#123; if (fa[tu][i] == fa[tv][i]) continue; tu = fa[tu][i]; tv = fa[tv][i]; &#125; return fa[tu][0];&#125;void solve()&#123; int u, v; scanf(\"%d %d\", &amp;u, &amp;v); int rootu = find(u); int rootv = find(v); if (rootu != rootv) &#123; puts(\"Not connected\"); return; &#125; int root = LCA(u, v); int ans = dis[u] + dis[v] - 2 * dis[root]; printf(\"%d\\n\", ans);&#125;void RUN()&#123; while (~scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;q)) &#123; init(); for (int i = 0; i &lt; m; ++i) &#123; int u, v, w; scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;w); addedge(u, v, w); addedge(v, u, w); mix(u, v); &#125; BFS(); while (q--) &#123; solve(); &#125; &#125;&#125;int main()&#123;#ifdef LOCAL_JUDGE freopen(\"Text.txt\", \"r\", stdin);#endif // LOCAL_JUDGE RUN();#ifdef LOCAL_JUDGE fclose(stdin);#endif // LOCAL_JUDGE return 0;&#125; POJ - 3417 Network题意：给出一棵树和一些非树边，你可以选择破坏一条树边以及一条非树边，问有多少种方式可以破坏这棵树。 思路： 对于每条非树边$u-v$都可以形成一个$u-LCA_{u, v}-v-u$的环，如果破坏这个这个环则只能选择环上一个树边以及新加入的非树边。 如果某条树边被多个环覆盖那么无法通过破坏这条边以及非树边来破坏整棵树。 如果某条树边没有被环覆盖那么可以通过破坏这条树边以及任意一条非树边来破坏整棵树。 最后可以通过$LCA$以及树上差分(前缀和？)来优化求出每条树边被多少个环覆盖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;typedef long long ll;const int maxn = 1e6 + 10;const int DEG = 20;struct Edge &#123; int to, nxt; Edge() &#123;&#125; Edge(int to, int nxt) :to(to), nxt(nxt) &#123;&#125;&#125;edge[maxn &lt;&lt; 1];int head[maxn], tot;int dis[maxn];void addedge(int u, int v)&#123; edge[tot] = Edge(v, head[u]); head[u] = tot++;&#125;void init()&#123; memset(head, -1, sizeof head); tot = 0;&#125;int fa[maxn][DEG];int deg[maxn];void BFS(int root)&#123; queue&lt;int&gt;q; deg[root] = 0; fa[root][0] = root; q.push(root); while (!q.empty()) &#123; int tmp = q.front(); q.pop(); for (int i = 1; i &lt; DEG; ++i) &#123; fa[tmp][i] = fa[fa[tmp][i - 1]][i - 1]; &#125; for (int i = head[tmp]; i != -1; i = edge[i].nxt) &#123; int v = edge[i].to; if (v == fa[tmp][0]) continue; deg[v] = deg[tmp] + 1; fa[v][0] = tmp; q.push(v); &#125; &#125;&#125;int LCA(int u, int v)&#123; if (deg[u] &gt; deg[v]) swap(u, v); int hu = deg[u]; int hv = deg[v]; int tu = u, tv = v; for (int det = hv - hu, i = 0; det; det &gt;&gt;= 1, ++i) &#123; if (det &amp; 1) &#123; tv = fa[tv][i]; &#125; &#125; if (tu == tv) return tu; for (int i = DEG - 1; i &gt;= 0; --i) &#123; if (fa[tu][i] == fa[tv][i]) continue; tu = fa[tu][i]; tv = fa[tv][i]; &#125; return fa[tu][0];&#125;int n, m;ll arr[maxn];void DFS(int u, int pre)&#123; for (int i = head[u]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to; if (v == pre) continue; DFS(v, u); arr[u] += arr[v]; &#125;&#125;void RUN()&#123; while (~scanf(\"%d %d\", &amp;n, &amp;m)) &#123; init(); memset(arr, 0, sizeof arr); for (int i = 1; i &lt; n; ++i) &#123; int u, v; scanf(\"%d %d\", &amp;u, &amp;v); addedge(u, v); addedge(v, u); &#125; BFS(1); for (int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf(\"%d %d\", &amp;u, &amp;v); arr[u]++; arr[v]++; arr[LCA(u, v)] -= 2; &#125; DFS(1, -1); ll ans = 0; for (int i = 2; i &lt;= n; ++i) &#123; if (!arr[i]) &#123; ans += m; &#125; else if (arr[i] == 1) &#123; ans++; &#125; &#125; printf(\"%lld\\n\", ans); &#125;&#125;int main()&#123;#ifdef LOCAL_JUDGE freopen(\"Text.txt\", \"r\", stdin);#endif // LOCAL_JUDGE RUN();#ifdef LOCAL_JUDGE fclose(stdin);#endif // LOCAL_JUDGE return 0;&#125; UVALive - 8196 Imperial roads题意：给出一张图，然后询问给出一条边，求有这条边的最小生成树的权值和。 思路： 先求最小生成树，然后询问的边如果在最小生成树里面那么就是原来的最小生成树的权值和。 否则在原来的最小生成树里面的加入一条边，形成个环，然后去掉这个环里面除了加入的边之外的边权最大的边即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 2e5 + 10;const int DEG = 20;int n, m;struct node &#123; int u, v; ll w; node() &#123;&#125; node(int u, int v, ll w) : u(u), v(v), w(w) &#123;&#125; inline bool operator&lt;(const node &amp;b) const &#123; return w &lt; b.w; &#125;&#125;;struct Edge &#123; int to; int nxt; ll w; Edge() &#123;&#125; Edge(int to, int nxt, ll w) : to(to), nxt(nxt), w(w) &#123;&#125;&#125; edge[maxn &lt;&lt; 1];int dis[maxn][DEG];bool inMST[maxn &lt;&lt; 1];int head[maxn];int tot;int father[maxn];vector&lt;node&gt; G;int cnt;map&lt;pair&lt;int, int&gt;, int&gt; mp;void addedge(int u, int v, ll w) &#123; edge[tot] = Edge(v, head[u], w); head[u] = tot++; edge[tot] = Edge(u, head[v], w); head[v] = tot++;&#125;void Init() &#123; G.clear(); cnt = 0; tot = 0; memset(dis, 0, sizeof dis); memset(head, -1, sizeof head); for (int i = 1; i &lt;= n; ++i) &#123; father[i] = i; &#125;&#125;int find(int x) &#123; return x == father[x] ? father[x] : father[x] = find(father[x]);&#125;void mix(int x, int y) &#123; x = find(x); y = find(y); if (x != y) &#123; father[x] = y; &#125;&#125;bool same(int x, int y) &#123; return find(x) == find(y);&#125;ll MST() &#123; mp.clear(); ll res = 0; sort(G.begin(), G.end()); memset(inMST,false, sizeof inMST); for (auto it: G) &#123; int u = it.u; int v = it.v; mp[make_pair(v, u)] =cnt; mp[make_pair(u, v)] = cnt++; &#125; for (auto it: G) &#123; int u = it.u; int v = it.v; if (same(u, v)) continue; mix(u, v); inMST[mp[make_pair(u, v)]] = true; addedge(u, v, it.w); res += it.w; &#125; return res;&#125;int fa[maxn][DEG];int deg[maxn];void BFS(int root) &#123; queue&lt;int&gt; q; deg[root] = 0; fa[root][0] =root; q.push(root); while (!q.empty()) &#123; int tmp = q.front(); q.pop(); for (int i = 1;i &lt; DEG;++i) &#123; dis[tmp][i] =max(dis[tmp][i - 1], dis[fa[tmp][i - 1]][i - 1]); fa[tmp][i] = fa[fa[tmp][i - 1]][i - 1]; &#125; for (int i = head[tmp];~i;i = edge[i].nxt) &#123; int v = edge[i].to; if (v == fa[tmp][0]) continue; deg[v] = deg[tmp] + 1; fa[v][0] =tmp; int id = mp[make_pair(tmp, v)]; dis[v][0] = G[id].w; q.push(v); &#125; &#125;&#125;int LCA(int u, int v) &#123; int res = 0; if (deg[u] &gt; deg[v])swap(u, v); int hu = deg[u], hv = deg[v]; int tu = u, tv = v; for (int det = hv - hu, i = 0;det;det &gt;&gt;= 1, ++i) &#123; if (det &amp; 1) &#123; res = max(res, dis[tv][i]); tv = fa[tv][i]; &#125; &#125; if (tu == tv)return res; for (int i = DEG - 1;i &gt;= 0; --i) &#123; if (fa[tu][i] == fa[tv][i]) continue; res = max(res, max(dis[tu][i], dis[tv][i])); tu = fa[tu][i]; tv = fa[tv][i]; &#125; res = max(res, max(dis[tu][0], dis[tv][0])); return res;&#125;void RUN() &#123; while (~scanf(\"%d %d\", &amp;n, &amp;m)) &#123; Init(); for (int i = 1;i &lt;=m;++i) &#123; int u, v; ll w; scanf(\"%d %d %lld\", &amp;u, &amp;v, &amp;w); G.push_back(node(u, v, w)); &#125; ll ans = MST(); BFS(1); int q; scanf(\"%d\", &amp;q); while (q--) &#123; int u, v; scanf(\"%d %d\", &amp;u, &amp;v); int id = mp[make_pair(u, v)]; ll w = G[id].w; if (inMST[id]) &#123; printf(\"%lld\\n\", ans); &#125; else &#123; ll res = LCA(u, v); printf(\"%lld\\n\", ans + w - res); &#125; &#125; &#125;&#125;int main() &#123;#ifdef LOCAL_JUDGE freopen(\"Text.txt\", \"r\", stdin);#endif // LOCAL_JUDGE RUN();#ifdef LOCAL_JUDGE fclose(stdin);#endif // LOCAL_JUDGE return 0;&#125; HDU - 4547 CD操作题意： 思路： 从$u-v$的操作数为$dis_u-dis_{LCA{u, v}}$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn = 1e5 + 10;const int DEG = 20;struct Edge &#123; int to, nxt; inline Edge() &#123;&#125; inline Edge(int to, int nxt) :to(to), nxt(nxt) &#123;&#125;&#125;edge[maxn &lt;&lt; 1];int head[maxn], tot;map&lt;string, int&gt;mp;int dis[maxn];inline void addedge(int u, int v)&#123; edge[tot] = Edge(v, head[u]); head[u] = tot++;&#125;inline void init()&#123; memset(head, -1, sizeof head); tot = 0;&#125;int fa[maxn][DEG];int deg[maxn];inline void BFS(int root)&#123; queue&lt;int&gt;q; deg[root] = 0; dis[root] = 0; fa[root][0] = root; q.push(root); while (!q.empty()) &#123; int tmp = q.front(); q.pop(); for (int i = 1; i &lt; DEG; ++i) &#123; fa[tmp][i] = fa[fa[tmp][i - 1]][i - 1]; &#125; for (int i = head[tmp]; i != -1; i = edge[i].nxt) &#123; int v = edge[i].to; if (v == fa[tmp][0]) continue; deg[v] = deg[tmp] + 1; dis[v] = dis[tmp] + 1; fa[v][0] = tmp; q.push(v); &#125; &#125;&#125;inline int LCA(int u, int v)&#123; if (deg[u] &gt; deg[v]) swap(u, v); int hu = deg[u]; int hv = deg[v]; int tu = u, tv = v; for (int det = hv - hu, i = 0; det; det &gt;&gt;= 1, ++i) &#123; if (det &amp; 1) &#123; tv = fa[tv][i]; &#125; &#125; if (tu == tv) return tu; for (int i = DEG - 1; i &gt;= 0; --i) &#123; if (fa[tu][i] == fa[tv][i]) continue; tu = fa[tu][i]; tv = fa[tv][i]; &#125; return fa[tu][0];&#125;int n, m;bool flag[maxn];inline void RUN()&#123; int t; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n &gt;&gt; m; init(); mp.clear(); int cnt = 1; memset(flag, false, sizeof flag); for (int i = 1; i &lt; n; ++i) &#123; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; if (mp[s1] == 0) &#123; mp[s1] = cnt++; &#125; if (mp[s2] == 0) &#123; mp[s2] = cnt++; &#125; addedge(mp[s2], mp[s1]); addedge(mp[s1], mp[s2]); flag[mp[s1]] = true; &#125; int root = 0; for (int i = 1; i &lt; cnt; ++i) &#123; if (!flag[i]) &#123; root = i; break; &#125; &#125; BFS(root); while (m--) &#123; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; int u = mp[s1]; int v = mp[s2]; int tmp = LCA(u, v); int ans = dis[u] - dis[tmp]; if (tmp != v) &#123; ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125;&#125;int main()&#123;#ifdef LOCAL_JUDGE freopen(\"Text.txt\", \"r\", stdin);#endif // LOCAL_JUDGE RUN();#ifdef LOCAL_JUDGE fclose(stdin);#endif // LOCAL_JUDGE return 0;&#125; ZOJ - 4048 Red Black Tree题意：有一个树，上面有红点和黑点，有边权，每个点的花费定义为它到离它最近的红点的距离，每次询问给出一些点，能够将这棵树中的一个黑点变为红点，使得这些点中的最大花费最小 思路： 二分答案，符合条件的点不管，将不符合条件的点LCA求出来，变红，然后算距离 ST表求LCA可直接过，复杂度为$O(n \\cdot log_n)$。 倍增求LCA复杂度为$O(n \\cdot log_n \\cdot log_n)$。 倍增求LCA可先根据深度排序，当有两个不符合的点上方的红点不同时则不能通过修改一个点使得所有不符合的点都产生改变，从而剪枝。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int INF = 0x3f3f3f3f;const ll INFLL = 0x3f3f3f3f3f3f3f3f;const ll MOD = (int)1e9 + 7;const int maxn = (int)1e5 + 10;const int DEG = 20;struct Edge &#123; int to, nxt; ll w; Edge() &#123;&#125; Edge(int to, int nxt, ll w) :to(to), nxt(nxt), w(w) &#123;&#125;&#125;edge[maxn &lt;&lt; 1];int head[maxn], tot;int red[maxn];void addedge(int u, int v, ll w)&#123; edge[tot] = Edge(v, head[u], w); head[u] = tot++;&#125;void Init(int n)&#123; for (int i = 1; i &lt;= n; ++i) &#123; red[i] = 0; head[i] = -1; &#125; tot = 0;&#125;ll dis[maxn];int fa[maxn][DEG];int deg[maxn];int pre[maxn];void BFS(int root)&#123; queue&lt;int&gt;q; dis[root] = 0; deg[root] = 0; fa[root][0] = root; pre[root] = root; q.push(root); while (!q.empty()) &#123; int tmp = q.front(); q.pop(); for (int i = 1; i &lt; DEG; ++i) &#123; fa[tmp][i] = fa[fa[tmp][i - 1]][i - 1]; &#125; for (int i = head[tmp]; ~i; i = edge[i].nxt) &#123; int v = edge[i].to; ll w = edge[i].w; if (v == fa[tmp][0]) continue; deg[v] = deg[tmp] + 1; fa[v][0] = tmp; if (red[v]) &#123; pre[v] = v; &#125; else &#123; pre[v] = pre[tmp]; &#125; if (red[v]) &#123; dis[v] = 0; &#125; else &#123; dis[v] = dis[tmp] + w; &#125; q.push(v); &#125; &#125;&#125;int LCA(int u, int v)&#123; if (deg[u] &gt; deg[v]) swap(u, v); int hu = deg[u], hv = deg[v]; int tu = u, tv = v; for (int det = hv - hu, i = 0; det; det &gt;&gt;= 1, ++i) &#123; if (det &amp; 1) &#123; tv = fa[tv][i]; &#125; &#125; if (tu == tv) return tu; for (int i = DEG - 1; i &gt;= 0; --i) &#123; if (fa[tu][i] == fa[tv][i]) continue; tu = fa[tu][i], tv = fa[tv][i]; &#125; return fa[tu][0];&#125;int n, m, q, k;int arr[maxn];bool cmp(int a, int b)&#123; return dis[a] &gt; dis[b];&#125;bool check(ll mid)&#123; int root = arr[1]; int cnt = 0; for (int i = 1; i &lt;= k; ++i) &#123; if (dis[arr[i]] &gt; mid) &#123; if (pre[root] != pre[arr[i]]) return false; root = LCA(root, arr[i]); cnt++; &#125; &#125; if (cnt == 1 || cnt == 0) return true; for (int i = 1; i &lt;= k; ++i) &#123; if (dis[arr[i]] &gt; mid) &#123; if (dis[arr[i]] - dis[root] &gt; mid) return false; &#125; &#125; return true;&#125;void RUN()&#123; int t; scanf(\"%d\", &amp;t); while (t--) &#123; scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;q); Init(n); for (int i = 1; i &lt;= m; ++i) &#123; int u; scanf(\"%d\", &amp;u); red[u] = 1; &#125; for (int i = 1; i &lt; n; ++i) &#123; int u, v; ll w; scanf(\"%d %d %lld\", &amp;u, &amp;v, &amp;w); addedge(u, v, w); addedge(v, u, w); &#125; BFS(1); while (q--) &#123; scanf(\"%d\", &amp;k); for (int i = 1; i &lt;= k; ++i) &#123; scanf(\"%d\", arr + i); &#125; if (k == 1) &#123; puts(\"0\"); continue; &#125; sort(arr + 1, arr + 1 + k, cmp); ll l = 0; ll r = INFLL; ll ans = 0; while (r - l &gt;= 0) &#123; ll mid = (r + l) &gt;&gt; 1; if (check(mid)) &#123; r = mid - 1; ans = mid; &#125; else &#123; l = mid + 1; &#125; &#125; printf(\"%lld\\n\", ans); &#125; &#125;&#125;int main()&#123;#ifdef LOCAL_JUDGE freopen(\"Text.txt\", \"r\", stdin);#endif // LOCAL_JUDGE RUN();#ifdef LOCAL_JUDGE fclose(stdin);#endif // LOCAL_JUDGE return 0;&#125;","categories":[],"tags":[{"name":"讲课","slug":"讲课","permalink":"https://hsueh37.gitee.io/blog/tags/%E8%AE%B2%E8%AF%BE/"}]}]}